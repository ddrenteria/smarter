<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Office Duel - New UI v17.0 - Double Turn Phase Timers</title>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <script>
    // Force refresh if cached
    if(window.location.search.indexOf('v=') === -1) {
      window.location.href = window.location.href + '?v=' + Date.now();
    }
  </script>
  <style>
    body { 
      font-family: sans-serif; 
      margin: 0; 
      padding: 20px; 
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      min-height: 100vh;
    }
    
    h1 {
      text-align: center;
      color: #333;
      margin-bottom: 30px;
      font-size: 2.5em;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    
    /* Screen Management Styles */
    .screen {
      min-height: 70vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    
    .screen-content {
      background: white;
      padding: 40px;
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
      text-align: center;
      max-width: 500px;
      width: 100%;
    }
    
    .screen-content h2 {
      color: #333;
      margin-bottom: 20px;
      font-size: 2em;
    }
    
    .screen-content p {
      color: #666;
      margin-bottom: 30px;
      font-size: 1.1em;
    }
    
    /* Home Screen Styles */
    .home-buttons {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .home-btn {
      background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%);
      color: white;
      border: none;
      padding: 20px 30px;
      border-radius: 12px;
      font-size: 1.2em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 16px rgba(33, 150, 243, 0.3);
    }
    
    .home-btn:hover {
      background: linear-gradient(135deg, #1976d2 0%, #1565c0 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(33, 150, 243, 0.4);
    }
    
    .home-btn:active {
      transform: translateY(0);
    }
    
    /* Input Group Styles */
    .input-group {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin: 20px 0;
    }
    
    .input-group input {
      padding: 15px;
      border: 2px solid #ddd;
      border-radius: 8px;
      font-size: 1em;
      transition: border-color 0.3s ease;
    }
    
    .input-group input:focus {
      outline: none;
      border-color: #2196f3;
      box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
    }
    
    .action-btn {
      background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
      color: white;
      border: none;
      padding: 15px 30px;
      border-radius: 8px;
      font-size: 1.1em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 16px rgba(76, 175, 80, 0.3);
    }
    
    .action-btn:hover {
      background: linear-gradient(135deg, #45a049 0%, #3d8b40 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
    }
    
    .secondary-btn {
      background: transparent;
      color: #666;
      border: 2px solid #ddd;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 1em;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-top: 20px;
    }
    
    .secondary-btn:hover {
      background: #f5f5f5;
      border-color: #bbb;
    }

    /* Game Styles */
    .game-container { 
      display: grid; 
      grid-template-columns: auto 1fr; 
      grid-template-rows: auto 1fr auto; 
      gap: 20px; 
      min-height: 80vh;
      width: 100%;
    }
    .game-header { grid-column: 2; grid-row: 1; }
    .game-main { grid-column: 2; grid-row: 2; }
    .game-footer { grid-column: 2; grid-row: 3; }
    .game-sidebar { grid-column: 1; grid-row: 1 / 4; }
    .player-section { border: 2px solid #ddd; padding: 20px; border-radius: 12px; background: white; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    .player-section.active { background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); border-color: #2196f3; box-shadow: 0 4px 16px rgba(33, 150, 243, 0.3); }
    .player-section h3 { margin: 0 0 15px 0; font-size: 1.2em; color: #333; }
    .player-area-label { 
      display: inline-block; 
      background: #2196f3; 
      color: white; 
      padding: 4px 12px; 
      border-radius: 20px; 
      font-size: 0.8em; 
      margin-bottom: 10px; 
    }
    .player-area-label.opponent { background: #ff5722; }
    .hand { display: flex; gap: 8px; margin: 10px 0; flex-wrap: wrap; }
    .card {
      width: 140px;
      min-height: 200px;
      padding: 10px;
      border: 2px solid #888;
      border-radius: 8px;
      cursor: pointer;
      background: white;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      justify-content: flex-start;
      text-align: center;
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .card:hover { 
      background: #f0f8ff; 
      border-color: #2196f3; 
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    .card.selected { 
      background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); 
      border-color: #2196f3; 
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
    }
    .card-title { font-weight: bold; margin-bottom: 6px; }
    .card-effects { list-style: none; padding: 0; margin: 0; font-size: 12px; text-align: left; }
    .card-effects li { color: #000; }
    .card-effects li.active { color: #28a745; font-weight: bold; }
    
    /* Effect highlighting for choose modal */
    .card-effects li.effect-mine { 
      color: #3da7ff !important; 
      font-weight: bold; 
      background: rgba(61, 167, 255, 0.1);
      padding: 2px 6px;
      border-radius: 4px;
      margin: 1px 0;
    }
    .card-effects li.effect-opponent { 
      color: #ff9d46 !important; 
      font-weight: bold; 
      background: rgba(255, 157, 70, 0.1);
      padding: 2px 6px;
      border-radius: 4px;
      margin: 1px 0;
    }
    .tableau { display: flex; gap: 4px; margin: 10px 0; flex-wrap: wrap; }
    .tableau-card {
      width: 140px;
      min-height: 200px;
      padding: 8px;
      border: 2px solid #ccc;
      border-radius: 6px;
      background: #f9f9f9;
      font-size: 12px;
      position: relative;
      display: flex;
      flex-direction: column;
      text-align: center;
    }
    .stacked-card { position: relative; }
    .card-count-badge { 
      position: absolute; 
      top: -8px; 
      right: -8px; 
      background: #ff4444; 
      color: white; 
      border-radius: 50%; 
      width: 20px; 
      height: 20px; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      font-size: 10px; 
      font-weight: bold; 
      border: 2px solid white;
    }
    .card-tooltip { position: relative; }
    .card-tooltip:hover .tooltip-content { display: block; }
    .tooltip-content { 
      display: none; position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); 
      background: #333; color: white; padding: 8px; border-radius: 4px; white-space: nowrap; 
      z-index: 1000; font-size: 12px; max-width: 300px; white-space: normal;
    }
    .log { white-space: pre-wrap; font-family: monospace; max-height: 200px; overflow: auto; border: 1px solid #eee; padding: 8px; background: #f9f9f9; }
    .status { font-weight: bold; margin: 10px 0; }
    .choice-cards {
      display: flex;
      gap: 20px;
      margin: 10px 0;
    }
    .choice-card {
      border: 2px solid #28a745;
      border-radius: 8px;
      padding: 15px;
      background: #f8f9fa;
      text-align: center;
      flex: 1;
    }
    .choice-card button {
      margin-top: 10px;
      padding: 8px 16px;
      background: #28a745;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .choice-card button:hover {
      background: #218838;
    }
    .shared-counter {
      text-align: center;
      margin: 20px 0;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 12px;
      color: white;
      min-width: 200px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    .dot-display {
      margin: 15px 0;
    }
    .dot-value {
      font-size: 48px;
      font-weight: bold;
      margin: 10px 0;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    .dot-labels {
      display: flex;
      justify-content: space-between;
      font-size: 14px;
      margin-top: 10px;
    }
    .player-label {
      background: rgba(255,255,255,0.2);
      padding: 5px 10px;
      border-radius: 15px;
    }
    .neutral-label {
      background: rgba(255,255,255,0.3);
      padding: 5px 10px;
      border-radius: 15px;
      font-weight: bold;
    }
    .winner-display {
      margin-top: 15px;
      padding: 15px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      border: 2px solid #fff;
    }
    .winner-display h2 {
      margin: 0;
      color: #fff;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }
    
    .winner-display .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      text-decoration: none;
      display: inline-block;
      margin: 0 5px;
    }

    .winner-display .btn-primary {
      background: linear-gradient(45deg, #4CAF50, #45a049);
      color: white;
    }

    .winner-display .btn-primary:hover {
      background: linear-gradient(45deg, #45a049, #3d8b40);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
    }

    .winner-display .btn-secondary {
      background: linear-gradient(45deg, #6c757d, #5a6268);
      color: white;
    }

    .winner-display .btn-secondary:hover {
      background: linear-gradient(45deg, #5a6268, #495057);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(108, 117, 125, 0.4);
    }
    /* Enhanced Timer Styling */
    .timer-display {
      display: inline-block;
      padding: 8px 16px;
      border-radius: 20px;
      font-weight: bold;
      font-size: 1.1em;
      transition: all 0.3s ease;
      background: #4caf50;
      color: white;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    .timer-display.warning { background: #ff9800; }
    .timer-display.danger { background: #f44336; animation: pulse 1s infinite; }
    @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
    
    /* Enhanced Choice Modal - Bottom Sheet Style */
    .choice-modal {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 45vh;
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      border-top: 4px solid #2196f3;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transform: translateY(100%);
      transition: transform 0.3s ease-in-out;
      box-shadow: 0 -8px 32px rgba(0,0,0,0.3);
    }
    .choice-modal.show {
      transform: translateY(0);
    }
    .choice-modal-content {
      background: transparent;
      padding: 20px;
      width: 100%;
      max-width: 800px;
    }
    
    /* Desktop sidebar variant */
    @media (min-width: 900px) {
      .choice-modal {
        position: fixed;
        top: 0;
        right: 0;
        width: 35%;
        height: 100vh;
        left: auto;
        bottom: auto;
        transform: translateX(100%);
        border-top: none;
        border-left: 4px solid #2196f3;
      }
      .choice-modal.show {
        transform: translateX(0);
      }
    }
    
    .choice-btn {
      background: #2196f3;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 1.1em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 2px 8px rgba(33, 150, 243, 0.3);
    }
    
    .choice-btn:hover {
      background: #1976d2;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
    }
    
    .choice-btn:active {
      transform: translateY(0);
    }
    
    /* Layout specific styles */
    .game-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 0;
    }
    
    .timer-top-right {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 100;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .auto-turn-btn {
      background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 0.9em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 2px 8px rgba(255, 152, 0, 0.3);
    }
    
    .auto-turn-btn:hover {
      background: linear-gradient(135deg, #f57c00 0%, #ef6c00 100%);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(255, 152, 0, 0.4);
    }
    
    .enemy-area {
      margin-bottom: 20px;
    }
    
    .player-area {
      margin-top: 20px;
    }
    
    /* Play Cards Section */
    .play-cards-section {
      margin-top: 20px;
      padding: 15px;
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      border-radius: 8px;
      border: 2px solid #dee2e6;
    }
    
    .play-selected-btn {
      background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 1.1em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
      width: 100%;
      margin-top: 10px;
    }
    
    .play-selected-btn:hover {
      background: linear-gradient(135deg, #218838 0%, #1aa179 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(40, 167, 69, 0.4);
    }
    
    .play-selected-btn:active {
      transform: translateY(0);
    }
    
    .play-selected-btn:disabled {
      background: #6c757d;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    /* Modal Card Display */
    .modal-card-display {
      background: white;
      border: 2px solid #ddd;
      border-radius: 8px;
      padding: 15px;
      margin: 10px 0;
      min-height: 120px;
      display: flex;
      flex-direction: column;
    }
    
    .modal-card-title {
      font-weight: bold;
      font-size: 1.1em;
      color: #333;
      margin-bottom: 10px;
      text-align: center;
    }
    
    .modal-card-effects {
      font-size: 0.9em;
      color: #666;
      line-height: 1.4;
    }
    
    .modal-card-effects ul {
      margin: 0;
      padding-left: 20px;
      list-style-type: disc;
    }
    
    .modal-card-effects li {
      margin: 4px 0;
    }
    
    .modal-card-title.hidden-card {
      color: #666 !important;
      font-style: italic !important;
      position: relative;
    }
    
    .modal-card-title.hidden-card::after {
      content: " (Hidden)";
      font-size: 0.8em;
      color: #999;
    }

    /* Ready Screen Styles */
    .match-info {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 8px;
      margin: 20px 0;
    }
    
    .copy-btn {
      background: #ff9800;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 0.9em;
      cursor: pointer;
      margin-left: 10px;
      transition: all 0.3s ease;
    }
    
    .copy-btn:hover {
      background: #f57c00;
    }
    
    .players-status {
      margin: 30px 0;
    }
    
    .player-status {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 15px;
      margin: 10px 0;
      background: #f8f9fa;
      border-radius: 8px;
      border-left: 4px solid #2196f3;
    }
    
    .player-label {
      font-weight: bold;
      color: #333;
    }
    
    .ready-status {
      font-weight: bold;
    }
    
    .ready-status.ready {
      color: #4caf50;
    }
    
    .ready-status.not-ready {
      color: #f44336;
    }
    
    .ready-btn {
      background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
      color: white;
      border: none;
      padding: 20px 40px;
      border-radius: 12px;
      font-size: 1.3em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 16px rgba(76, 175, 80, 0.3);
      margin: 20px 0;
    }
    
    .ready-btn:hover {
      background: linear-gradient(135deg, #45a049 0%, #3d8b40 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
    }
    
    .waiting-message {
      color: #666;
      font-style: italic;
      margin-top: 20px;
    }
  </style>
</head>
<body>
   <h1>üéÆ Office Duel - New 4-Screen UI v17.0 - Double Turn Phase Timers</h1>
  
  <!-- Screen 1: Home Screen -->
  <div id="homeScreen" class="screen" style="display: block;">
    <div class="screen-content">
      <h2>üéÆ Welcome to Office Duel!</h2>
      <p>Choose how you want to play:</p>
      <div class="home-buttons">
        <button id="createMatchBtn" class="home-btn">üè¢ Create Match</button>
        <button id="joinMatchBtn" class="home-btn">üîó Join Match</button>
        <button id="playBotBtn" class="home-btn">ü§ñ Play vs Bot</button>
    </div>
    </div>
  </div>

  <!-- Screen 2: Create Match Screen -->
  <div id="createMatchScreen" class="screen" style="display: none;">
    <div class="screen-content">
      <h2>Create New Match</h2>
      <p>Enter your name to create a match:</p>
      <div class="input-group">
        <input id="createPlayerName" type="text" placeholder="Your name" />
        <button id="confirmCreateBtn" class="action-btn">Create Match</button>
      </div>
      <button id="backToHomeBtn" class="secondary-btn">‚Üê Back to Home</button>
    </div>
  </div>
  
  <!-- Screen 2: Join Match Screen -->
  <div id="joinMatchScreen" class="screen" style="display: none;">
    <div class="screen-content">
      <h2>Join Existing Match</h2>
      <p>Enter the match ID and your name:</p>
      <div class="input-group">
        <input id="joinMatchId" type="text" placeholder="Match ID" />
        <input id="joinPlayerName" type="text" placeholder="Your name" />
        <button id="confirmJoinBtn" class="action-btn">Join Match</button>
      </div>
      <button id="backToHomeBtn2" class="secondary-btn">‚Üê Back to Home</button>
    </div>
  </div>

  <!-- Screen 3: Ready Screen -->
  <div id="readyScreen" class="screen" style="display: none;">
    <div class="screen-content">
      <h2>Waiting Room</h2>
      <div class="match-info">
        <p><strong>Match ID:</strong> <span id="displayMatchId">-</span></p>
        <button id="copyMatchIdBtn" class="copy-btn">üìã Copy Match ID</button>
      </div>
      <div class="players-status">
        <div class="player-status">
          <span class="player-label">Player A:</span>
          <span id="playerAName">-</span>
          <span id="playerAReady" class="ready-status">(Not Ready)</span>
        </div>
        <div class="player-status">
          <span class="player-label">Player B:</span>
          <span id="playerBName">-</span>
          <span id="playerBReady" class="ready-status">(Not Ready)</span>
        </div>
      </div>
      <button id="readyBtn" class="ready-btn" style="display: none;">I'm Ready!</button>
      <div id="waitingMessage" class="waiting-message">Waiting for both players to be ready...</div>
    </div>
  </div>

  <!-- Screen 4: Game Screen -->
  <div id="gameScreen" class="screen" style="display: none;">
    <div class="game-container" id="gameContainer">
    <!-- Timer in top right -->
    <div class="timer-top-right">
      <div class="status">Timer: <span id="timer" class="timer-display">-</span></div>
        <button id="autoBtn" class="auto-turn-btn">Auto Turn</button>
    </div>
    
    <!-- Left Sidebar - Shared Counter -->
    <div class="game-sidebar">
      <div class="shared-counter">
        <h3>Shared Dot Counter</h3>
        <div class="dot-display">
          <div class="dot-value" id="dotCounter">0</div>
          <div class="dot-labels">
            <span class="player-label">B Wins (-5)</span>
            <span class="neutral-label">Neutral (0)</span>
            <span class="player-label">A Wins (+5)</span>
          </div>
        </div>
        <div id="winnerDisplay" class="winner-display" style="display: none;">
          <h2 id="winnerText">Game Over!</h2>
          <div style="margin-top: 15px;">
            <button id="rematchBtn" class="btn btn-primary" style="margin-right: 10px;">üîÑ Rematch</button>
            <button id="gameBackToHomeBtn" class="btn btn-secondary">üè† Back to Home</button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Game Header -->
    <div class="game-header">
      <div class="status">Active Player: <span id="active">-</span></div>
      <div class="status">Phase: <span id="phase">-</span></div>
    </div>
    
    <!-- Main Game Area -->
    <div class="game-main">
      <!-- Enemy Area (Top) -->
      <div class="player-section enemy-area" id="playerA">
        <div class="player-area-label opponent">Opponent Area</div>
        <h3 id="playerATitle">Player A</h3>
        <div class="status">Hand: <span id="handSizeA">-</span> cards</div>
        <div class="status">Tableau: <span id="tableauSizeA">-</span> cards</div>
        <h4>Hand:</h4>
        <div class="hand" id="handA"></div>
        <h4>Tableau:</h4>
        <div class="tableau" id="tableauA"></div>
      </div>

      <!-- Your Area (Bottom) -->
      <div class="player-section player-area" id="playerB">
        <div class="player-area-label">Your Area</div>
        <h3 id="playerBTitle">Player B</h3>
        <div class="status">Hand: <span id="handSizeB">-</span> cards</div>
        <div class="status">Tableau: <span id="tableauSizeB">-</span> cards</div>
        <h4>Hand:</h4>
        <div class="hand" id="handB"></div>
        <h4>Tableau:</h4>
        <div class="tableau" id="tableauB"></div>
        
        <!-- Play Cards Section -->
        <div class="play-cards-section">
          <div class="status" id="selectionStatus">Selected: Face Up=<span id="selUp">-</span>, Face Down=<span id="selDown">-</span></div>
          <button id="playBtn" class="play-selected-btn" style="display: none;">üéØ Play Selected Cards</button>
        </div>
      </div>
    </div>
    
    <!-- Game Footer -->
    <div class="game-footer">
        <h3>Game Log</h3>
        <div id="gameLog" class="log"></div>
      </div>
    </div>
  </div>

    <!-- Enhanced Card Choice Modal -->
    <div id="choiceModal" class="choice-modal" style="display: none;">
      <div class="choice-modal-content">
        <h2 id="choiceModalTitle">Choose Between These Cards</h2>
      <p style="text-align: center; color: #666; margin: 10px 0; font-size: 0.9em;">
        <span style="color: #3da7ff; font-weight: bold;">Blue</span> = Effect for you | 
        <span style="color: #ff9d46; font-weight: bold;">Orange</span> = Effect for opponent
      </p>
        <div class="choice-cards">
          <div class="choice-card">
            <h4>Face Up Card</h4>
            <div class="modal-card-display" id="faceUpCardDisplay">
              <div class="modal-card-title">-</div>
              <div class="modal-card-effects">-</div>
            </div>
            <button id="chooseFaceUpBtn" onclick="chooseFaceUp()" class="choice-btn">Choose This One</button>
          </div>
          <div class="choice-card">
            <h4>Face Down Card</h4>
            <div class="modal-card-display" id="faceDownCardDisplay">
              <div class="modal-card-title">???</div>
              <div class="modal-card-effects">???</div>
            </div>
            <button id="chooseFaceDownBtn" onclick="chooseFaceDown()" class="choice-btn">Choose This One</button>
          </div>
        </div>
      </div>
    </div>

  <script>
     // Auto-detect API URL based on environment
     const api = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' 
       ? '' // Local development - use same host
       : 'https://smarter-co00.onrender.com'; // Production - use remote API
     
     console.log('üåê Environment detected:', window.location.hostname);
     console.log('üîó Using API:', api || 'same host (' + window.location.origin + ')');
    let matchId = '';
    let playerSeat = null;
    let playerName = null;
    let gameState = null;
    let selUp = null, selDown = null;
    let turnTimer = null;
    let choiceTimer = null;
    let turnTimeLeft = 60; // Doubled from 30 to 60 seconds for card selection
    let choiceTimeLeft = 30; // Doubled from 15 to 30 seconds for choice selection

    // Screen management functions
    function showScreen(screenId) {
      const screens = ['homeScreen', 'createMatchScreen', 'joinMatchScreen', 'readyScreen', 'gameScreen'];
      screens.forEach(id => {
        document.getElementById(id).style.display = 'none';
      });
      document.getElementById(screenId).style.display = 'block';
      
      // Special handling for game screen
      if (screenId === 'gameScreen') {
        document.getElementById('gameContainer').style.display = 'grid';
      } else {
        document.getElementById('gameContainer').style.display = 'none';
      }
      console.log('Showing screen:', screenId);
    }

    // Game functions
    async function req(url, opts={}) {
      const r = await fetch(url, opts);
      if (!r.ok) throw new Error(await r.text());
      return r.json();
    }

    function log(msg){
      const el = document.getElementById('gameLog');
      if (el) {
        el.textContent += msg + "\n";
        el.scrollTop = el.scrollHeight;
      }
    }
    
    // Read matchId from URL and check for existing seat
    (function initMatchFromUrl(){
      const url = new URL(window.location.href);
      const pMatch = url.searchParams.get('match');
      if(pMatch){
        matchId = pMatch;
      } else {
        const parts = window.location.pathname.split('/');
        if(parts.length>=3 && parts[1]==='app' && parts[2].length>0){
          matchId = parts[2];
        }
      }
      
      // Check localStorage for existing seat
      const storedSeat = localStorage.getItem('match_' + matchId + '_seat');
      const storedName = localStorage.getItem('match_' + matchId + '_name');
      
      if(storedSeat !== null && storedName !== null){
        playerSeat = parseInt(storedSeat);
        playerName = storedName;
      }
      
      if(matchId){
        document.getElementById('displayMatchId').textContent = matchId;
        if(playerSeat !== null){
          startAutoRefresh();
          refresh();
        } else {
          showScreen('joinMatchScreen');
        }
      } else {
        showScreen('homeScreen');
      }
    })();

    // Event listeners
    document.getElementById('createMatchBtn').onclick = () => {
      showScreen('createMatchScreen');
    };

    document.getElementById('joinMatchBtn').onclick = () => {
      showScreen('joinMatchScreen');
    };

    document.getElementById('playBotBtn').onclick = () => {
      createMatchWithBot();
    };

    document.getElementById('confirmCreateBtn').onclick = createMatch;

    document.getElementById('confirmJoinBtn').onclick = joinMatch;

    async function createMatch() {
      const name = document.getElementById('createPlayerName').value.trim();
      if (!name) {
        alert('Please enter your name');
        return;
      }

      try {
        const data = await req(api + '/api/match', { method:'POST', headers:{'Content-Type':'application/json'}, body:'{}' });
        matchId = data.id;
        playerName = name;
        
        // Join the match we just created
        const response = await req(api + '/api/match/' + matchId + '/join', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: name })
        });

        playerSeat = response.seat;
        
        // Store in localStorage
        localStorage.setItem('match_' + matchId + '_seat', playerSeat);
        localStorage.setItem('match_' + matchId + '_name', playerName);
        localStorage.setItem('playerName', playerName);
        localStorage.setItem('wasVsBot', 'false'); // Player vs Player
        
        document.getElementById('displayMatchId').textContent = matchId;
        showScreen('readyScreen');
        startAutoRefresh();
        refresh();
        
        log('Created match and joined as Player ' + (playerSeat === 0 ? 'A' : 'B'));
      } catch (error) {
        alert('Failed to create match: ' + error.message);
      }
    }

    async function createMatchWithBot() {
      const name = prompt('Enter your name for the bot match:');
      if (!name) return;
      
      try {
        const data = await req(api + '/api/match/bot', { method:'POST', headers:{'Content-Type':'application/json'}, body:'{}' });
        matchId = data.id;
        
        // Join as Player B (human player)
        const response = await req(api + '/api/match/' + matchId + '/join', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: name })
        });

        playerSeat = response.seat;
        playerName = name;
        
        // Store in localStorage
        localStorage.setItem('match_' + matchId + '_seat', playerSeat);
        localStorage.setItem('match_' + matchId + '_name', playerName);
        localStorage.setItem('playerName', playerName);
        localStorage.setItem('wasVsBot', 'true');
        
        document.getElementById('displayMatchId').textContent = matchId;
        showScreen('readyScreen');
        startAutoRefresh();
        refresh();
        
        log('Created bot match and joined as Player ' + (playerSeat === 0 ? 'A' : 'B'));
      } catch (error) {
        alert('Failed to create bot match: ' + error.message);
      }
    }

    async function joinMatch(){
      const id = document.getElementById('joinMatchId').value.trim();
      const name = document.getElementById('joinPlayerName').value.trim();

      if(!id){ alert('Please enter a match id'); return; }
      if(!name){ alert('Please enter your name'); return; }

      matchId = id;
      await joinMatchDirect(id, name);
    }

    async function joinMatchDirect(id, name){
      try {
        const response = await req(api + '/api/match/' + id + '/join', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name })
        });

        playerSeat = response.seat;
        playerName = name;
        
        // Persist for reloads
        localStorage.setItem('match_' + id + '_seat', playerSeat);
        localStorage.setItem('match_' + id + '_name', playerName);
        localStorage.setItem('playerName', playerName);
        localStorage.setItem('wasVsBot', 'false'); // Player vs Player
        
        document.getElementById('displayMatchId').textContent = matchId;
        showScreen('readyScreen');
        startAutoRefresh();
        refresh();
        
        log('Joined match as Player ' + (playerSeat === 0 ? 'A' : 'B'));
      } catch (error) {
        alert('Failed to join match: ' + error.message);
      }
    }

    document.getElementById('backToHomeBtn').onclick = () => {
      showScreen('homeScreen');
    };

    document.getElementById('backToHomeBtn2').onclick = () => {
      showScreen('homeScreen');
    };

    // Enter key support
    document.getElementById('createPlayerName').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') document.getElementById('confirmCreateBtn').click();
    });

    document.getElementById('joinMatchId').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') document.getElementById('confirmJoinBtn').click();
    });

    document.getElementById('joinPlayerName').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') document.getElementById('confirmJoinBtn').click();
    });

    // Add all the game functions from the backup file
    // This includes refresh, render functions, game logic, etc.
    // For brevity, I'll add the essential functions

    async function refresh() {
      if (!matchId) return;
      
      const url = playerSeat !== null ? 
        api + '/api/match/' + matchId + '?seat=' + playerSeat :
        api + '/api/match/' + matchId;
      
      gameState = await req(url);
      
      // Handle lobby state
      if (!gameState.started) {
        showLobby();
        return;
      }
      
      // Game started - show game UI
      showGame();
      
      // Update player info
      document.getElementById('handSizeA').textContent = gameState.handSizeA;
      document.getElementById('handSizeB').textContent = gameState.handSizeB;
      document.getElementById('tableauSizeA').textContent = gameState.tableauSizeA;
      document.getElementById('tableauSizeB').textContent = gameState.tableauSizeB;
      document.getElementById('active').textContent = gameState.activePlayer === 0 ? 'A' : 'B';
      document.getElementById('phase').textContent = gameState.phase || 'PLAY_TWO_CARDS';
      
      // Update player names and area labels based on current player
      const playerAName = gameState.playerA || 'Player A';
      const playerBName = gameState.playerB || 'Player B';
      document.getElementById('playerATitle').textContent = playerAName;
      document.getElementById('playerBTitle').textContent = playerBName;
      
      // Update area labels based on current player perspective
      const playerALabel = document.querySelector('#playerA .player-area-label');
      const playerBLabel = document.querySelector('#playerB .player-area-label');
      
      if (playerSeat === 0) {
        // Current player is Player A
        playerALabel.textContent = 'Your Area';
        playerALabel.className = 'player-area-label';
        playerBLabel.textContent = 'Opponent Area';
        playerBLabel.className = 'player-area-label opponent';
      } else if (playerSeat === 1) {
        // Current player is Player B
        playerALabel.textContent = 'Opponent Area';
        playerALabel.className = 'player-area-label opponent';
        playerBLabel.textContent = 'Your Area';
        playerBLabel.className = 'player-area-label';
      }
      
      // Update dot counter with enhanced visual feedback
      const dotCounter = gameState.sharedDotCounter;
      const dotCounterElement = document.getElementById('dotCounter');
      dotCounterElement.textContent = dotCounter;
      
      // Update counter styling based on value
      dotCounterElement.className = 'dot-value';
      if (dotCounter >= 5) {
        dotCounterElement.style.color = '#4caf50'; // Green for Player A winning
        dotCounterElement.style.textShadow = '0 0 10px rgba(76, 175, 80, 0.5)';
      } else if (dotCounter <= -5) {
        dotCounterElement.style.color = '#f44336'; // Red for Player B winning
        dotCounterElement.style.textShadow = '0 0 10px rgba(244, 67, 54, 0.5)';
      } else {
        dotCounterElement.style.color = '#fff'; // White for neutral
        dotCounterElement.style.textShadow = '2px 2px 4px rgba(0,0,0,0.3)';
      }
      
      // Check win conditions
      checkWinConditions();
      
      // Update active player highlighting with enhanced visual feedback
      const playerAElement = document.getElementById('playerA');
      const playerBElement = document.getElementById('playerB');
      
      playerAElement.classList.toggle('active', gameState.activePlayer === 0);
      playerBElement.classList.toggle('active', gameState.activePlayer === 1);
      
      // Add active turn indicator to player titles
      const playerATitle = document.getElementById('playerATitle');
      const playerBTitle = document.getElementById('playerBTitle');
      
      if (gameState.activePlayer === 0) {
        playerATitle.innerHTML = (gameState.playerA || 'Player A') + ' <span style="color: #4caf50; font-size: 0.8em;">üü¢ Your Turn</span>';
        playerBTitle.textContent = gameState.playerB || 'Player B';
      } else {
        playerATitle.textContent = gameState.playerA || 'Player A';
        playerBTitle.innerHTML = (gameState.playerB || 'Player B') + ' <span style="color: #4caf50; font-size: 0.8em;">üü¢ Your Turn</span>';
      }
      
      // Update UI based on phase
      updateUIForPhase();
      
      // Render hands and tableaus
      renderHands();
      renderTableaus();
      
      // Ensure interaction is properly toggled
      const isMyTurn = playerSeat !== null && playerSeat === gameState.activePlayer;
      toggleInteraction(isMyTurn);
      
      // Auto-play bot turns
      if (gameState.started) {
        const isPlayerABot = gameState.playerAIsBot;
        const isPlayerBBot = gameState.playerBIsBot;
        const activePlayer = gameState.activePlayer;
        const phase = gameState.phase;
        const inactivePlayer = 1 - activePlayer;
        
        console.log('Bot check: started=' + gameState.started + ', isPlayerABot=' + isPlayerABot + ', isPlayerBBot=' + isPlayerBBot + ', activePlayer=' + activePlayer + ', phase=' + phase);
        
        let shouldAct = false;
        let delay = 1000;
        let action = 'playing';
        
        if (phase === 'PLAY_TWO_CARDS') {
          // Submit phase: only active player bot acts
          if ((activePlayer === 0 && isPlayerABot) || (activePlayer === 1 && isPlayerBBot)) {
            shouldAct = true;
            delay = 1000; // 1 second to select cards
            action = 'selecting cards';
          }
        } else if (phase === 'OPPONENT_PICK') {
          // Choice phase: only inactive player bot acts
          if ((inactivePlayer === 0 && isPlayerABot) || (inactivePlayer === 1 && isPlayerBBot)) {
            shouldAct = true;
            delay = 3000; // 3 seconds to choose between cards
            action = 'choosing between cards';
          }
        }
        
        if (shouldAct) {
          console.log('Bot will ' + action + ' in ' + delay + 'ms');
          setTimeout(async () => {
            try {
              await req(api + '/api/match/' + matchId + '/bot-turn?seat=' + playerSeat, { method: 'POST' });
              log('Bot ' + action + ' automatically');
            } catch (error) {
              console.log('Bot auto-play failed:', error);
            }
          }, delay);
        }
      }
    }

    function showLobby() {
      showScreen('readyScreen');
      
      // Update lobby info
      document.getElementById('playerAName').textContent = gameState.playerA || '-';
      document.getElementById('playerBName').textContent = gameState.playerB || '-';
      
      const playerAReady = document.getElementById('playerAReady');
      const playerBReady = document.getElementById('playerBReady');
      
      playerAReady.textContent = gameState.readyA ? '(Ready)' : '(Not Ready)';
      playerBReady.textContent = gameState.readyB ? '(Ready)' : '(Not Ready)';
      playerAReady.className = gameState.readyA ? 'ready-status ready' : 'ready-status not-ready';
      playerBReady.className = gameState.readyB ? 'ready-status ready' : 'ready-status not-ready';
      
      // Show ready button if this player isn't ready yet
      const readyBtn = document.getElementById('readyBtn');
      const waitingMsg = document.getElementById('waitingMessage');
      
      if (playerSeat === 0 && !gameState.readyA) {
        readyBtn.style.display = 'block';
        waitingMsg.textContent = 'Click "I\'m Ready!" when you\'re ready to start';
      } else if (playerSeat === 1 && !gameState.readyB) {
        readyBtn.style.display = 'block';
        waitingMsg.textContent = 'Click "I\'m Ready!" when you\'re ready to start';
      } else if (!gameState.readyA || !gameState.readyB) {
        readyBtn.style.display = 'none';
        waitingMsg.textContent = 'Waiting for the other player to be ready...';
        } else {
        readyBtn.style.display = 'none';
        waitingMsg.textContent = 'Both players ready! Starting game...';
      }
    }

    function showGame() {
      showScreen('gameScreen');
    }

    // Add all other necessary game functions here...
    // (This is a simplified version - the full version would include all the render functions, game logic, etc.)

    // Auto-refresh every 2 seconds when there's an active match
    let refreshInterval;
    function startAutoRefresh() {
      if (refreshInterval) clearInterval(refreshInterval);
      refreshInterval = setInterval(async () => {
        if (matchId) {
          try {
            await refresh();
          } catch (e) {
            console.log('Auto-refresh failed:', e);
          }
        }
      }, 2000);
    }

    function stopAutoRefresh() {
      if (refreshInterval) {
        clearInterval(refreshInterval);
        refreshInterval = null;
      }
    }

    // Add event listeners for game controls
    document.getElementById('readyBtn').onclick = setReady;
    document.getElementById('copyMatchIdBtn').onclick = copyMatchId;
    document.getElementById('autoBtn').onclick = autoTurn;

    async function setReady() {
      try {
        await req(api + '/api/match/' + matchId + '/ready?seat=' + playerSeat, {
          method: 'POST'
        });
        log('Ready status sent');
        refresh();
      } catch (error) {
        alert('Failed to set ready status: ' + error.message);
      }
    }

    async function copyMatchId() {
      if (!matchId) return;
      
      try {
        // Copy just the match ID to clipboard
        await navigator.clipboard.writeText(matchId);
        
        // Show temporary feedback
        const btn = document.getElementById('copyMatchIdBtn');
        const originalText = btn.textContent;
        btn.textContent = '‚úÖ Copied!';
        btn.style.backgroundColor = '#28a745';
        
        setTimeout(() => {
          btn.textContent = originalText;
          btn.style.backgroundColor = '';
        }, 1500);
        
        log('Match ID copied to clipboard: ' + matchId);
      } catch (error) {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = matchId;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        
        log('Match ID copied to clipboard (fallback)');
      }
    }

    async function autoTurn() {
      if (!matchId) return;
      const url = playerSeat !== null ? 
        api + '/api/match/' + matchId + '/auto?seat=' + playerSeat :
        api + '/api/match/' + matchId + '/auto';
      await req(url, { method:'POST' });
      log('Auto turn submitted');
      await refresh();
    }

    // Complete game functions implementation
    function renderCard(cardId, cardDef, isSelectable = false, realCardId = null) {
      const div = document.createElement('div');
      div.className = 'card-tooltip';
      
      const realId = realCardId || cardId;
      const displayId = cardId;
      
        const btn = document.createElement('button');
      btn.className = 'card' + (isSelectable && (selUp === displayId || selDown === displayId) ? ' selected' : '');
      btn.setAttribute('data-real-id', realId);
      
      if(cardDef){
          const title = document.createElement('div');
          title.className = 'card-title';
          title.textContent = cardDef.name;
          btn.appendChild(title);
          const ul = document.createElement('ul');
          ul.className = 'card-effects';
          cardDef.tiers.forEach((tier, idx)=>{
             const li=document.createElement('li');
             li.textContent = (idx+1)+'. '+ (tier.actions[0]?.description || '');
             ul.appendChild(li);
          });
          btn.appendChild(ul);
      } else {
          btn.textContent = displayId;
      }
      
      const canSelect = isSelectable && (!gameState || !gameState.waitingForOpponentChoice);
      
      if (canSelect) {
        btn.onclick = () => {
          if (!selUp) selUp = realId;
          else if (!selDown && realId !== selUp) selDown = realId; 
          else { selUp = realId; selDown = null; }
          document.getElementById('selUp').textContent = selUp || '-';
          document.getElementById('selDown').textContent = selDown || '-';
          updateCardSelection();
        };
      }
      
      if (cardDef) {
        const tooltip = document.createElement('div');
        tooltip.className = 'tooltip-content';
        tooltip.innerHTML = generateCardTooltip(cardDef);
        div.appendChild(tooltip);
      }
      
      div.appendChild(btn);
      return div;
    }

    function generateCardTooltip(cardDef) {
      let html = `<strong>${cardDef.name}</strong><br>`;
      html += `Tags: ${cardDef.tags.join(', ')}<br><br>`;
      
      cardDef.tiers.forEach((tier, index) => {
        html += `<strong>Tier ${index + 1}:</strong><br>`;
        tier.actions.forEach(action => {
          html += `‚Ä¢ ${action.description}<br>`;
        });
        html += '<br>';
      });
      
      return html;
    }

    function getNextEffectLevel(cardId, playerTableau) {
      if (!cardId || !playerTableau) return 0;
      const count = playerTableau.filter(id => id === cardId).length;
      console.log(`Effect level calculation: cardId=${cardId}, tableau=[${playerTableau.join(', ')}], count=${count}, nextLevel=${Math.min(count, 2)}`);
      return Math.min(count, 2); // 0, 1, or 2 (tiers are 0-indexed)
    }

    function generateEffectsHTMLWithHighlighting(cardDef, myTableau, oppTableau) {
      if (!cardDef) return 'Unknown card';
      
      // The card being evaluated (from choice panel) needs to be matched against tableau IDs
      // We need to find what ID this card would have in the tableau
      const cardId = findCardIdInTableau(cardDef, myTableau, oppTableau);
      
      let html = '<ul class="card-effects">';
      cardDef.tiers.forEach((tier, index) => {
        tier.actions.forEach(action => {
          const myNextLevel = getNextEffectLevel(cardId, myTableau);
          const oppNextLevel = getNextEffectLevel(cardId, oppTableau);
          
          let className = '';
          if (index === myNextLevel) {
            className = 'effect-mine';
          } else if (index === oppNextLevel) {
            className = 'effect-opponent';
          }
          
          html += `<li class="${className}"><strong>Tier ${index + 1}:</strong> ${action.description}</li>`;
        });
      });
      html += '</ul>';
      return html;
    }
    
    function findCardIdInTableau(cardDef, myTableau, oppTableau) {
      // Find the tableau ID that corresponds to this card
      const allTableauIds = [...myTableau, ...oppTableau];
      
      // Look for a tableau ID whose definition matches this card's name
      for (const tableauId of allTableauIds) {
        const tableauCardDef = gameState.cardDefinitions[tableauId];
        if (tableauCardDef && tableauCardDef.name === cardDef.name) {
          console.log(`‚úÖ Found match: ${cardDef.name} ‚Üí ${tableauId}`);
          return tableauId;
        }
      }
      
      console.log(`‚ùå No match found for ${cardDef.name} in tableaus:`, {
        cardName: cardDef.name,
        myTableau: myTableau,
        oppTableau: oppTableau,
        cardDefinitions: Object.keys(gameState.cardDefinitions).map(id => ({
          id: id,
          name: gameState.cardDefinitions[id]?.name
        }))
      });
      
      // Fallback to card definition ID or name
      return cardDef.id || cardDef.name;
    }

    function generateEffectsHTML(cardDef) {
      if (!cardDef) return 'Unknown card';
      
      let html = '<ul class="card-effects">';
      cardDef.tiers.forEach((tier, index) => {
        tier.actions.forEach(action => {
          html += `<li><strong>Tier ${index + 1}:</strong> ${action.description}</li>`;
        });
      });
      html += '</ul>';
      return html;
    }

    function updateCardSelection() {
      const handCards = document.querySelectorAll('.hand .card');
      handCards.forEach(card => {
        const realId = card.getAttribute('data-real-id');
        if (realId === selUp || realId === selDown) {
          card.classList.add('selected');
        } else {
          card.classList.remove('selected');
        }
      });
    }

    function renderHands() {
      if (!gameState || playerSeat === null) return;
      
      // Determine which hand divs belong to me vs opponent
      const myHandDiv = playerSeat === 0 ? document.getElementById('handA') : document.getElementById('handB');
      const oppHandDiv = playerSeat === 0 ? document.getElementById('handB') : document.getElementById('handA');
      
      // Clear both hands
      myHandDiv.innerHTML = '';
      oppHandDiv.innerHTML = '';
      
      // Render my hand with real cards
      if (gameState.activeHandCardIds && gameState.activeHandCardIds.length > 0) {
        const cardCounts = {};
        gameState.activeHandCardIds.forEach(id => {
          cardCounts[id] = (cardCounts[id] || 0) + 1;
        });
        
        Object.keys(cardCounts).forEach(id => {
          const count = cardCounts[id];
          const cardDef = gameState.cardDefinitions[id];
          for (let i = 0; i < count; i++) {
            const uniqueId = count > 1 ? `${id}_${i}` : id;
            myHandDiv.appendChild(renderCard(uniqueId, cardDef, true, id));
          }
        });
      }
      
      // Render opponent hand with card backs
      const oppHandSize = playerSeat === 0 ? gameState.handSizeB : gameState.handSizeA;
      for (let i = 0; i < oppHandSize; i++) {
        const cardBack = document.createElement('div');
        cardBack.className = 'card-tooltip';
        cardBack.style.width = '140px';
        cardBack.style.height = '200px';
        cardBack.style.border = '2px solid #666';
        cardBack.style.borderRadius = '8px';
        cardBack.style.backgroundColor = '#333';
        cardBack.style.display = 'flex';
        cardBack.style.alignItems = 'center';
        cardBack.style.justifyContent = 'center';
        cardBack.style.fontSize = '24px';
        cardBack.style.color = '#fff';
        cardBack.textContent = '?';
        oppHandDiv.appendChild(cardBack);
      }
    }
    function renderTableaus() {
      if (!gameState) return;
      
      // Render Player A tableau
      const tableauA = document.getElementById('tableauA');
      tableauA.innerHTML = '';
      const cardCountsA = {};
      gameState.tableauCardIdsA.forEach(id => {
        cardCountsA[id] = (cardCountsA[id] || 0) + 1;
      });
      
      Object.keys(cardCountsA).forEach(id => {
        const count = cardCountsA[id];
        const cardDef = gameState.cardDefinitions[id];
        const stackedCard = renderStackedCard(id, cardDef, count);
        tableauA.appendChild(stackedCard);
      });
      
      // Render Player B tableau
      const tableauB = document.getElementById('tableauB');
      tableauB.innerHTML = '';
      const cardCountsB = {};
      gameState.tableauCardIdsB.forEach(id => {
        cardCountsB[id] = (cardCountsB[id] || 0) + 1;
      });
      
      Object.keys(cardCountsB).forEach(id => {
        const count = cardCountsB[id];
        const cardDef = gameState.cardDefinitions[id];
        const stackedCard = renderStackedCard(id, cardDef, count);
        tableauB.appendChild(stackedCard);
      });
    }

    function renderStackedCard(cardId, cardDef, count) {
      const div = document.createElement('div');
      div.className = 'card-tooltip stacked-card';
      
      const btn = document.createElement('button');
      btn.className = 'tableau-card';
      btn.style.width = '140px';
      btn.style.minHeight = '200px';
      btn.style.position='relative';
      
      if(cardDef){
          const title=document.createElement('div');
          title.className='card-title';
          title.textContent=cardDef.name;
          btn.appendChild(title);
          const ul=document.createElement('ul');
          ul.className='card-effects';
          cardDef.tiers.forEach((tier,idx)=>{
              const li=document.createElement('li');
              li.textContent=(idx+1)+'. '+(tier.actions[0]?.description||'');
              if(idx===Math.min(count-1,2)) li.classList.add('active');
              ul.appendChild(li);
          });
          btn.appendChild(ul);
      } else {
          btn.textContent=cardId;
      }
      
      // Add count badge if more than 1
      if (count > 1) {
        const badge = document.createElement('span');
        badge.className = 'card-count-badge';
        badge.textContent = count;
        btn.appendChild(badge);
      }
      
      if (cardDef) {
        const tooltip = document.createElement('div');
        tooltip.className = 'tooltip-content';
        tooltip.innerHTML = generateCardTooltip(cardDef);
        div.appendChild(tooltip);
      }
      
      div.appendChild(btn);
      return div;
    }
    function startTurnTimer() {
      clearTimers();
      turnTimeLeft = 60; // Doubled from 30 to 60 seconds
      updateTimerDisplay();
      
      turnTimer = setInterval(() => {
        turnTimeLeft--;
        updateTimerDisplay();
        
        if (turnTimeLeft <= 0) {
          clearTimers();
          log('Turn timer expired! Auto-selecting random cards...');
          autoSelectRandomCards();
        }
      }, 1000);
    }

    function startChoiceTimer() {
      clearTimers();
      choiceTimeLeft = 30; // Doubled from 15 to 30 seconds
      updateTimerDisplay();
      
      choiceTimer = setInterval(() => {
        choiceTimeLeft--;
        updateTimerDisplay();
        
        if (choiceTimeLeft <= 0) {
          clearTimers();
          log('Choice timer expired! Auto-selecting random choice...');
          autoSelectRandomChoice();
        }
      }, 1000);
    }
    
    function updateTimerDisplay() {
      const timerElement = document.getElementById('timer');
      if (!timerElement) return;
      
      const currentTime = turnTimer ? turnTimeLeft : choiceTimeLeft;
      timerElement.textContent = currentTime + 's';
      
      // Update timer styling based on time remaining (proportional to timer type)
      timerElement.className = 'timer-display';
      const isChoicePhase = choiceTimer !== null;
      
      if (isChoicePhase) {
        // Choice phase: 30 seconds total
        if (currentTime <= 5) {
          timerElement.classList.add('danger');
        } else if (currentTime <= 10) {
          timerElement.classList.add('warning');
        }
      } else {
        // Turn phase: 60 seconds total  
        if (currentTime <= 10) {
          timerElement.classList.add('danger');
        } else if (currentTime <= 20) {
          timerElement.classList.add('warning');
        }
      }
    }

    function clearTimers() {
      if (turnTimer) {
        clearInterval(turnTimer);
        turnTimer = null;
      }
      if (choiceTimer) {
        clearInterval(choiceTimer);
        choiceTimer = null;
      }
    }

    async function autoSelectRandomCards() {
      if (!matchId || !gameState || gameState.waitingForOpponentChoice) return;
      
      const handIds = gameState.activeHandCardIds;
      if (handIds.length < 2) return;
      
      // Select two random cards
      const random1 = handIds[Math.floor(Math.random() * handIds.length)];
      let random2 = handIds[Math.floor(Math.random() * handIds.length)];
      while (random2 === random1 && handIds.length > 1) {
        random2 = handIds[Math.floor(Math.random() * handIds.length)];
      }
      
      selUp = random1;
      selDown = random2;
      document.getElementById('selUp').textContent = selUp;
      document.getElementById('selDown').textContent = selDown;
      
      // Make the API call
      clearTimers();
      const body = JSON.stringify({ faceUpId: selUp, faceDownId: selDown });
      const url = playerSeat !== null ? 
        api + '/api/match/' + matchId + '/play?seat=' + playerSeat :
        api + '/api/match/' + matchId + '/play';
      gameState = await req(url, { method:'POST', headers:{'Content-Type':'application/json'}, body });
      log('Auto-played: up=' + selUp + ', down=' + selDown);
      
      // Reset selection after playing
      resetSelection();
      
      await refresh();
    }

    async function autoSelectRandomChoice() {
      if (!matchId || !gameState || !gameState.waitingForOpponentChoice) return;
      
      const chooseFaceUpOption = Math.random() < 0.5;
      if (chooseFaceUpOption) {
        await chooseFaceUp();
        } else {
        await chooseFaceDown();
      }
    }

    function resetSelection() {
      selUp = null;
      selDown = null;
      document.getElementById('selUp').textContent = '-';
      document.getElementById('selDown').textContent = '-';
      updateCardSelection();
    }

    function updateUIForPhase() {
      const isWaitingForChoice = gameState.waitingForOpponentChoice;
      const phase = gameState.phase || 'PLAY_TWO_CARDS';
      const isMyTurn = playerSeat !== null && playerSeat === gameState.activePlayer;
      
      // Show/hide selection status
      const selectionStatus = document.getElementById('selectionStatus');
      if (selectionStatus) {
        selectionStatus.style.display = isWaitingForChoice ? 'none' : 'block';
      }
      
      // Show/hide buttons
      const playBtn = document.getElementById('playBtn');
      if (playBtn) {
        playBtn.style.display = !isWaitingForChoice ? 'block' : 'none';
      }
      
      // Start appropriate timer only if not already running
      if (isWaitingForChoice && !choiceTimer) {
        startChoiceTimer();
      } else if (!isWaitingForChoice && !turnTimer) {
        startTurnTimer();
      }
      
      // Toggle interaction based on turn
      toggleInteraction(isMyTurn);
      
      if (isWaitingForChoice) {
        // Show the cards that need to be chosen between
        const faceUpDef = gameState.cardDefinitions[gameState.faceUpCardId];
        const faceDownDef = gameState.cardDefinitions[gameState.faceDownCardId];
        
        // Only show choice buttons to the opponent (not the player who submitted the cards)
        const isOpponentTurn = playerSeat !== null && playerSeat !== gameState.activePlayer;
        const isCardSubmitter = playerSeat !== null && playerSeat === gameState.activePlayer;
        
        // Get current player's tableaus for effect highlighting
        const myTableau = playerSeat === 0 ? gameState.tableauCardIdsA : gameState.tableauCardIdsB;
        const oppTableau = playerSeat === 0 ? gameState.tableauCardIdsB : gameState.tableauCardIdsA;
        
        // Debug: Log current state
        console.log('Choice Panel Debug:');
        console.log('  My tableau:', myTableau.map(id => `${id} = ${gameState.cardDefinitions[id]?.name || 'Unknown'}`));
        console.log('  Opp tableau:', oppTableau.map(id => `${id} = ${gameState.cardDefinitions[id]?.name || 'Unknown'}`));
        console.log('  Face up card ID:', gameState.faceUpCardId);
        console.log('  Face down card ID:', gameState.faceDownCardId);
        console.log('  Face up def:', faceUpDef);
        console.log('  Face down def:', faceDownDef);
        
        // Update Face Up Card display
        const faceUpTitle = document.querySelector('#faceUpCardDisplay .modal-card-title');
        const faceUpEffects = document.querySelector('#faceUpCardDisplay .modal-card-effects');
        
        if (faceUpDef && faceUpTitle && faceUpEffects) {
          faceUpTitle.textContent = faceUpDef.name;
          faceUpEffects.innerHTML = generateEffectsHTMLWithHighlighting(faceUpDef, myTableau, oppTableau);
        } else if (faceUpTitle && faceUpEffects) {
          // Fallback if card definition is missing
          faceUpTitle.textContent = gameState.faceUpCardId || 'Face Up Card';
          faceUpEffects.innerHTML = '<p>Card details loading...</p>';
        }
        
        // Update Face Down Card display
        const faceDownTitle = document.querySelector('#faceDownCardDisplay .modal-card-title');
        const faceDownEffects = document.querySelector('#faceDownCardDisplay .modal-card-effects');
        if (faceDownTitle && faceDownEffects) {
          // If backend sends "???" but we are the card submitter, use our stored card
          let actualFaceDownDef = faceDownDef;
          if (isCardSubmitter && !faceDownDef && myLastFaceDownCard) {
            actualFaceDownDef = gameState.cardDefinitions[myLastFaceDownCard];
            console.log('üé≠ Using stored face-down card:', myLastFaceDownCard, '‚Üí', actualFaceDownDef?.name);
          }
          
          console.log('Face Down Card logic:', {
            isCardSubmitter: isCardSubmitter,
            backendFaceDownId: gameState.faceDownCardId,
            myStoredCard: myLastFaceDownCard,
            faceDownDef: faceDownDef,
            actualFaceDownDef: actualFaceDownDef,
            playerSeat: playerSeat,
            activePlayer: gameState.activePlayer
          });
          
          if (isCardSubmitter && actualFaceDownDef) {
            // Show complete details to the player who submitted the cards (they know what it is)
            faceDownTitle.textContent = actualFaceDownDef.name + ' (You selected this)';
            faceDownTitle.className = 'modal-card-title';
            faceDownTitle.style.fontStyle = 'italic';
            faceDownTitle.style.color = '#666';
            faceDownEffects.innerHTML = generateEffectsHTMLWithHighlighting(actualFaceDownDef, myTableau, oppTableau);
        } else {
            // Opponent cannot see the face down card details
          faceDownTitle.textContent = '???';
          faceDownTitle.className = 'modal-card-title';
            faceDownTitle.style.fontStyle = 'normal';
            faceDownTitle.style.color = 'inherit';
            faceDownEffects.innerHTML = '<p>Hidden card</p>';
          }
        }
        
        // Show the choice modal
        const choiceModal = document.getElementById('choiceModal');
        if (choiceModal) {
          choiceModal.style.display = 'flex';
          choiceModal.classList.add('show');
        
        if (isOpponentTurn) {
          document.getElementById('choiceModalTitle').textContent = 'Choose Between These Cards';
          document.querySelectorAll('#choiceModal .choice-btn').forEach(btn => btn.style.display = 'block');
        } else {
          document.getElementById('choiceModalTitle').textContent = 'Waiting for opponent to choose...';
          document.querySelectorAll('#choiceModal .choice-btn').forEach(btn => btn.style.display = 'none');
        }
        }
      } else {
        // Hide modal when not waiting for choice
        const choiceModal = document.getElementById('choiceModal');
        if (choiceModal) {
          choiceModal.classList.remove('show');
        setTimeout(() => {
            choiceModal.style.display = 'none';
          }, 300);
        }
      }
    }
    function toggleInteraction(isMyTurn) {
      const phase = gameState.phase || 'PLAY_TWO_CARDS';
      const canInteract = isMyTurn && phase === 'PLAY_TWO_CARDS';
      
      // Enable/disable hand cards
      const handCards = document.querySelectorAll('.hand .card');
      handCards.forEach(card => {
        if (canInteract) {
          card.style.pointerEvents = 'auto';
          card.style.opacity = '1';
        } else {
          card.style.pointerEvents = 'none';
          card.style.opacity = '0.5';
        }
      });
      
      // Show/hide play button and selection status
      const playBtn = document.getElementById('playBtn');
      const selectionStatus = document.getElementById('selectionStatus');
      
      if (canInteract && playBtn && selectionStatus) {
        playBtn.style.display = 'block';
        selectionStatus.style.display = 'block';
      } else {
        if (playBtn) playBtn.style.display = 'none';
        if (selectionStatus) selectionStatus.style.display = 'none';
      }
    }

    function checkWinConditions() {
      const dots = gameState.sharedDotCounter;
      const winnerDisplay = document.getElementById('winnerDisplay');
      const winnerText = document.getElementById('winnerText');
      
      if (winnerDisplay && winnerText) {
      if (dots >= 5) {
        // Player A wins
        winnerDisplay.style.display = 'block';
        winnerText.textContent = 'üéâ Player A Wins! (+5 dots)';
        winnerText.style.color = '#4CAF50';
        log('üéâ Player A wins with ' + dots + ' dots!');
        disableGameControls();
      } else if (dots <= -5) {
        // Player B wins
        winnerDisplay.style.display = 'block';
        winnerText.textContent = 'üéâ Player B Wins! (-5 dots)';
        winnerText.style.color = '#4CAF50';
        log('üéâ Player B wins with ' + dots + ' dots!');
        disableGameControls();
      } else {
        // No winner yet
        winnerDisplay.style.display = 'none';
        }
      }
    }

    function disableGameControls() {
      // Disable all game controls when someone wins
      const controls = ['playBtn', 'autoBtn', 'chooseFaceUpBtn', 'chooseFaceDownBtn'];
      controls.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
          element.disabled = true;
          element.style.opacity = '0.5';
        }
      });
      
      // Clear timers
      clearTimers();
      
      // Disable card selection
      const handCards = document.querySelectorAll('.hand .card');
      handCards.forEach(card => {
        card.style.pointerEvents = 'none';
        card.style.opacity = '0.5';
      });

      // Show rematch and back to home buttons
      const rematchBtn = document.getElementById('rematchBtn');
      const gameBackToHomeBtn = document.getElementById('gameBackToHomeBtn');
      if (rematchBtn) {
        rematchBtn.disabled = false;
        rematchBtn.style.opacity = '1';
        rematchBtn.style.display = 'inline-block';
      }
      if (gameBackToHomeBtn) {
        gameBackToHomeBtn.disabled = false;
        gameBackToHomeBtn.style.opacity = '1';
        gameBackToHomeBtn.style.display = 'inline-block';
      }
    }

    async function chooseFaceUp() {
      if (!matchId) return;
      clearTimers();
      // Hide modal immediately
      const choiceModal = document.getElementById('choiceModal');
      if (choiceModal) {
        choiceModal.classList.remove('show');
        setTimeout(() => {
          choiceModal.style.display = 'none';
        }, 300);
      }
      const body = JSON.stringify({ chooseFaceUp: true });
      const url = playerSeat !== null ? 
        api + '/api/match/' + matchId + '/choose?seat=' + playerSeat :
        api + '/api/match/' + matchId + '/choose';
      gameState = await req(url, { method:'POST', headers:{'Content-Type':'application/json'}, body });
      log('Opponent chose Face Up card');
      await refresh();
    }

    async function chooseFaceDown() {
      if (!matchId) return;
      clearTimers();
      // Hide modal immediately
      const choiceModal = document.getElementById('choiceModal');
      if (choiceModal) {
        choiceModal.classList.remove('show');
        setTimeout(() => {
          choiceModal.style.display = 'none';
        }, 300);
      }
      const body = JSON.stringify({ chooseFaceUp: false });
      const url = playerSeat !== null ? 
        api + '/api/match/' + matchId + '/choose?seat=' + playerSeat :
        api + '/api/match/' + matchId + '/choose';
      gameState = await req(url, { method:'POST', headers:{'Content-Type':'application/json'}, body });
      log('Opponent chose Face Down card');
      await refresh();
    }

    // Store the last face-down card we submitted (so we can show it to ourselves later)
    let myLastFaceDownCard = null;

    // Missing function for play selected cards
    async function playSelected() {
      if (!matchId || !selUp || !selDown) { 
        log('Pick two cards'); 
        return; 
      }
      clearTimers();
      
      // Store our face-down card selection locally
      myLastFaceDownCard = selDown;
      console.log('üé≠ Storing my face-down card:', selDown);
      
      const body = JSON.stringify({ faceUpId: selUp, faceDownId: selDown });
      const url = playerSeat !== null ? 
        api + '/api/match/' + matchId + '/play?seat=' + playerSeat :
        api + '/api/match/' + matchId + '/play';
      gameState = await req(url, { method:'POST', headers:{'Content-Type':'application/json'}, body });
      log('Played: up=' + selUp + ', down=' + selDown);
      
      // Reset selection after playing
      resetSelection();
      
      await refresh();
    }

    // Add event listener for play button
    const playBtn = document.getElementById('playBtn');
    if (playBtn) {
      playBtn.onclick = playSelected;
    }

    // Add event listeners for rematch and back to home buttons
    const rematchBtn = document.getElementById('rematchBtn');
    if (rematchBtn) {
      rematchBtn.onclick = startRematch;
    }

    const gameBackToHomeBtn = document.getElementById('gameBackToHomeBtn');
    if (gameBackToHomeBtn) {
      gameBackToHomeBtn.onclick = () => {
        // Clear game state and return to home
        clearGameState();
        showScreen('homeScreen');
      };
    }

    async function startRematch() {
      try {
        log('üîÑ Starting rematch with same players...');
        
        // Hide winner display immediately
        const winnerDisplay = document.getElementById('winnerDisplay');
        if (winnerDisplay) {
          winnerDisplay.style.display = 'none';
        }
        
        // Show loading message
        log('Resetting game state...');
        
        // Reset all game visuals but keep matchId and playerSeat
        resetGameVisuals();
        
        // Try to call backend rematch endpoint
        try {
          await req(api + '/api/match/' + matchId + '/rematch', { method: 'POST' });
          log('‚úÖ Backend rematch successful');
        } catch (backendError) {
          // If backend endpoint doesn't exist, that's OK - we'll handle it manually
          if (backendError.message.includes('404') || backendError.message.includes('Not Found')) {
            log('‚ö†Ô∏è Backend rematch endpoint not available, using manual reset');
          } else {
            throw backendError; // Re-throw non-404 errors
          }
        }
        
        // Show ready screen for both players to confirm they want to play again
        if (matchId) {
          document.getElementById('displayMatchId').textContent = matchId;
          showScreen('readyScreen');
          
          log('üéÆ Ready screen shown. Both players need to set ready again.');
          
          // Start refreshing to get latest state
          await refresh();
          startAutoRefresh();
        } else {
          throw new Error('Match ID is missing');
        }
        
      } catch (error) {
        log('‚ùå Error starting rematch: ' + error.message);
        alert('Failed to start rematch. Returning to home screen.');
        
        // If any error, go back to home screen
        clearGameState();
        showScreen('homeScreen');
      }
    }
    
    function resetGameVisuals() {
      console.log('üéÆ Resetting game visuals for rematch...');
      
      // Reset only visual elements, keep matchId and playerSeat
      gameState = null;
      selUp = null;
      selDown = null;
      myLastFaceDownCard = null; // Clear stored face-down card for new game
      
      // Clear timers
      clearTimers();
      
      // Reset UI elements
      document.getElementById('selUp').textContent = '-';
      document.getElementById('selDown').textContent = '-';
      
      // Clear tableaus and hands
      const tableauA = document.getElementById('tableauA');
      const tableauB = document.getElementById('tableauB');
      const handA = document.getElementById('handA');
      const handB = document.getElementById('handB');
      
      if (tableauA) tableauA.innerHTML = '';
      if (tableauB) tableauB.innerHTML = '';
      if (handA) handA.innerHTML = '';
      if (handB) handB.innerHTML = '';
      
      // Reset dot counter display
      const sharedDotCounter = document.getElementById('sharedDotCounter');
      if (sharedDotCounter) {
        sharedDotCounter.textContent = '0';
      }
      
      // Reset timer display
      const timer = document.getElementById('timer');
      if (timer) {
        timer.textContent = '';
        timer.className = 'timer-display';
      }
      
      // Hide choice modal
      const choiceModal = document.getElementById('choiceModal');
      if (choiceModal) {
        choiceModal.classList.remove('show');
        choiceModal.style.display = 'none';
      }
      
      // Hide winner display
      const winnerDisplay = document.getElementById('winnerDisplay');
      if (winnerDisplay) {
        winnerDisplay.style.display = 'none';
      }
      
      // Re-enable game controls
      const controls = ['playBtn', 'autoBtn', 'chooseFaceUpBtn', 'chooseFaceDownBtn'];
      controls.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
          element.disabled = false;
          element.style.opacity = '1';
        }
      });
      
      log('Game visuals reset for rematch');
    }

    function clearGameState() {
      // Clear all game-related variables
      gameState = null;
      matchId = null;
      playerSeat = null;
      selUp = null;
      selDown = null;
      myLastFaceDownCard = null; // Clear stored face-down card
      
      // Clear timers
      clearTimers();
      
      // Stop auto refresh
      if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
        autoRefreshInterval = null;
      }
      
      // Reset UI elements
      document.getElementById('selUp').textContent = '-';
      document.getElementById('selDown').textContent = '-';
      
      // Clear tableaus and hands
      const tableauA = document.getElementById('tableauA');
      const tableauB = document.getElementById('tableauB');
      const handA = document.getElementById('handA');
      const handB = document.getElementById('handB');
      
      if (tableauA) tableauA.innerHTML = '';
      if (tableauB) tableauB.innerHTML = '';
      if (handA) handA.innerHTML = '';
      if (handB) handB.innerHTML = '';
      
      // Reset dot counter display
      const sharedDotCounter = document.getElementById('sharedDotCounter');
      if (sharedDotCounter) {
        sharedDotCounter.textContent = '0';
      }
      
      // Reset timer display
      const timer = document.getElementById('timer');
      if (timer) {
        timer.textContent = '';
        timer.className = 'timer-display';
      }
      
      // Reset player displays
      const playerAName = document.getElementById('playerAName');
      const playerBName = document.getElementById('playerBName');
      const playerAStatus = document.getElementById('playerAStatus');
      const playerBStatus = document.getElementById('playerBStatus');
      
      if (playerAName) playerAName.textContent = '';
      if (playerBName) playerBName.textContent = '';
      if (playerAStatus) playerAStatus.textContent = '';
      if (playerBStatus) playerBStatus.textContent = '';
      
      // Reset active player display
      const activePlayerText = document.querySelector('.game-header p');
      if (activePlayerText) {
        activePlayerText.textContent = 'Active Player: -';
      }
      
      // Reset phase display
      const phaseText = document.querySelector('.game-header p:last-child');
      if (phaseText) {
        phaseText.textContent = 'Phase: WAITING';
      }
      
      // Hide choice modal
      const choiceModal = document.getElementById('choiceModal');
      if (choiceModal) {
        choiceModal.classList.remove('show');
        choiceModal.style.display = 'none';
      }
      
      // Hide winner display
      const winnerDisplay = document.getElementById('winnerDisplay');
      if (winnerDisplay) {
        winnerDisplay.style.display = 'none';
      }
      
      // Re-enable game controls
      const controls = ['playBtn', 'autoBtn', 'chooseFaceUpBtn', 'chooseFaceDownBtn'];
      controls.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
          element.disabled = false;
          element.style.opacity = '1';
        }
      });
      
      log('Game state cleared completely for rematch');
    }

    // Force show home screen on load
    document.addEventListener('DOMContentLoaded', function() {
      console.log('DOM loaded, showing home screen');
      showScreen('homeScreen');
    });

    // Also show home screen immediately
    showScreen('homeScreen');
  </script>
</body>
</html>

<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Office Duel - Enhanced UI v2.0</title>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <style>
    body { font-family: sans-serif; margin: 20px; background: #f5f5f5; }
    .game-container { 
      display: grid; 
      grid-template-columns: auto 1fr; 
      grid-template-rows: auto 1fr auto; 
      gap: 20px; 
      min-height: 80vh;
    }
    .game-header { grid-column: 2; grid-row: 1; }
    .game-main { grid-column: 2; grid-row: 2; }
    .game-footer { grid-column: 2; grid-row: 3; }
    .game-sidebar { 
      grid-column: 1; 
      grid-row: 1 / 4; 
      display: flex;
      flex-direction: column;
      justify-content: center; /* Centra verticalmente el contenido */
      align-items: center; /* Centra horizontalmente el contenido */
    }
    .player-section { border: 2px solid #ddd; padding: 20px; border-radius: 12px; background: white; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    .player-section.active { background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); border-color: #2196f3; box-shadow: 0 4px 16px rgba(33, 150, 243, 0.3); }
    .player-section h3 { margin: 0 0 15px 0; font-size: 1.2em; color: #333; }
    .player-area-label { 
      display: inline-block; 
      background: #2196f3; 
      color: white; 
      padding: 4px 12px; 
      border-radius: 20px; 
      font-size: 0.8em; 
      margin-bottom: 10px; 
    }
    .player-area-label.opponent { background: #ff5722; }
    .hand { display: flex; gap: 8px; margin: 10px 0; flex-wrap: wrap; }
    .card {
      width: 140px;
      min-height: 200px;
      padding: 10px;
      border: 2px solid #888;
      border-radius: 8px;
      cursor: pointer;
      background: white;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      justify-content: flex-start;
      text-align: center;
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .card:hover { 
      background: #f0f8ff; 
      border-color: #2196f3; 
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    .card.selected { 
      background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); 
      border-color: #2196f3; 
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
    }
    .card-title { font-weight: bold; margin-bottom: 6px; }
    .card-effects { list-style: none; padding: 0; margin: 0; font-size: 12px; text-align: left; }
    .card-effects li { color: #000; }
    .card-effects li.active { color: #28a745; font-weight: bold; }
    
    /* Effect highlighting for choose modal */
    .card-effects li.effect-mine { 
      color: #3da7ff !important; 
      font-weight: bold; 
      background: rgba(61, 167, 255, 0.1);
      padding: 2px 6px;
      border-radius: 4px;
      margin: 1px 0;
    }
    .card-effects li.effect-opponent { 
      color: #ff9d46 !important; 
      font-weight: bold; 
      background: rgba(255, 157, 70, 0.1);
      padding: 2px 6px;
      border-radius: 4px;
      margin: 1px 0;
    }
    .tableau { display: flex; gap: 4px; margin: 10px 0; flex-wrap: wrap; }
    .tableau-card {
      width: 140px;
      min-height: 200px;
      padding: 8px;
      border: 2px solid #ccc;
      border-radius: 6px;
      background: #f9f9f9;
      font-size: 12px;
      position: relative;
      display: flex;
      flex-direction: column;
      text-align: center;
    }
    .stacked-card { position: relative; }
    .card-count-badge { 
      position: absolute; 
      top: -8px; 
      right: -8px; 
      background: #ff4444; 
      color: white; 
      border-radius: 50%; 
      width: 20px; 
      height: 20px; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      font-size: 10px; 
      font-weight: bold; 
      border: 2px solid white;
    }
    .card-tooltip { position: relative; }
    .card-tooltip:hover .tooltip-content { display: block; }
    .tooltip-content { 
      display: none; position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); 
      background: #333; color: white; padding: 8px; border-radius: 4px; white-space: nowrap; 
      z-index: 1000; font-size: 12px; max-width: 300px; white-space: normal;
    }
    .log { white-space: pre-wrap; font-family: monospace; max-height: 200px; overflow: auto; border: 1px solid #eee; padding: 8px; background: #f9f9f9; }
    .controls { 
      margin: 20px 0; 
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    
    .controls button {
      background: #4caf50;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      transition: all 0.3s ease;
    }
    
    .controls button:hover:not(:disabled) {
      background: #45a049;
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    
    .controls button:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    .status { font-weight: bold; margin: 10px 0; }
    
    .choice-cards {
      display: flex;
      gap: 20px;
      margin: 10px 0;
    }
    
    .choice-card {
      border: 2px solid #28a745;
      border-radius: 8px;
      padding: 15px;
      background: #f8f9fa;
      text-align: center;
      flex: 1;
    }
    
    .choice-card button {
      margin-top: 10px;
      padding: 8px 16px;
      background: #28a745;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .choice-card button:hover {
      background: #218838;
    }
    
    .shared-counter {
      text-align: center;
      margin: 20px 0;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 12px;
      color: white;
      min-width: 200px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    
    .dot-display {
      margin: 15px 0;
    }
    
    .dot-value {
      font-size: 48px;
      font-weight: bold;
      margin: 10px 0;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    
    .visual-counter {
      font-size: 24px !important;
    }
    
    .visual-counter-display {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }
    
    .player-name {
      font-size: 12px;
      font-weight: bold;
      color: rgba(255, 255, 255, 0.9);
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    }
    
    .stones-container {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 20px;
    }
    
    .stone {
      display: inline-block;
      width: 16px;
      height: 16px;
      line-height: 16px;
      text-align: center;
      border-radius: 50%;
      transition: all 0.3s ease;
    }
    
    .stone.active {
      color: #ffd700;
      text-shadow: 0 0 8px rgba(255, 215, 0, 0.8);
      transform: scale(1.2);
    }
    
    .stone.inactive {
      color: rgba(255, 255, 255, 0.4);
    }
    
    .stone.center {
      color: rgba(255, 255, 255, 0.6);
      font-weight: bold;
    }
    
    .dot-labels {
      display: flex;
      justify-content: space-between;
      font-size: 14px;
      margin-top: 10px;
    }
    
    .player-label {
      background: rgba(255,255,255,0.2);
      padding: 5px 10px;
      border-radius: 15px;
    }
    
    .neutral-label {
      background: rgba(255,255,255,0.3);
      padding: 5px 10px;
      border-radius: 15px;
      font-weight: bold;
    }
    
    .winner-display {
      margin-top: 15px;
      padding: 15px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      border: 2px solid #fff;
    }
    
    .winner-display h2 {
      margin: 0;
      color: #fff;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }
    
    /* Enhanced Timer Styling */
    .timer-display {
      display: inline-block;
      padding: 8px 16px;
      border-radius: 20px;
      font-weight: bold;
      font-size: 1.1em;
      transition: all 0.3s ease;
      background: #4caf50;
      color: white;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    .timer-display.warning { background: #ff9800; }
    .timer-display.danger { background: #f44336; animation: pulse 1s infinite; }
    @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
    
    /* Game Status Enhancements */
    .game-status {
      background: white;
      padding: 15px;
      border-radius: 8px;
      margin: 10px 0;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border-left: 4px solid #2196f3;
    }
    
    /* Enhanced Choice Modal - Bottom Sheet Style */
    .choice-modal {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 45vh;
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      border-top: 4px solid #2196f3;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transform: translateY(100%);
      transition: transform 0.3s ease-in-out;
      box-shadow: 0 -8px 32px rgba(0,0,0,0.3);
    }
    .choice-modal.show {
      transform: translateY(0);
    }
    .choice-modal-content {
      background: transparent;
      padding: 20px;
      width: 100%;
      max-width: 800px;
    }
    
    /* Desktop sidebar variant */
    @media (min-width: 900px) {
      .choice-modal {
        position: fixed;
        top: 0;
        right: 0;
        width: 35%;
        height: 100vh;
        left: auto;
        bottom: auto;
        transform: translateX(100%);
        border-top: none;
        border-left: 4px solid #2196f3;
      }
      .choice-modal.show {
        transform: translateX(0);
      }
    }
    
    .choice-btn {
      background: #2196f3;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 1.1em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 2px 8px rgba(33, 150, 243, 0.3);
    }
    
    .choice-btn:hover {
      background: #1976d2;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
    }
    
    .choice-btn:active {
      transform: translateY(0);
    }
    
    /* Layout specific styles */
    .game-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 0;
    }
    
    .timer-top-right {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 100;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .auto-turn-btn {
      background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 0.9em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 2px 8px rgba(255, 152, 0, 0.3);
    }
    
    .auto-turn-btn:hover {
      background: linear-gradient(135deg, #f57c00 0%, #ef6c00 100%);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(255, 152, 0, 0.4);
    }
    
    .enemy-area {
      margin-bottom: 20px;
    }
    
    .player-area {
      margin-top: 20px;
    }
    
    /* Play Cards Section */
    .play-cards-section {
      margin-top: 20px;
      padding: 15px;
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      border-radius: 8px;
      border: 2px solid #dee2e6;
    }
    
    .play-selected-btn {
      background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 1.1em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
      width: 100%;
      margin-top: 10px;
    }
    
    .play-selected-btn:hover {
      background: linear-gradient(135deg, #218838 0%, #1aa179 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(40, 167, 69, 0.4);
    }
    
    .play-selected-btn:active {
      transform: translateY(0);
    }
    
    .play-selected-btn:disabled {
      background: #6c757d;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    /* Modal Card Display */
    .modal-card-display {
      background: white;
      border: 2px solid #ddd;
      border-radius: 8px;
      padding: 15px;
      margin: 10px 0;
      min-height: 120px;
      display: flex;
      flex-direction: column;
    }
    
    .modal-card-title {
      font-weight: bold;
      font-size: 1.1em;
      color: #333;
      margin-bottom: 10px;
      text-align: center;
    }
    
    .modal-card-effects {
      font-size: 0.9em;
      color: #666;
      line-height: 1.4;
    }
    
    .modal-card-effects ul {
      margin: 0;
      padding-left: 20px;
      list-style-type: disc;
    }
    
    .modal-card-effects li {
      margin: 4px 0;
    }
    
    .modal-card-title.hidden-card {
      color: #666 !important;
      font-style: italic !important;
      position: relative;
    }
    
    .modal-card-title.hidden-card::after {
      content: " (Hidden)";
      font-size: 0.8em;
      color: #999;
    }
    
    /* Screen Management Styles */
    .screen {
      min-height: 70vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    
    .screen-content {
      background: white;
      padding: 40px;
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
      text-align: center;
      max-width: 500px;
      width: 100%;
    }
    
    .screen-content h2 {
      color: #333;
      margin-bottom: 20px;
      font-size: 2em;
    }
    
    .screen-content p {
      color: #666;
      margin-bottom: 30px;
      font-size: 1.1em;
    }
    
    /* Home Screen Styles */
    .home-buttons {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .home-btn {
      background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%);
      color: white;
      border: none;
      padding: 20px 30px;
      border-radius: 12px;
      font-size: 1.2em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 16px rgba(33, 150, 243, 0.3);
    }
    
    .home-btn:hover {
      background: linear-gradient(135deg, #1976d2 0%, #1565c0 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(33, 150, 243, 0.4);
    }
    
    .home-btn:active {
      transform: translateY(0);
    }
    
    /* Input Group Styles */
    .input-group {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin: 20px 0;
    }
    
    .input-group input {
      padding: 15px;
      border: 2px solid #ddd;
      border-radius: 8px;
      font-size: 1em;
      transition: border-color 0.3s ease;
    }
    
    .input-group input:focus {
      outline: none;
      border-color: #2196f3;
      box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
    }
    
    .action-btn {
      background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
      color: white;
      border: none;
      padding: 15px 30px;
      border-radius: 8px;
      font-size: 1.1em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 16px rgba(76, 175, 80, 0.3);
    }
    
    .action-btn:hover {
      background: linear-gradient(135deg, #45a049 0%, #3d8b40 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
    }
    
    .secondary-btn {
      background: transparent;
      color: #666;
      border: 2px solid #ddd;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 1em;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-top: 20px;
    }
    
    .secondary-btn:hover {
      background: #f5f5f5;
      border-color: #bbb;
    }
    
    /* Ready Screen Styles */
    .match-info {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 8px;
      margin: 20px 0;
    }
    
    .copy-btn {
      background: #ff9800;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 0.9em;
      cursor: pointer;
      margin-left: 10px;
      transition: all 0.3s ease;
    }
    
    .copy-btn:hover {
      background: #f57c00;
    }
    
    .players-status {
      margin: 30px 0;
    }
    
    .player-status {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 15px;
      margin: 10px 0;
      background: #f8f9fa;
      border-radius: 8px;
      border-left: 4px solid #2196f3;
    }
    
    .player-label {
      font-weight: bold;
      color: #333;
    }
    
    .ready-status {
      font-weight: bold;
    }
    
    .ready-status.ready {
      color: #4caf50;
    }
    
    .ready-status.not-ready {
      color: #f44336;
    }
    
    .ready-btn {
      background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
      color: white;
      border: none;
      padding: 20px 40px;
      border-radius: 12px;
      font-size: 1.3em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 16px rgba(76, 175, 80, 0.3);
      margin: 20px 0;
    }
    
    .ready-btn:hover {
      background: linear-gradient(135deg, #45a049 0%, #3d8b40 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
    }
    
    .waiting-message {
      color: #666;
      font-style: italic;
      margin-top: 20px;
    }
    
    /* Push number styling */
    .push-positive {
      color: #4caf50;
      font-weight: bold;
    }
    
    .push-negative {
      color: #f44336;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>Office Duel - Enhanced UI</h1>
  
  <!-- Screen 1: Home Screen -->
  <div id="homeScreen" class="screen" style="display: block;">
    <div class="screen-content">
      <h2>üéÆ Welcome to Office Duel!</h2>
      <p>Choose how you want to play:</p>
      <div class="home-buttons">
        <button id="createMatchBtn" class="home-btn">üè¢ Create Match</button>
        <button id="joinMatchBtn" class="home-btn">üîó Join Match</button>
        <button id="playBotBtn" class="home-btn">ü§ñ Play vs Bot</button>
      </div>
    </div>
  </div>

  <!-- Screen 2: Create Match Screen -->
  <div id="createMatchScreen" class="screen" style="display: none;">
    <div class="screen-content">
      <h2>Create New Match</h2>
      <p>Enter your name to create a match:</p>
      <div class="input-group">
        <input id="createPlayerName" type="text" placeholder="Your name" />
        <button id="confirmCreateBtn" class="action-btn">Create Match</button>
      </div>
      <button id="backToHomeBtn" class="secondary-btn">‚Üê Back to Home</button>
    </div>
  </div>

  <!-- Screen 2: Join Match Screen -->
  <div id="joinMatchScreen" class="screen" style="display: none;">
    <div class="screen-content">
      <h2>Join Existing Match</h2>
      <p>Enter the match ID and your name:</p>
      <div class="input-group">
        <input id="joinMatchId" type="text" placeholder="Match ID" />
        <input id="joinPlayerName" type="text" placeholder="Your name" />
        <button id="confirmJoinBtn" class="action-btn">Join Match</button>
      </div>
      <button id="backToHomeBtn2" class="secondary-btn">‚Üê Back to Home</button>
    </div>
  </div>

  <!-- Screen 3: Ready Screen -->
  <div id="readyScreen" class="screen" style="display: none;">
    <div class="screen-content">
      <h2>Waiting Room</h2>
      <div class="match-info">
        <p><strong>Match ID:</strong> <span id="displayMatchId">-</span></p>
        <button id="copyMatchIdBtn" class="copy-btn">üìã Copy Match ID</button>
      </div>
      <div class="players-status">
        <div class="player-status">
          <span class="player-label">Player A:</span>
          <span id="playerAName">-</span>
          <span id="playerAReady" class="ready-status">(Not Ready)</span>
        </div>
        <div class="player-status">
          <span class="player-label">Player B:</span>
          <span id="playerBName">-</span>
          <span id="playerBReady" class="ready-status">(Not Ready)</span>
        </div>
      </div>
      <button id="readyBtn" class="ready-btn" style="display: none;">I'm Ready!</button>
      <div id="waitingMessage" class="waiting-message">Waiting for both players to be ready...</div>
    </div>
  </div>

  <!-- Screen 4: Game Screen -->
  <div id="gameScreen" class="screen" style="display: none;">
    <div class="game-container" id="gameContainer">
      <!-- Timer in top right -->
      <div class="timer-top-right">
        <div class="status">Timer: <span id="timer" class="timer-display">-</span></div>
        <button id="autoBtn" class="auto-turn-btn">Auto Turn</button>
      </div>
    
    <!-- Left Sidebar - Shared Counter -->
    <div class="game-sidebar">
      <div class="shared-counter">
        <h3>Battle Stones</h3>
        <div class="dot-display">
          <div class="dot-value" id="dotCounter">0</div>
          <div class="dot-labels">
            <span class="player-label">B Wins (-5)</span>
            <span class="neutral-label">Neutral (0)</span>
            <span class="player-label">A Wins (+5)</span>
          </div>
        </div>
        <div id="winnerDisplay" class="winner-display" style="display: none;">
          <h2 id="winnerText">Game Over!</h2>
        </div>
      </div>
    </div>
    
    <!-- Game Header -->
    <div class="game-header">
      <div class="status">Active Player: <span id="active">-</span></div>
      <div class="status">Phase: <span id="phase">-</span></div>
    </div>
    
    <!-- Main Game Area -->
    <div class="game-main">
      <!-- Enemy Area (Top) -->
      <div class="player-section enemy-area" id="playerA">
        <div class="player-area-label opponent">Opponent Area</div>
        <h3 id="playerATitle">Player A</h3>
        <div class="status">Hand: <span id="handSizeA">-</span> cards</div>
        <div class="status">Tableau: <span id="tableauSizeA">-</span> cards</div>
        <h4>Hand:</h4>
        <div class="hand" id="handA"></div>
        <h4>Tableau:</h4>
        <div class="tableau" id="tableauA"></div>
      </div>

      <!-- Your Area (Bottom) -->
      <div class="player-section player-area" id="playerB">
        <div class="player-area-label">Your Area</div>
        <h3 id="playerBTitle">Player B</h3>
        <div class="status">Hand: <span id="handSizeB">-</span> cards</div>
        <div class="status">Tableau: <span id="tableauSizeB">-</span> cards</div>
        <h4>Hand:</h4>
        <div class="hand" id="handB"></div>
        <h4>Tableau:</h4>
        <div class="tableau" id="tableauB"></div>
        
        <!-- Play Cards Section -->
        <div class="play-cards-section">
          <div class="status" id="selectionStatus">Selected: Face Up=<span id="selUp">-</span>, Face Down=<span id="selDown">-</span></div>
          <button id="playBtn" class="play-selected-btn" style="display: none;">üéØ Play Selected Cards</button>
        </div>
      </div>
    </div>
    
      <!-- Game Footer -->
      <div class="game-footer">
        <h3>Game Log</h3>
        <div id="gameLog" class="log"></div>
      </div>
    </div>
  </div>

    <!-- Enhanced Card Choice Modal -->
    <div id="choiceModal" class="choice-modal" style="display: none;">
      <div class="choice-modal-content">
        <h2 id="choiceModalTitle">Choose Between These Cards</h2>
        <p style="text-align: center; color: #666; margin: 10px 0; font-size: 0.9em;">
          <span style="color: #3da7ff; font-weight: bold;">Blue</span> = Effect for you | 
          <span style="color: #ff9d46; font-weight: bold;">Orange</span> = Effect for opponent
        </p>
        <div class="choice-cards">
          <div class="choice-card">
            <h4>Face Up Card</h4>
            <div class="modal-card-display" id="faceUpCardDisplay">
              <div class="modal-card-title">-</div>
              <div class="modal-card-effects">-</div>
            </div>
            <button id="chooseFaceUpBtn" onclick="chooseFaceUp()" class="choice-btn">Choose This One</button>
          </div>
          <div class="choice-card">
            <h4>Face Down Card</h4>
            <div class="modal-card-display" id="faceDownCardDisplay">
              <div class="modal-card-title">???</div>
              <div class="modal-card-effects">???</div>
            </div>
            <button id="chooseFaceDownBtn" onclick="chooseFaceDown()" class="choice-btn">Choose This One</button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Fallback choice status for non-modal display -->
    <div class="status" id="choiceStatus" style="display: none;">
      <h4>Opponent must choose between these two cards:</h4>
      <div class="choice-cards">
        <div class="choice-card">
          <strong>Face Up Card:</strong> <span id="faceUpCard">-</span>
          <button id="chooseFaceUpBtnFallback" onclick="chooseFaceUp()">Choose This One</button>
        </div>
        <div class="choice-card">
          <strong>Face Down Card:</strong> <span id="faceDownCard">-</span>
          <button id="chooseFaceDownBtnFallback" onclick="chooseFaceDown()">Choose This One</button>
        </div>
      </div>
    </div>
    <button id="playBtn" style="display: none;">Play Selected</button>
  </div>

  <!-- Game Log moved to game screen -->
  <div id="log" class="log" style="display: none;"></div>

  <script>
    // Cache refresh handled by meta tags
    
    const api = 'https://smarter-co00.onrender.com';
    let matchId = '';
    let playerSeat = null;
    let playerName = null;
    
    // Ask for player name on page load (once per browser)
    (function askPlayerName(){
      let stored = localStorage.getItem('playerName');
      if(!stored){
        stored = prompt('Enter your name');
        if(stored){
          localStorage.setItem('playerName', stored);
        }
      }
      playerName = stored || null;
    })();

    // Screen management functions
    function showScreen(screenId) {
      const screens = ['homeScreen', 'createMatchScreen', 'joinMatchScreen', 'readyScreen', 'gameScreen'];
      screens.forEach(id => {
        document.getElementById(id).style.display = 'none';
      });
      document.getElementById(screenId).style.display = 'block';
      
      // Special handling for game screen
      if (screenId === 'gameScreen') {
        document.getElementById('gameContainer').style.display = 'grid';
      } else {
        document.getElementById('gameContainer').style.display = 'none';
      }
    }

    // Read matchId from URL and check for existing seat
    (function initMatchFromUrl(){
      const url = new URL(window.location.href);
      const pMatch = url.searchParams.get('match');
      if(pMatch){
        matchId = pMatch;
      } else {
        const parts = window.location.pathname.split('/');
        if(parts.length>=3 && parts[1]==='app' && parts[2].length>0){
          matchId = parts[2];
        }
      }
      
      // Check localStorage for existing seat
      const storedSeat = localStorage.getItem('match_' + matchId + '_seat');
      const storedName = localStorage.getItem('match_' + matchId + '_name');
      
      if(storedSeat !== null && storedName !== null){
        playerSeat = parseInt(storedSeat);
        playerName = storedName;
      }
      
      if(matchId){
        document.getElementById('displayMatchId').textContent = matchId;
        if(playerSeat !== null){
          startAutoRefresh();
          refresh();
        } else {
          showScreen('joinMatchScreen');
        }
      } else {
        showScreen('homeScreen');
      }
      
      // Debug: log current screen
      console.log('Initial screen:', matchId ? (playerSeat !== null ? 'game/ready' : 'join') : 'home');
    })();
    let gameState = null;
    let selUp = null, selDown = null;
    let turnTimer = null;
    let choiceTimer = null;
    let turnTimeLeft = 30;
    let choiceTimeLeft = 15;

    async function req(url, opts={}) {
      const r = await fetch(url, opts);
      if (!r.ok) throw new Error(await r.text());
      return r.json();
    }

    function log(msg){
      const el = document.getElementById('gameLog');
      if (el) {
        el.textContent += msg + "\n";
        el.scrollTop = el.scrollHeight;
      }
    }

    function renderCard(cardId, cardDef, isSelectable = false, realCardId = null) {
      const div = document.createElement('div');
      div.className = 'card-tooltip';
      
      // Use real card ID for backend, display ID for UI
      const realId = realCardId || cardId;
      const displayId = cardId;
      
        const btn = document.createElement('button');
      btn.className = 'card' + (isSelectable && (selUp === displayId || selDown === displayId) ? ' selected' : '');
      //btn.textContent = displayId + (cardDef ? (' - ' + cardDef.name) : '');
      btn.setAttribute('data-real-id', realId); // Store real ID for backend
      
      // Build inner layout: title + effects list
      if(cardDef){
          const title = document.createElement('div');
          title.className = 'card-title';
          title.textContent = cardDef.name;
          btn.appendChild(title);
          const ul = document.createElement('ul');
          ul.className = 'card-effects';
          // Show first 3 tiers descriptions (first action per tier)
          cardDef.tiers.forEach((tier, idx)=>{
             const li=document.createElement('li');
             li.innerHTML = (idx+1)+'. '+ (tier.actions[0]?.description || '');
             ul.appendChild(li);
          });
          btn.appendChild(ul);
      } else {
          btn.textContent = displayId;
      }
      
      // Only allow selection if it's selectable AND not waiting for opponent choice
      const canSelect = isSelectable && !gameState.waitingForOpponentChoice;
      
      if (canSelect) {
        btn.onclick = () => {
          if (!selUp) selUp = realId; // Use real ID for backend
          else if (!selDown && realId !== selUp) selDown = realId; 
          else { selUp = realId; selDown = null; }
          document.getElementById('selUp').textContent = selUp || '-';
          document.getElementById('selDown').textContent = selDown || '-';
          // Don't re-render hands, just update the visual selection
          updateCardSelection();
        };
      }
      
      if (cardDef) {
        const tooltip = document.createElement('div');
        tooltip.className = 'tooltip-content';
        tooltip.innerHTML = generateCardTooltip(cardDef);
        div.appendChild(tooltip);
      }
      
      div.appendChild(btn);
      return div;
    }

    function generateCardTooltip(cardDef) {
      let html = `<strong>${cardDef.name}</strong><br>`;
      html += `Tags: ${cardDef.tags.join(', ')}<br><br>`;
      
      cardDef.tiers.forEach((tier, index) => {
        html += `<strong>Tier ${index + 1}:</strong><br>`;
        tier.actions.forEach(action => {
          if (action.description && action.description.trim() !== '') {
            html += `‚Ä¢ ${action.description}<br>`;
          }
        });
        html += '<br>';
      });
      
      return html;
    }

    function generateEffectsHTML(cardDef) {
      let html = '<ul>';
      cardDef.tiers.forEach((tier, index) => {
        tier.actions.forEach(action => {
          if (action.description && action.description.trim() !== '') {
            html += `<li><strong>Tier ${index + 1}:</strong> ${action.description}</li>`;
          }
        });
      });
      html += '</ul>';
      return html;
    }

    // Helper function to calculate next effect level for a player
    function getNextEffectLevel(cardId, playerSeat) {
      if (!gameState || !gameState.cardDefinitions[cardId]) return 0;
      
      // Count how many copies of this card the player has in their tableau
      let cardCount = 0;
      if (playerSeat === 0) {
        cardCount = gameState.tableauCardIdsA.filter(id => id === cardId).length;
      } else {
        cardCount = gameState.tableauCardIdsB.filter(id => id === cardId).length;
      }
      
      // Return the tier level (0, 1, or 2) that will be activated
      return Math.min(cardCount, 2);
    }

    // Generate effects HTML with highlighting for choose modal
    function generateEffectsHTMLWithHighlighting(cardDef, isForOpponent = false) {
      if (!cardDef || !gameState) return '<ul></ul>';
      
      const viewingPlayerSeat = playerSeat;
      const otherPlayerSeat = 1 - viewingPlayerSeat;
      
      let html = '<ul>';
      cardDef.tiers.forEach((tier, index) => {
        tier.actions.forEach(action => {
          if (action.description && action.description.trim() !== '') {
            const myLevel = getNextEffectLevel(cardDef.id || Object.keys(gameState.cardDefinitions).find(id => gameState.cardDefinitions[id] === cardDef), viewingPlayerSeat);
            const opponentLevel = getNextEffectLevel(cardDef.id || Object.keys(gameState.cardDefinitions).find(id => gameState.cardDefinitions[id] === cardDef), otherPlayerSeat);
            
            let className = '';
            if (index === myLevel) {
              className = 'effect-mine';
            } else if (index === opponentLevel) {
              className = 'effect-opponent';
            }
            
            html += `<li class="${className}"><strong>Tier ${index + 1}:</strong> ${action.description}</li>`;
          }
        });
      });
      html += '</ul>';
      return html;
    }

    function renderHands() {
      if (!gameState || playerSeat === null) return;
      
      // Determine which hand divs belong to me vs opponent
      const myHandDiv = playerSeat === 0 ? document.getElementById('handA') : document.getElementById('handB');
      const oppHandDiv = playerSeat === 0 ? document.getElementById('handB') : document.getElementById('handA');
      
      // Clear both hands
      myHandDiv.innerHTML = '';
      oppHandDiv.innerHTML = '';
      
      // Render my hand with real cards
      if (gameState.activeHandCardIds && gameState.activeHandCardIds.length > 0) {
        const cardCounts = {};
        gameState.activeHandCardIds.forEach(id => {
          cardCounts[id] = (cardCounts[id] || 0) + 1;
        });
        
        Object.keys(cardCounts).forEach(id => {
          const count = cardCounts[id];
          const cardDef = gameState.cardDefinitions[id];
          for (let i = 0; i < count; i++) {
            const uniqueId = count > 1 ? `${id}_${i}` : id;
            myHandDiv.appendChild(renderCard(uniqueId, cardDef, true, id));
          }
        });
      }
      
      // Render opponent hand with card backs (dots)
      const oppHandSize = playerSeat === 0 ? gameState.handSizeB : gameState.handSizeA;
      for (let i = 0; i < oppHandSize; i++) {
        const cardBack = document.createElement('div');
        cardBack.className = 'card-tooltip';
        cardBack.style.width = '140px';
        cardBack.style.height = '200px';
        cardBack.style.border = '2px solid #666';
        cardBack.style.borderRadius = '8px';
        cardBack.style.backgroundColor = '#333';
        cardBack.style.display = 'flex';
        cardBack.style.alignItems = 'center';
        cardBack.style.justifyContent = 'center';
        cardBack.style.fontSize = '24px';
        cardBack.style.color = '#fff';
        cardBack.textContent = '?';
        oppHandDiv.appendChild(cardBack);
      }
    }

    function renderTableaus() {
      if (!gameState) return;
      
      // Render Player A tableau
      const tableauA = document.getElementById('tableauA');
      tableauA.innerHTML = '';
      const cardCountsA = {};
      gameState.tableauCardIdsA.forEach(id => {
        cardCountsA[id] = (cardCountsA[id] || 0) + 1;
      });
      
      Object.keys(cardCountsA).forEach(id => {
        const count = cardCountsA[id];
        const cardDef = gameState.cardDefinitions[id];
        const stackedCard = renderStackedCard(id, cardDef, count);
        tableauA.appendChild(stackedCard);
      });
      
      // Render Player B tableau
      const tableauB = document.getElementById('tableauB');
      tableauB.innerHTML = '';
      const cardCountsB = {};
      gameState.tableauCardIdsB.forEach(id => {
        cardCountsB[id] = (cardCountsB[id] || 0) + 1;
      });
      
      Object.keys(cardCountsB).forEach(id => {
        const count = cardCountsB[id];
        const cardDef = gameState.cardDefinitions[id];
        const stackedCard = renderStackedCard(id, cardDef, count);
        tableauB.appendChild(stackedCard);
      });
    }

    function renderStackedCard(cardId, cardDef, count) {
      const div = document.createElement('div');
      div.className = 'card-tooltip stacked-card';
      
      const btn = document.createElement('button');
      btn.className = 'tableau-card';
      //btn.textContent = cardId + (cardDef ? (' - ' + cardDef.name) : '');
      btn.style.width = '140px';
      btn.style.minHeight = '200px';
      btn.style.position='relative';
      
      if(cardDef){
          const title=document.createElement('div');
          title.className='card-title';
          title.textContent=cardDef.name;
          btn.appendChild(title);
          const ul=document.createElement('ul');
          ul.className='card-effects';
          cardDef.tiers.forEach((tier,idx)=>{
              const li=document.createElement('li');
              li.innerHTML=(idx+1)+'. '+(tier.actions[0]?.description||'');
              if(idx===Math.min(count-1,2)) li.classList.add('active');
              ul.appendChild(li);
          });
          btn.appendChild(ul);
      } else {
          btn.textContent=cardId;
      }
      
      // Add count badge if more than 1
      if (count > 1) {
        const badge = document.createElement('span');
        badge.className = 'card-count-badge';
        badge.textContent = count;
        btn.appendChild(badge);
      }
      
      if (cardDef) {
        const tooltip = document.createElement('div');
        tooltip.className = 'tooltip-content';
        tooltip.innerHTML = generateCardTooltip(cardDef);
        div.appendChild(tooltip);
      }
      
      div.appendChild(btn);
      return div;
    }

    async function createMatch() {
      const name = document.getElementById('createPlayerName').value.trim();
      if (!name) {
        alert('Please enter your name');
        return;
      }

      try {
        const data = await req(api + '/api/match', { method:'POST', headers:{'Content-Type':'application/json'}, body:'{}' });
        matchId = data.id;
        playerName = name;
        
        // Join the match we just created
        const response = await req(api + '/api/match/' + matchId + '/join', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: name })
        });

        playerSeat = response.seat;
        
        // Store in localStorage
        localStorage.setItem('match_' + matchId + '_seat', playerSeat);
        localStorage.setItem('match_' + matchId + '_name', playerName);
        
        document.getElementById('displayMatchId').textContent = matchId;
        showScreen('readyScreen');
        startAutoRefresh();
        refresh();
        
        log('Created match and joined as Player ' + (playerSeat === 0 ? 'A' : 'B'));
      } catch (error) {
        alert('Failed to create match: ' + error.message);
      }
    }

    async function createMatchWithBot() {
      const name = prompt('Enter your name for the bot match:');
      if (!name) return;
      
      try {
        const data = await req(api + '/api/match/bot', { method:'POST', headers:{'Content-Type':'application/json'}, body:'{}' });
        matchId = data.id;
        
        // Join as Player B (human player)
        const response = await req(api + '/api/match/' + matchId + '/join', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: name })
        });

        playerSeat = response.seat;
        playerName = name;
        
        // Store in localStorage
        localStorage.setItem('match_' + matchId + '_seat', playerSeat);
        localStorage.setItem('match_' + matchId + '_name', playerName);
        
        document.getElementById('displayMatchId').textContent = matchId;
        showScreen('readyScreen');
        startAutoRefresh();
        refresh();
        
        log('Created bot match and joined as Player ' + (playerSeat === 0 ? 'A' : 'B'));
      } catch (error) {
        alert('Failed to create bot match: ' + error.message);
      }
    }

    // New unified join flow
    async function joinMatch(){
      const id = document.getElementById('joinMatchId').value.trim();
      const name = document.getElementById('joinPlayerName').value.trim();

      if(!id){ alert('Please enter a match id'); return; }
      if(!name){ alert('Please enter your name'); return; }

      matchId = id;
      await joinMatchDirect(id, name);
    }

    // Helper that actually calls server /join
    async function joinMatchDirect(id, name){
      try {
        const response = await req(api + '/api/match/' + id + '/join', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name })
        });

        playerSeat = response.seat;
        playerName = name;

        // Persist for reloads
        localStorage.setItem('match_' + id + '_seat', playerSeat);
        localStorage.setItem('match_' + id + '_name', playerName);

        document.getElementById('displayMatchId').textContent = matchId;
        showScreen('readyScreen');
        startAutoRefresh();
        refresh();
        
        log('Joined match as Player ' + (playerSeat === 0 ? 'A' : 'B'));
      } catch (error) {
        alert('Failed to join match: ' + error.message);
      }
    }

    // Generate visual stone counter display
    function generateVisualCounter(dotCounter, playerAName, playerBName) {
      // Clamp counter between -5 and 5
      const clampedCounter = Math.max(-5, Math.min(5, dotCounter));
      
      // Truncate player names to max 10 characters
      const nameA = playerAName.length > 10 ? playerAName.substring(0, 10) + '...' : playerAName;
      const nameB = playerBName.length > 10 ? playerBName.substring(0, 10) + '...' : playerBName;
      
      // Generate stones array: 5 for player A, 1 neutral (center), 5 for player B
      const stones = [];
      
      // Player A stones (left side) - positive values (+1 to +5) - INVERTED
      for (let i = 1; i <= 5; i++) {
        if (clampedCounter === i) {
          stones.push('<span class="stone active">‚óè</span>'); // Active stone for exact position
        } else {
          stones.push('<span class="stone inactive">‚óã</span>'); // Inactive stone
        }
      }
      
      // Center neutral stone (0)
      if (clampedCounter === 0) {
        stones.push('<span class="stone active">‚óè</span>'); // Active center stone
      } else {
        stones.push('<span class="stone center">‚óã</span>'); // Inactive center stone
      }
      
      // Player B stones (right side) - negative values (-1 to -5) - INVERTED
      for (let i = 1; i <= 5; i++) {
        if (clampedCounter === -i) {
          stones.push('<span class="stone active">‚óè</span>'); // Active stone for exact position
        } else {
          stones.push('<span class="stone inactive">‚óã</span>'); // Inactive stone
        }
      }
      
      // Combine everything
      return `<div class="visual-counter-display">
        <div class="player-name">${nameA}</div>
        <div class="stones-container">${stones.join('')}</div>
        <div class="player-name">${nameB}</div>
      </div>`;
    }

    async function refresh() {
      if (!matchId) return;
      
      const url = playerSeat !== null ? 
        api + '/api/match/' + matchId + '?seat=' + playerSeat :
        api + '/api/match/' + matchId;
      
      gameState = await req(url);
      
      // Handle lobby state
      if (!gameState.started) {
        showLobby();
        return;
      }
      
      // Game started - show game UI
      showGame();
      
      // Update player info
      document.getElementById('handSizeA').textContent = gameState.handSizeA;
      document.getElementById('handSizeB').textContent = gameState.handSizeB;
      document.getElementById('tableauSizeA').textContent = gameState.tableauSizeA;
      document.getElementById('tableauSizeB').textContent = gameState.tableauSizeB;
      document.getElementById('active').textContent = gameState.activePlayer === 0 ? 'A' : 'B';
      document.getElementById('phase').textContent = gameState.phase || 'PLAY_TWO_CARDS';
      
      // Update player names and area labels based on current player
      const playerAName = gameState.playerA || 'Player A';
      const playerBName = gameState.playerB || 'Player B';
      document.getElementById('playerATitle').textContent = playerAName;
      document.getElementById('playerBTitle').textContent = playerBName;
      
      // Update area labels based on current player perspective
      const playerALabel = document.querySelector('#playerA .player-area-label');
      const playerBLabel = document.querySelector('#playerB .player-area-label');
      
      if (playerSeat === 0) {
        // Current player is Player A
        playerALabel.textContent = 'Your Area';
        playerALabel.className = 'player-area-label';
        playerBLabel.textContent = 'Opponent Area';
        playerBLabel.className = 'player-area-label opponent';
      } else if (playerSeat === 1) {
        // Current player is Player B
        playerALabel.textContent = 'Opponent Area';
        playerALabel.className = 'player-area-label opponent';
        playerBLabel.textContent = 'Your Area';
        playerBLabel.className = 'player-area-label';
      }
      
      // Update dot counter with visual stone system
      const dotCounter = gameState.sharedDotCounter;
      const dotCounterElement = document.getElementById('dotCounter');
      
      // Generate visual stone display
      const visualCounter = generateVisualCounter(dotCounter, playerAName, playerBName);
      dotCounterElement.innerHTML = visualCounter;
      
      // Update counter styling based on value
      dotCounterElement.className = 'dot-value visual-counter';
      if (dotCounter >= 5) {
        dotCounterElement.style.color = '#4caf50'; // Green for Player A winning
        dotCounterElement.style.textShadow = '0 0 10px rgba(76, 175, 80, 0.5)';
      } else if (dotCounter <= -5) {
        dotCounterElement.style.color = '#f44336'; // Red for Player B winning
        dotCounterElement.style.textShadow = '0 0 10px rgba(244, 67, 54, 0.5)';
      } else {
        dotCounterElement.style.color = '#fff'; // White for neutral
        dotCounterElement.style.textShadow = '2px 2px 4px rgba(0,0,0,0.3)';
      }
      
      // Check win conditions
      checkWinConditions();
      
      // Update active player highlighting with enhanced visual feedback
      const playerAElement = document.getElementById('playerA');
      const playerBElement = document.getElementById('playerB');
      
      playerAElement.classList.toggle('active', gameState.activePlayer === 0);
      playerBElement.classList.toggle('active', gameState.activePlayer === 1);
      
      // Add active turn indicator to player titles
      const playerATitle = document.getElementById('playerATitle');
      const playerBTitle = document.getElementById('playerBTitle');
      
      if (gameState.activePlayer === 0) {
        playerATitle.innerHTML = (gameState.playerA || 'Player A') + ' <span style="color: #4caf50; font-size: 0.8em;">üü¢ Your Turn</span>';
        playerBTitle.textContent = gameState.playerB || 'Player B';
      } else {
        playerATitle.textContent = gameState.playerA || 'Player A';
        playerBTitle.innerHTML = (gameState.playerB || 'Player B') + ' <span style="color: #4caf50; font-size: 0.8em;">üü¢ Your Turn</span>';
      }
      
      // Update UI based on phase
      updateUIForPhase();
      
      // Render hands and tableaus
      renderHands();
      renderTableaus();
      
      // Ensure interaction is properly toggled
      const isMyTurn = playerSeat !== null && playerSeat === gameState.activePlayer;
      toggleInteraction(isMyTurn);
      
      // Auto-play bot turns
      if (gameState.started) {
        const isPlayerABot = gameState.playerAIsBot;
        const isPlayerBBot = gameState.playerBIsBot;
        const activePlayer = gameState.activePlayer;
        const phase = gameState.phase;
        const inactivePlayer = 1 - activePlayer;
        
        console.log('Bot check: started=' + gameState.started + ', isPlayerABot=' + isPlayerABot + ', isPlayerBBot=' + isPlayerBBot + ', activePlayer=' + activePlayer + ', phase=' + phase);
        
        let shouldAct = false;
        let delay = 1000;
        let action = 'playing';
        
        if (phase === 'PLAY_TWO_CARDS') {
          // Submit phase: only active player bot acts
          if ((activePlayer === 0 && isPlayerABot) || (activePlayer === 1 && isPlayerBBot)) {
            shouldAct = true;
            delay = 1000; // 1 second to select cards
            action = 'selecting cards';
          }
        } else if (phase === 'OPPONENT_PICK') {
          // Choice phase: only inactive player bot acts
          if ((inactivePlayer === 0 && isPlayerABot) || (inactivePlayer === 1 && isPlayerBBot)) {
            shouldAct = true;
            delay = 3000; // 3 seconds to choose between cards
            action = 'choosing between cards';
          }
        }
        
        if (shouldAct) {
          console.log('Bot will ' + action + ' in ' + delay + 'ms');
          setTimeout(async () => {
            try {
              await req(api + '/api/match/' + matchId + '/bot-turn?seat=' + playerSeat, { method: 'POST' });
              log('Bot ' + action + ' automatically');
            } catch (error) {
              console.log('Bot auto-play failed:', error);
            }
          }, delay);
        }
      }
    }

    function toggleInteraction(isMyTurn) {
      const phase = gameState.phase || 'PLAY_TWO_CARDS';
      const canInteract = isMyTurn && phase === 'PLAY_TWO_CARDS';
      
      // Enable/disable hand cards
      const handCards = document.querySelectorAll('.hand .card');
      handCards.forEach(card => {
        if (canInteract) {
          card.style.pointerEvents = 'auto';
          card.style.opacity = '1';
        } else {
          card.style.pointerEvents = 'none';
          card.style.opacity = '0.5';
        }
      });
      
      // Show/hide play button and selection status
      const playBtn = document.getElementById('playBtn');
      const selectionStatus = document.getElementById('selectionStatus');
      
      if (canInteract) {
        playBtn.style.display = 'block';
        selectionStatus.style.display = 'block';
      } else {
        playBtn.style.display = 'none';
        selectionStatus.style.display = 'none';
      }
    }

    function updateUIForPhase() {
      const isWaitingForChoice = gameState.waitingForOpponentChoice;
      const phase = gameState.phase || 'PLAY_TWO_CARDS';
      const isMyTurn = playerSeat !== null && playerSeat === gameState.activePlayer;
      
      // Show/hide selection status
      document.getElementById('selectionStatus').style.display = isWaitingForChoice ? 'none' : 'block';
      document.getElementById('choiceStatus').style.display = isWaitingForChoice ? 'block' : 'none';
      
      // Show/hide buttons
      document.getElementById('playBtn').style.display = !isWaitingForChoice ? 'block' : 'none';
      
      // Start appropriate timer only if not already running
      if (isWaitingForChoice && !choiceTimer) {
        startChoiceTimer();
      } else if (!isWaitingForChoice && !turnTimer) {
        startTurnTimer();
      }
      
      // Toggle interaction based on turn
      toggleInteraction(isMyTurn);
      
      if (isWaitingForChoice) {
        // Show the cards that need to be chosen between
        const faceUpDef = gameState.cardDefinitions[gameState.faceUpCardId];
        const faceDownDef = gameState.cardDefinitions[gameState.faceDownCardId];
        
        // Only show choice buttons to the opponent (not the player who submitted the cards)
        const isOpponentTurn = playerSeat !== null && playerSeat !== gameState.activePlayer;
        const isCardSubmitter = playerSeat !== null && playerSeat === gameState.activePlayer;
        
        // Update Face Up Card display
        const faceUpTitle = document.querySelector('#faceUpCardDisplay .modal-card-title');
        const faceUpEffects = document.querySelector('#faceUpCardDisplay .modal-card-effects');
        
        if (faceUpDef) {
          faceUpTitle.textContent = faceUpDef.name;
          faceUpEffects.innerHTML = generateEffectsHTMLWithHighlighting(faceUpDef);
        } else {
          faceUpTitle.textContent = gameState.faceUpCardId;
          faceUpEffects.textContent = 'Unknown card';
        }
        
        // Update Face Down Card display
        const faceDownTitle = document.querySelector('#faceDownCardDisplay .modal-card-title');
        const faceDownEffects = document.querySelector('#faceDownCardDisplay .modal-card-effects');
        if (isCardSubmitter && faceDownDef) {
          // Show hidden card details to the player who submitted the cards
          faceDownTitle.textContent = faceDownDef.name + ' (Hidden)';
          faceDownTitle.className = 'modal-card-title hidden-card';
          faceDownEffects.innerHTML = generateEffectsHTMLWithHighlighting(faceDownDef);
        } else {
          // Keep it hidden for the opponent
          faceDownTitle.textContent = '???';
          faceDownTitle.className = 'modal-card-title';
          faceDownEffects.textContent = 'Hidden card';
        }
        
        // Update fallback content
        document.getElementById('faceUpCard').textContent = 
          gameState.faceUpCardId + (faceUpDef ? (' - ' + faceUpDef.name) : '');
        document.getElementById('faceDownCard').textContent = 
          (isCardSubmitter && faceDownDef) ? (gameState.faceDownCardId + ' - ' + faceDownDef.name + ' (Hidden)') : '???';
        
        if (isOpponentTurn) {
          // Show modal for opponent to choose
          document.getElementById('choiceModal').style.display = 'flex';
          document.getElementById('choiceModal').classList.add('show');
          document.getElementById('choiceModalTitle').textContent = 'Choose Between These Cards';
          // Show choice buttons in modal
          document.querySelectorAll('#choiceModal .choice-btn').forEach(btn => btn.style.display = 'block');
        } else {
          // Show waiting message for active player
          document.getElementById('choiceModal').style.display = 'flex';
          document.getElementById('choiceModal').classList.add('show');
          document.getElementById('choiceModalTitle').textContent = 'Waiting for opponent to choose...';
          // Hide choice buttons in modal
          document.querySelectorAll('#choiceModal .choice-btn').forEach(btn => btn.style.display = 'none');
        }
        
        // Update fallback display
        const choiceButtons = document.querySelectorAll('#chooseFaceUpBtnFallback, #chooseFaceDownBtnFallback');
        choiceButtons.forEach(btn => {
          btn.style.display = isOpponentTurn ? 'block' : 'none';
        });
        
        // Show appropriate message in fallback
        const choiceStatus = document.getElementById('choiceStatus');
        if (isOpponentTurn) {
          choiceStatus.querySelector('h4').textContent = 'Choose between these two cards:';
        } else {
          choiceStatus.querySelector('h4').textContent = 'Waiting for opponent to choose...';
        }
      } else {
        // Hide modal when not waiting for choice
        document.getElementById('choiceModal').classList.remove('show');
        setTimeout(() => {
          document.getElementById('choiceModal').style.display = 'none';
        }, 300); // Wait for animation to complete
        // Only reset selection if we're not in the middle of selecting cards
        // Don't reset if we already have cards selected
        if (!selUp && !selDown) {
          document.getElementById('selUp').textContent = '-';
          document.getElementById('selDown').textContent = '-';
        }
      }
    }

    async function autoTurn() {
      if (!matchId) return;
      const url = playerSeat !== null ? 
        api + '/api/match/' + matchId + '/auto?seat=' + playerSeat :
        api + '/api/match/' + matchId + '/auto';
      await req(url, { method:'POST' });
      log('Auto turn submitted');
      await refresh();
    }

    async function playSelected() {
      if (!matchId || !selUp || !selDown) { log('Pick two cards'); return; }
      clearTimers();
      const body = JSON.stringify({ faceUpId: selUp, faceDownId: selDown });
      const url = playerSeat !== null ? 
        api + '/api/match/' + matchId + '/play?seat=' + playerSeat :
        api + '/api/match/' + matchId + '/play';
      gameState = await req(url, { method:'POST', headers:{'Content-Type':'application/json'}, body });
      log('Played: up=' + selUp + ', down=' + selDown);
      
      // Reset selection after playing
      resetSelection();
      
      await refresh();
    }

    async function chooseFaceUp() {
      if (!matchId) return;
      clearTimers();
      // Hide modal with animation
      document.getElementById('choiceModal').classList.remove('show');
      setTimeout(() => {
        document.getElementById('choiceModal').style.display = 'none';
      }, 300);
      const body = JSON.stringify({ chooseFaceUp: true });
      const url = playerSeat !== null ? 
        api + '/api/match/' + matchId + '/choose?seat=' + playerSeat :
        api + '/api/match/' + matchId + '/choose';
      gameState = await req(url, { method:'POST', headers:{'Content-Type':'application/json'}, body });
      log('Opponent chose Face Up card');
      await refresh();
    }

    async function chooseFaceDown() {
      if (!matchId) return;
      clearTimers();
      // Hide modal with animation
      document.getElementById('choiceModal').classList.remove('show');
      setTimeout(() => {
        document.getElementById('choiceModal').style.display = 'none';
      }, 300);
      const body = JSON.stringify({ chooseFaceUp: false });
      const url = playerSeat !== null ? 
        api + '/api/match/' + matchId + '/choose?seat=' + playerSeat :
        api + '/api/match/' + matchId + '/choose';
      gameState = await req(url, { method:'POST', headers:{'Content-Type':'application/json'}, body });
      log('Opponent chose Face Down card');
      await refresh();
    }

    // Home screen event listeners
    document.getElementById('createMatchBtn').onclick = () => {
      showScreen('createMatchScreen');
    };

    document.getElementById('joinMatchBtn').onclick = () => {
      showScreen('joinMatchScreen');
    };

    document.getElementById('playBotBtn').onclick = () => {
      createMatchWithBot();
    };

    // Create match screen event listeners
    document.getElementById('confirmCreateBtn').onclick = createMatch;
    document.getElementById('backToHomeBtn').onclick = () => {
      showScreen('homeScreen');
    };

    // Join match screen event listeners
    document.getElementById('confirmJoinBtn').onclick = joinMatch;
    document.getElementById('backToHomeBtn2').onclick = () => {
      showScreen('homeScreen');
    };

    // Enter key support for inputs
    document.getElementById('createPlayerName').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') createMatch();
    });

    document.getElementById('joinMatchId').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') joinMatch();
    });

    document.getElementById('joinPlayerName').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') joinMatch();
    });
    const refreshBtn = document.getElementById('refreshBtn');
    if(refreshBtn){
      refreshBtn.onclick = async () => {
        const btn = document.getElementById('refreshBtn');
        const originalText = btn.textContent;
        btn.textContent = 'Refreshing...';
        btn.disabled = true;
        try {
          await refresh();
          btn.textContent = '‚úì Refreshed';
          setTimeout(() => {
            btn.textContent = originalText;
            btn.disabled = false;
          }, 1000);
        } catch (error) {
          btn.textContent = '‚úó Error';
          setTimeout(() => {
            btn.textContent = originalText;
            btn.disabled = false;
          }, 2000);
        }
      };
    }
    document.getElementById('autoBtn').onclick = autoTurn;
    document.getElementById('playBtn').onclick = playSelected;
    document.getElementById('joinBtn').onclick = joinMatch;
    document.getElementById('joinMatchBtn').onclick = joinMatchWithName;
    document.getElementById('readyBtn').onclick = setReady;
    document.getElementById('copyMatchIdBtn').onclick = copyMatchId;

    // Auto-refresh every 2 seconds when there's an active match
    let refreshInterval;
    function startAutoRefresh() {
      if (refreshInterval) clearInterval(refreshInterval);
      refreshInterval = setInterval(async () => {
        if (matchId) {
          try {
            await refresh();
          } catch (e) {
            console.log('Auto-refresh failed:', e);
          }
        }
      }, 2000);
    }

    function stopAutoRefresh() {
      if (refreshInterval) {
        clearInterval(refreshInterval);
        refreshInterval = null;
      }
    }

    function updateCardSelection() {
      // Update visual selection without re-rendering
      const handCards = document.querySelectorAll('.hand .card');
      handCards.forEach(card => {
        const realId = card.getAttribute('data-real-id');
        if (realId === selUp || realId === selDown) {
          card.classList.add('selected');
        } else {
          card.classList.remove('selected');
        }
      });
    }

    function resetSelection() {
      selUp = null;
      selDown = null;
      document.getElementById('selUp').textContent = '-';
      document.getElementById('selDown').textContent = '-';
      updateCardSelection();
    }

    function checkWinConditions() {
      const dots = gameState.sharedDotCounter;
      const winnerDisplay = document.getElementById('winnerDisplay');
      const winnerText = document.getElementById('winnerText');
      
      if (dots <= -5) {
        // Player A wins (dots <= -5) - INVERTED LOGIC
        const playerAName = gameState.playerA || 'Player A';
        winnerDisplay.style.display = 'block';
        
        // Show clearer message based on who actually won
        if (gameState.playerAIsBot && !gameState.playerBBot) {
          // Bot vs Human: Bot won
          winnerText.textContent = 'ü§ñ ' + playerAName + ' Wins! (-5 dots)';
          winnerText.style.color = '#ff6b6b'; // Red for bot victory
        } else {
          // Human vs Human or other cases
          winnerText.textContent = 'üéâ ' + playerAName + ' Wins! (-5 dots)';
          winnerText.style.color = '#4CAF50'; // Green for human victory
        }
        
        log('üéâ ' + playerAName + ' wins with ' + dots + ' dots!');
        disableGameControls();
      } else if (dots >= 5) {
        // Player B wins (dots >= 5) - INVERTED LOGIC
        const playerBName = gameState.playerB || 'Player B';
        winnerDisplay.style.display = 'block';
        
        // Show clearer message based on who actually won
        if (gameState.playerAIsBot && !gameState.playerBBot) {
          // Bot vs Human: Human won
          winnerText.textContent = 'üéâ You Win! (' + playerBName + ' +5 dots)';
          winnerText.style.color = '#4CAF50'; // Green for human victory
        } else {
          // Human vs Human or other cases
          winnerText.textContent = 'üéâ ' + playerBName + ' Wins! (+5 dots)';
          winnerText.style.color = '#4CAF50'; // Green for human victory
        }
        
        log('üéâ ' + playerBName + ' wins with ' + dots + ' dots!');
        disableGameControls();
      } else {
        // No winner yet
        winnerDisplay.style.display = 'none';
      }
    }

    function disableGameControls() {
      // Disable all game controls when someone wins
      const controls = ['playBtn', 'autoBtn', 'chooseFaceUpBtn', 'chooseFaceDownBtn'];
      controls.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
          element.disabled = true;
          element.style.opacity = '0.5';
        }
      });
      
      // Clear timers
      clearTimers();
      
      // Disable card selection
      const handCards = document.querySelectorAll('.hand .card');
      handCards.forEach(card => {
        card.style.pointerEvents = 'none';
        card.style.opacity = '0.5';
      });
    }

    function startTurnTimer() {
      clearTimers();
      turnTimeLeft = 30;
      updateTimerDisplay();
      
      turnTimer = setInterval(() => {
        turnTimeLeft--;
        updateTimerDisplay();
        
        if (turnTimeLeft <= 0) {
          clearTimers();
          log('Turn timer expired! Auto-selecting random cards...');
          autoSelectRandomCards();
        }
      }, 1000);
    }

    function startChoiceTimer() {
      clearTimers();
      choiceTimeLeft = 15;
      updateTimerDisplay();
      
      choiceTimer = setInterval(() => {
        choiceTimeLeft--;
        updateTimerDisplay();
        
        if (choiceTimeLeft <= 0) {
          clearTimers();
          log('Choice timer expired! Auto-selecting random choice...');
          autoSelectRandomChoice();
        }
      }, 1000);
    }
    
    function updateTimerDisplay() {
      const timerElement = document.getElementById('timer');
      const currentTime = turnTimer ? turnTimeLeft : choiceTimeLeft;
      timerElement.textContent = currentTime + 's';
      
      // Update timer styling based on time remaining
      timerElement.className = 'timer-display';
      if (currentTime <= 5) {
        timerElement.classList.add('danger');
      } else if (currentTime <= 10) {
        timerElement.classList.add('warning');
      }
    }

    function clearTimers() {
      if (turnTimer) {
        clearInterval(turnTimer);
        turnTimer = null;
      }
      if (choiceTimer) {
        clearInterval(choiceTimer);
        choiceTimer = null;
      }
    }

    async function autoSelectRandomCards() {
      if (!matchId || !gameState || gameState.waitingForOpponentChoice) return;
      
      const handIds = gameState.activeHandCardIds;
      if (handIds.length < 2) return;
      
      // Select two random cards
      const random1 = handIds[Math.floor(Math.random() * handIds.length)];
      let random2 = handIds[Math.floor(Math.random() * handIds.length)];
      while (random2 === random1 && handIds.length > 1) {
        random2 = handIds[Math.floor(Math.random() * handIds.length)];
      }
      
      selUp = random1;
      selDown = random2;
      document.getElementById('selUp').textContent = selUp;
      document.getElementById('selDown').textContent = selDown;
      
      // Don't call playSelected() here to avoid double reset
      // Instead, make the API call directly
      clearTimers();
      const body = JSON.stringify({ faceUpId: selUp, faceDownId: selDown });
      const url = playerSeat !== null ? 
        api + '/api/match/' + matchId + '/play?seat=' + playerSeat :
        api + '/api/match/' + matchId + '/play';
      gameState = await req(url, { method:'POST', headers:{'Content-Type':'application/json'}, body });
      log('Auto-played: up=' + selUp + ', down=' + selDown);
      
      // Reset selection after playing
      resetSelection();
      
      await refresh();
    }

    async function autoSelectRandomChoice() {
      if (!matchId || !gameState || !gameState.waitingForOpponentChoice) return;
      
      const chooseFaceUp = Math.random() < 0.5;
      if (chooseFaceUp) {
        await chooseFaceUp();
      } else {
        await chooseFaceDown();
      }
    }

    // New Milestone 1 functions
    function showJoinPrompt() {
      document.getElementById('joinPrompt').style.display = 'block';
      document.getElementById('lobbyInfo').style.display = 'none';
      document.getElementById('gameContainer').style.display = 'none';
    }

    function showLobby() {
      showScreen('readyScreen');
      
      // Update lobby info
      document.getElementById('playerAName').textContent = gameState.playerA || '-';
      document.getElementById('playerBName').textContent = gameState.playerB || '-';
      
      const playerAReady = document.getElementById('playerAReady');
      const playerBReady = document.getElementById('playerBReady');
      
      playerAReady.textContent = gameState.readyA ? '(Ready)' : '(Not Ready)';
      playerBReady.textContent = gameState.readyB ? '(Ready)' : '(Not Ready)';
      playerAReady.className = gameState.readyA ? 'ready-status ready' : 'ready-status not-ready';
      playerBReady.className = gameState.readyB ? 'ready-status ready' : 'ready-status not-ready';
      
      // Show ready button if this player isn't ready yet
      const readyBtn = document.getElementById('readyBtn');
      const waitingMsg = document.getElementById('waitingMessage');
      
      if (playerSeat === 0 && !gameState.readyA) {
        readyBtn.style.display = 'block';
        waitingMsg.textContent = 'Click "I\'m Ready!" when you\'re ready to start';
      } else if (playerSeat === 1 && !gameState.readyB) {
        readyBtn.style.display = 'block';
        waitingMsg.textContent = 'Click "I\'m Ready!" when you\'re ready to start';
      } else if (!gameState.readyA || !gameState.readyB) {
        readyBtn.style.display = 'none';
        waitingMsg.textContent = 'Waiting for the other player to be ready...';
      } else {
        readyBtn.style.display = 'none';
        waitingMsg.textContent = 'Both players ready! Starting game...';
      }
    }

    function showGame() {
      showScreen('gameScreen');
    }

    async function joinMatchWithName() {
      const name = document.getElementById('playerName').value.trim();
      if (!name) {
        alert('Please enter your name');
        return;
      }

      try {
        const response = await req(api + '/api/match/' + matchId + '/join', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: name })
        });

        playerSeat = response.seat;
        playerName = name;
        
        // Store in localStorage
        localStorage.setItem('match_' + matchId + '_seat', playerSeat);
        localStorage.setItem('match_' + matchId + '_name', playerName);
        
        log('Joined match as Player ' + (playerSeat === 0 ? 'A' : 'B'));
        
        startAutoRefresh();
        refresh();
      } catch (error) {
        alert('Failed to join match: ' + error.message);
      }
    }

    async function setReady() {
      try {
        await req(api + '/api/match/' + matchId + '/ready?seat=' + playerSeat, {
          method: 'POST'
        });
        log('Ready status sent');
        refresh();
      } catch (error) {
        alert('Failed to set ready status: ' + error.message);
      }
    }

    async function copyMatchId() {
      if (!matchId) return;
      
      try {
        // Copy just the match ID to clipboard
        await navigator.clipboard.writeText(matchId);
        
        // Show temporary feedback
        const btn = document.getElementById('copyMatchIdBtn');
        const originalText = btn.textContent;
        btn.textContent = '‚úÖ Copied!';
        btn.style.backgroundColor = '#28a745';
        
        setTimeout(() => {
          btn.textContent = originalText;
          btn.style.backgroundColor = '';
        }, 1500);
        
        log('Match ID copied to clipboard: ' + matchId);
      } catch (error) {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = matchId;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        
        log('Match ID copied to clipboard (fallback)');
      }
    }

    // Force show home screen on load
    document.addEventListener('DOMContentLoaded', function() {
      console.log('DOM loaded, forcing home screen');
      showScreen('homeScreen');
    });
  </script>
</body>
</html>


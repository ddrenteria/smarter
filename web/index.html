<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Office Duell - New UI v17.1 - Double Turn Phase Timers</title>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <script>
    // Force refresh if cached - v17.1
    console.log('Loading Office Duel v17.1 - Board Symmetry Fix');
    if(window.location.search.indexOf('v=') === -1) {
      window.location.href = window.location.href + '?v=' + Date.now();
    }
  </script>
  <style>
    body { 
      font-family: sans-serif; 
      margin: 0; 
      padding: 20px; 
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      min-height: 100vh;
    }
    
    h1 {
      text-align: center;
      color: #333;
      margin-bottom: 30px;
      font-size: 2.5em;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    
    /* Screen Management Styles */
    .screen {
      min-height: 70vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    
    .screen-content {
      background: white;
      padding: 40px;
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
      text-align: center;
      max-width: 500px;
      width: 100%;
    }
    
    .screen-content h2 {
      color: #333;
      margin-bottom: 20px;
      font-size: 2em;
    }
    
    .screen-content p {
      color: #666;
      margin-bottom: 30px;
      font-size: 1.1em;
    }
    
    /* Home Screen Styles */
    .home-buttons {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .home-btn {
      background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%);
      color: white;
      border: none;
      padding: 20px 30px;
      border-radius: 12px;
      font-size: 1.2em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 16px rgba(33, 150, 243, 0.3);
    }
    
    .home-btn:hover {
      background: linear-gradient(135deg, #1976d2 0%, #1565c0 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(33, 150, 243, 0.4);
    }
    
    .home-btn:active {
      transform: translateY(0);
    }
    
    /* Input Group Styles */
    .input-group {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin: 20px 0;
    }
    
    .input-group input {
      padding: 15px;
      border: 2px solid #ddd;
      border-radius: 8px;
      font-size: 1em;
      transition: border-color 0.3s ease;
    }
    
    .input-group input:focus {
      outline: none;
      border-color: #2196f3;
      box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
    }
    
    .action-btn {
      background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
      color: white;
      border: none;
      padding: 15px 30px;
      border-radius: 8px;
      font-size: 1.1em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 16px rgba(76, 175, 80, 0.3);
    }
    
    .action-btn:hover {
      background: linear-gradient(135deg, #45a049 0%, #3d8b40 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
    }
    
    .secondary-btn {
      background: transparent;
      color: #666;
      border: 2px solid #ddd;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 1em;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-top: 20px;
    }
    
    .secondary-btn:hover {
      background: #f5f5f5;
      border-color: #bbb;
    }

    /* Game Styles */
    .game-container { 
      display: grid; 
      grid-template-columns: auto 1fr; 
      grid-template-rows: auto 1fr auto; 
      gap: 20px; 
      min-height: 80vh;
      width: 100%;
    }
    .game-header { grid-column: 2; grid-row: 1; }
    .game-main { grid-column: 2; grid-row: 2; }
    .game-footer { grid-column: 2; grid-row: 3; }
    .game-sidebar { grid-column: 1; grid-row: 1 / 4; }
    .player-section { border: 2px solid #ddd; padding: 20px; border-radius: 12px; background: white; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    
    .card-selection-panel {
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      border: 2px solid #dee2e6;
      border-radius: 15px;
      padding: 20px;
      margin: 10px 0;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      position: relative;
      z-index: 10;
      min-height: 300px;
    }
    
    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding-bottom: 15px;
      border-bottom: 2px solid #dee2e6;
    }
    
    .panel-header h3 {
      margin: 0;
      color: #333;
      font-size: 1.5em;
      font-weight: bold;
    }
    
    .phase-info {
      background: #007bff;
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      font-weight: bold;
      font-size: 0.9em;
    }
    
    .legend {
      display: flex;
      justify-content: center;
      gap: 30px;
      margin-bottom: 20px;
      font-size: 0.9em;
      color: #666;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .legend-color {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      display: inline-block;
    }
    
    .legend-color.blue {
      background: #007bff;
    }
    
    .legend-color.orange {
      background: #ff9800;
    }
    
    .card-choice-container {
      display: flex;
      gap: 20px;
      justify-content: center;
      margin-bottom: 20px;
    }
    
    .card-choice {
      background: white;
      border: 2px solid #28a745;
      border-radius: 10px;
      padding: 20px;
      text-align: center;
      min-width: 250px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .card-choice h4 {
      margin: 0 0 15px 0;
      color: #333;
      font-size: 1.2em;
    }
    
    .card-preview {
      min-height: 200px;
      border: 2px dashed #dee2e6;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
      background: #f8f9fa;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .card-preview.has-card {
      border: 2px solid #007bff;
      background: white;
    }
    
    .placeholder {
      color: #999;
      font-style: italic;
    }
    
    .choose-btn {
      background: #28a745;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .choose-btn:hover:not(:disabled) {
      background: #218838;
    }
    
    .choose-btn:disabled {
      background: #6c757d;
      cursor: not-allowed;
    }
    
    .play-controls {
      background: white;
      border-radius: 10px;
      padding: 15px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      text-align: center;
    }
    
    .selected-cards {
      display: flex;
      gap: 20px;
      justify-content: center;
      margin-bottom: 15px;
    }
    
    .selected-card {
      background: white;
      border: 2px solid #007bff;
      border-radius: 10px;
      padding: 15px;
      text-align: center;
      min-width: 200px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .selected-card h4 {
      margin: 0 0 10px 0;
      color: #007bff;
      font-size: 1em;
    }
    
    .card-preview {
      min-height: 100px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f8f9fa;
      border-radius: 8px;
      border: 1px dashed #6c757d;
      color: #6c757d;
      font-style: italic;
    }
    
    .card-preview.has-card {
      background: white;
      border: 2px solid #28a745;
      color: #333;
      font-style: normal;
    }
    
    .play-controls {
      text-align: center;
    }
    
    .play-controls .status {
      margin-bottom: 10px;
      font-weight: bold;
      color: #495057;
    }
    
    .preview-card {
      text-align: center;
    }
    
    .preview-name {
      font-weight: bold;
      font-size: 1.1em;
      color: #333;
      margin-bottom: 5px;
    }
    
    .preview-tags {
      font-size: 0.9em;
      color: #666;
      font-style: italic;
    }
    
    .central-card {
      background: white;
      border: 2px solid #dee2e6;
      border-radius: 10px;
      padding: 15px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      transition: all 0.3s ease;
      cursor: pointer;
    }
    
    .central-card:hover {
      border-color: #007bff;
      box-shadow: 0 4px 8px rgba(0,123,255,0.2);
    }
    
    .central-card.selected {
      border-color: #28a745;
      background: #f8fff9;
      box-shadow: 0 4px 8px rgba(40,167,69,0.3);
    }
    
    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .card-header h4 {
      margin: 0;
      color: #333;
      font-size: 1.1em;
    }
    
    .card-count {
      background: #007bff;
      color: white;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 0.8em;
      font-weight: bold;
    }
    
    .card-tags {
      color: #666;
      font-size: 0.9em;
      font-style: italic;
      margin-bottom: 15px;
    }
    
    .card-tiers {
      margin-bottom: 15px;
    }
    
    .tier {
      margin-bottom: 10px;
      padding: 8px;
      background: #f8f9fa;
      border-radius: 6px;
      border-left: 3px solid #007bff;
    }
    
    .tier-header {
      font-weight: bold;
      color: #007bff;
      font-size: 0.9em;
      margin-bottom: 5px;
    }
    
    .tier-actions {
      font-size: 0.8em;
      color: #555;
    }
    
    .action {
      margin-bottom: 3px;
      padding-left: 10px;
    }
    
    .card-actions {
      display: flex;
      gap: 8px;
    }
    
    .card-actions button {
      flex: 1;
      padding: 8px 12px;
      border: none;
      border-radius: 6px;
      font-size: 0.8em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .select-face-up {
      background: #28a745;
      color: white;
    }
    
    .select-face-up:hover {
      background: #218838;
    }
    
    .select-face-down {
      background: #ffc107;
      color: #212529;
    }
    
    .select-face-down:hover {
      background: #e0a800;
    }
    
    /* Drag and Drop Styles */
    .hand-card {
      cursor: grab;
      transition: all 0.3s ease;
    }
    
    .hand-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    
    .hand-card.dragging {
      opacity: 0.5;
      transform: rotate(5deg);
    }
    
    .card-preview.drag-over {
      border-color: #007bff;
      background: #e3f2fd;
      border-style: solid;
    }
    
    .card-preview.drag-over .placeholder {
      color: #007bff;
      font-weight: bold;
    }
    
    .card-preview.has-card .placeholder {
      display: none;
    }
    
    .card-preview.has-card {
      border-style: solid;
    }
    
    .card-preview-content {
      width: 100%;
      text-align: left;
    }
    
    .card-preview-name {
      font-weight: bold;
      color: #333;
      margin-bottom: 10px;
      font-size: 1.1em;
    }
    
    .card-preview-tiers {
      font-size: 0.9em;
    }
    
    .tier-preview {
      margin-bottom: 8px;
      padding: 5px;
      background: #f8f9fa;
      border-radius: 4px;
      border-left: 3px solid #007bff;
    }
    
    .tier-preview.self-effect {
      border-left-color: #007bff;
    }
    
    .tier-preview.opponent-effect {
      border-left-color: #ff9800;
    }
    
    .tier-preview-header {
      font-weight: bold;
      color: #007bff;
      font-size: 0.8em;
      margin-bottom: 3px;
    }
    
    .tier-preview-action {
      color: #555;
      font-size: 0.8em;
    }
    
    .mystery-card {
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      border: 2px dashed #6c757d;
    }
    
    .mystery-card .card-preview-name {
      color: #6c757d;
      font-style: italic;
    }
    
    .mystery-card .tier-preview {
      background: #f8f9fa;
      border-left-color: #6c757d;
    }
    
    .mystery-card .tier-preview-header {
      color: #6c757d;
    }
    
    .mystery-card .tier-preview-action {
      color: #6c757d;
      font-style: italic;
    }
    .player-section.active { background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); border-color: #2196f3; box-shadow: 0 4px 16px rgba(33, 150, 243, 0.3); }
    .player-section h3 { margin: 0 0 15px 0; font-size: 1.2em; color: #333; }
    .player-area-label { 
      display: inline-block; 
      background: #2196f3; 
      color: white; 
      padding: 4px 12px; 
      border-radius: 20px; 
      font-size: 0.8em; 
      margin-bottom: 10px; 
    }
    .player-area-label.opponent { background: #ff5722; }
    .hand { display: flex; gap: 8px; margin: 10px 0; flex-wrap: wrap; }
    .card {
      width: 140px;
      min-height: 200px;
      padding: 10px;
      border: 2px solid #888;
      border-radius: 8px;
      cursor: pointer;
      background: white;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      justify-content: flex-start;
      text-align: center;
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .card:hover { 
      background: #f0f8ff; 
      border-color: #2196f3; 
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    .card.selected { 
      background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); 
      border-color: #2196f3; 
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
    }
    .card-title { font-weight: bold; margin-bottom: 6px; }
    .card-effects { list-style: none; padding: 0; margin: 0; font-size: 12px; text-align: left; }
    .card-effects li { color: #000; }
    .card-effects li.active { color: #28a745; font-weight: bold; }
    
    /* Effect highlighting for choose modal */
    .card-effects li.effect-mine { 
      color: #3da7ff !important; 
      font-weight: bold; 
      background: rgba(61, 167, 255, 0.1);
      padding: 2px 6px;
      border-radius: 4px;
      margin: 1px 0;
    }
    .card-effects li.effect-opponent { 
      color: #ff9d46 !important; 
      font-weight: bold; 
      background: rgba(255, 157, 70, 0.1);
      padding: 2px 6px;
      border-radius: 4px;
      margin: 1px 0;
    }
    
    /* Tier highlighting for central panel */
    .tier-preview.effect-mine {
      border: 2px solid #3da7ff !important;
      background: rgba(61, 167, 255, 0.1) !important;
      box-shadow: 0 0 8px rgba(61, 167, 255, 0.3);
    }
    .tier-preview.effect-opponent {
      border: 2px solid #ff9d46 !important;
      background: rgba(255, 157, 70, 0.1) !important;
      box-shadow: 0 0 8px rgba(255, 157, 70, 0.3);
    }
    .tableau { display: flex; gap: 4px; margin: 10px 0; flex-wrap: wrap; }
    .tableau-card {
      width: 140px;
      min-height: 200px;
      padding: 8px;
      border: 2px solid #ccc;
      border-radius: 6px;
      background: #f9f9f9;
      font-size: 12px;
      position: relative;
      display: flex;
      flex-direction: column;
      text-align: center;
    }
    .stacked-card { position: relative; }
    .card-count-badge { 
      position: absolute; 
      top: -8px; 
      right: -8px; 
      background: #ff4444; 
      color: white; 
      border-radius: 50%; 
      width: 20px; 
      height: 20px; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      font-size: 10px; 
      font-weight: bold; 
      border: 2px solid white;
    }
    .card-tooltip { position: relative; }
    .card-tooltip:hover .tooltip-content { display: block; }
    .tooltip-content { 
      display: none; position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); 
      background: #333; color: white; padding: 8px; border-radius: 4px; white-space: nowrap; 
      z-index: 1000; font-size: 12px; max-width: 300px; white-space: normal;
    }
    .log { white-space: pre-wrap; font-family: monospace; max-height: 200px; overflow: auto; border: 1px solid #eee; padding: 8px; background: #f9f9f9; }
    .status { font-weight: bold; margin: 10px 0; }
    .choice-cards {
      display: flex;
      gap: 20px;
      margin: 10px 0;
    }
    .choice-card {
      border: 2px solid #28a745;
      border-radius: 8px;
      padding: 15px;
      background: #f8f9fa;
      text-align: center;
      flex: 1;
    }
    .choice-card button {
      margin-top: 10px;
      padding: 8px 16px;
      background: #28a745;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .choice-card button:hover {
      background: #218838;
    }
    .shared-counter {
      text-align: center;
      margin: 20px 0;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 12px;
      color: white;
      min-width: 200px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    .dot-display {
      margin: 15px 0;
    }
    .dot-value {
      font-size: 48px;
      font-weight: bold;
      margin: 10px 0;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    .dot-labels {
      display: flex;
      justify-content: space-between;
      font-size: 14px;
      margin-top: 10px;
    }
    .player-label {
      background: rgba(255,255,255,0.2);
      padding: 5px 10px;
      border-radius: 15px;
    }
    .neutral-label {
      background: rgba(255,255,255,0.3);
      padding: 5px 10px;
      border-radius: 15px;
      font-weight: bold;
    }
    .winner-display {
      margin-top: 15px;
      padding: 15px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      border: 2px solid #fff;
    }
    .winner-display h2 {
      margin: 0;
      color: #fff;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }
    
    .winner-display .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      text-decoration: none;
      display: inline-block;
      margin: 0 5px;
    }

    .winner-display .btn-primary {
      background: linear-gradient(45deg, #4CAF50, #45a049);
      color: white;
    }

    .winner-display .btn-primary:hover {
      background: linear-gradient(45deg, #45a049, #3d8b40);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
    }

    .winner-display .btn-secondary {
      background: linear-gradient(45deg, #6c757d, #5a6268);
      color: white;
    }

    .winner-display .btn-secondary:hover {
      background: linear-gradient(45deg, #5a6268, #495057);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(108, 117, 125, 0.4);
    }
    /* Enhanced Timer Styling */
    .timer-display {
      display: inline-block;
      padding: 8px 16px;
      border-radius: 20px;
      font-weight: bold;
      font-size: 1.1em;
      transition: all 0.3s ease;
      background: #4caf50;
      color: white;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    .timer-display.warning { background: #ff9800; }
    .timer-display.danger { background: #f44336; animation: pulse 1s infinite; }
    @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
    
    /* Enhanced Choice Modal - Bottom Sheet Style */
    .choice-modal {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 45vh;
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      border-top: 4px solid #2196f3;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transform: translateY(100%);
      transition: transform 0.3s ease-in-out;
      box-shadow: 0 -8px 32px rgba(0,0,0,0.3);
    }
    .choice-modal.show {
      transform: translateY(0);
    }
    .choice-modal-content {
      background: transparent;
      padding: 20px;
      width: 100%;
      max-width: 800px;
    }
    
    /* Desktop sidebar variant */
    @media (min-width: 900px) {
      .choice-modal {
        position: fixed;
        top: 0;
        right: 0;
        width: 35%;
        height: 100vh;
        left: auto;
        bottom: auto;
        transform: translateX(100%);
        border-top: none;
        border-left: 4px solid #2196f3;
      }
      .choice-modal.show {
        transform: translateX(0);
      }
    }
    
    .choice-btn {
      background: #2196f3;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 1.1em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 2px 8px rgba(33, 150, 243, 0.3);
    }
    
    .choice-btn:hover {
      background: #1976d2;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
    }
    
    .choice-btn:active {
      transform: translateY(0);
    }
    
    /* Layout specific styles */
    .game-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 0;
    }
    
    .timer-display-container {
      margin-top: 20px;
      padding: 15px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      text-align: center;
    }
    
    .timer-display-container .status {
      margin-bottom: 10px;
      font-weight: bold;
    }
    
    .effect-feedback-container {
      margin-top: 20px;
      padding: 15px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      max-height: 200px;
      overflow-y: auto;
    }
    
    .effect-feedback-container h4 {
      margin: 0 0 10px 0;
      color: #333;
      font-size: 0.9em;
    }
    
    .effect-feedback-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .effect-item {
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 8px;
      border-left: 4px solid #2196f3;
      font-size: 0.8em;
      animation: slideIn 0.3s ease-out;
    }
    
    .effect-item.heal {
      border-left-color: #4caf50;
    }
    
    .effect-item.damage {
      border-left-color: #f44336;
    }
    
    .effect-item.dot-change {
      border-left-color: #ff9800;
    }
    
    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(-20px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }
    
    .auto-turn-btn {
      background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 0.9em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 2px 8px rgba(255, 152, 0, 0.3);
    }
    
    .auto-turn-btn:hover {
      background: linear-gradient(135deg, #f57c00 0%, #ef6c00 100%);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(255, 152, 0, 0.4);
    }
    
    .enemy-area {
      margin-bottom: 20px;
    }
    
    .player-area {
      margin-top: 20px;
    }
    
    /* Play Cards Section */
    .play-cards-section {
      margin-top: 20px;
      padding: 15px;
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      border-radius: 8px;
      border: 2px solid #dee2e6;
    }
    
    .play-selected-btn {
      background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 1.1em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
      width: 100%;
      margin-top: 10px;
    }
    
    .play-selected-btn:hover {
      background: linear-gradient(135deg, #218838 0%, #1aa179 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(40, 167, 69, 0.4);
    }
    
    .play-selected-btn:active {
      transform: translateY(0);
    }
    
    .play-selected-btn:disabled {
      background: #6c757d;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    /* Modal Card Display */
    .modal-card-display {
      background: white;
      border: 2px solid #ddd;
      border-radius: 8px;
      padding: 15px;
      margin: 10px 0;
      min-height: 120px;
      display: flex;
      flex-direction: column;
    }
    
    .modal-card-title {
      font-weight: bold;
      font-size: 1.1em;
      color: #333;
      margin-bottom: 10px;
      text-align: center;
    }
    
    .modal-card-effects {
      font-size: 0.9em;
      color: #666;
      line-height: 1.4;
    }
    
    .modal-card-effects ul {
      margin: 0;
      padding-left: 20px;
      list-style-type: disc;
    }
    
    .modal-card-effects li {
      margin: 4px 0;
    }
    
    .modal-card-title.hidden-card {
      color: #666 !important;
      font-style: italic !important;
      position: relative;
    }
    
    .modal-card-title.hidden-card::after {
      content: " (Hidden)";
      font-size: 0.8em;
      color: #999;
    }

    /* Ready Screen Styles */
    .match-info {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 8px;
      margin: 20px 0;
    }
    
    .copy-btn {
      background: #ff9800;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 0.9em;
      cursor: pointer;
      margin-left: 10px;
      transition: all 0.3s ease;
    }
    
    .copy-btn:hover {
      background: #f57c00;
    }
    
    .players-status {
      margin: 30px 0;
    }
    
    .player-status {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 15px;
      margin: 10px 0;
      background: #f8f9fa;
      border-radius: 8px;
      border-left: 4px solid #2196f3;
    }
    
    .player-label {
      font-weight: bold;
      color: #333;
    }
    
    .ready-status {
      font-weight: bold;
    }
    
    .ready-status.ready {
      color: #4caf50;
    }
    
    .ready-status.not-ready {
      color: #f44336;
    }
    
    .ready-btn {
      background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
      color: white;
      border: none;
      padding: 20px 40px;
      border-radius: 12px;
      font-size: 1.3em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 16px rgba(76, 175, 80, 0.3);
      margin: 20px 0;
    }
    
    .ready-btn:hover {
      background: linear-gradient(135deg, #45a049 0%, #3d8b40 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
    }
    
    .waiting-message {
      color: #666;
      font-style: italic;
      margin-top: 20px;
    }
  </style>
</head>
<body>
   <h1>🎮 Office Duell - New 4-Screen UI v17.0 - Double Turn Phase Timers</h1>
  
  <!-- Screen 1: Home Screen -->
  <div id="homeScreen" class="screen" style="display: block;">
    <div class="screen-content">
      <h2>🎮 Welcome to Office Duel!</h2>
      <p>Choose how you want to play:</p>
      <div class="home-buttons">
        <button id="createMatchBtn" class="home-btn">🏢 Create Match</button>
        <button id="joinMatchBtn" class="home-btn">🔗 Join Match</button>
        <button id="playBotBtn" class="home-btn">🤖 Play vs Bot</button>
    </div>
    </div>
  </div>

  <!-- Screen 2: Create Match Screen -->
  <div id="createMatchScreen" class="screen" style="display: none;">
    <div class="screen-content">
      <h2>Create New Match</h2>
      <p>Enter your name to create a match:</p>
      <div class="input-group">
        <input id="createPlayerName" type="text" placeholder="Your name" />
        <button id="confirmCreateBtn" class="action-btn">Create Match</button>
      </div>
      <button id="backToHomeBtn" class="secondary-btn">← Back to Home</button>
    </div>
  </div>
  
  <!-- Screen 2: Join Match Screen -->
  <div id="joinMatchScreen" class="screen" style="display: none;">
    <div class="screen-content">
      <h2>Join Existing Match</h2>
      <p>Enter the match ID and your name:</p>
      <div class="input-group">
        <input id="joinMatchId" type="text" placeholder="Match ID" />
        <input id="joinPlayerName" type="text" placeholder="Your name" />
        <button id="confirmJoinBtn" class="action-btn">Join Match</button>
      </div>
      <button id="backToHomeBtn2" class="secondary-btn">← Back to Home</button>
    </div>
  </div>

  <!-- Screen 3: Ready Screen -->
  <div id="readyScreen" class="screen" style="display: none;">
    <div class="screen-content">
      <h2>Waiting Room</h2>
      <div class="match-info">
        <p><strong>Match IDD:</strong> <span id="displayMatchId">-</span></p>
        <button id="copyMatchIdBtn" class="copy-btn">📋 Copy Match ID</button>
      </div>
      <div class="players-status">
        <div class="player-status">
          <span class="player-label">Player A:</span>
          <span id="playerAName">-</span>
          <span id="playerAReady" class="ready-status">(Not Ready)</span>
        </div>
        <div class="player-status">
          <span class="player-label">Player B:</span>
          <span id="playerBName">-</span>
          <span id="playerBReady" class="ready-status">(Not Ready)</span>
        </div>
      </div>
      <button id="readyBtn" class="ready-btn" style="display: none;">I'm Ready!</button>
      <div id="waitingMessage" class="waiting-message">Waiting for both players to be ready...</div>
    </div>
  </div>

  <!-- Screen 4: Game Screen -->
  <div id="gameScreen" class="screen" style="display: none;">
    <div class="game-container" id="gameContainer">
    
    <!-- Left Sidebar - Shared Counter -->
    <div class="game-sidebar">
      <div class="shared-counter">
        <h3>Shared Dot Counter</h3>
        <div class="dot-display">
          <div class="dot-value" id="dotCounter">0</div>
          <div class="dot-labels">
            <span class="player-label">B Wins (-5)</span>
            <span class="neutral-label">Neutral (0)</span>
            <span class="player-label">A Wins (+5)</span>
          </div>
        </div>
        <!-- Timer moved below dot counter -->
        <div class="timer-display-container">
          <div class="status">Timer: <span id="timer" class="timer-display">-</span></div>
          <button id="autoBtn" class="auto-turn-btn">Auto Turn</button>
        </div>
        <!-- Effect Feedback Display -->
        <div class="effect-feedback-container">
          <h4>Efectos Recientes</h4>
          <div id="effectFeedback" class="effect-feedback-list">
            <!-- Effects will be displayed here -->
          </div>
        </div>
        
        <div id="winnerDisplay" class="winner-display" style="display: none;">
          <h2 id="winnerText">Game Over!</h2>
          <div style="margin-top: 15px;">
            <button id="rematchBtn" class="btn btn-primary" style="margin-right: 10px;">🔄 Rematch</button>
            <button id="gameBackToHomeBtn" class="btn btn-secondary">🏠 Back to Home</button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Game Header -->
    <div class="game-header">
      <div class="status">Active Player: <span id="active">-</span></div>
      <div class="status">Phase: <span id="phase">-</span></div>
    </div>
    
    <!-- Main Game Area -->
    <div class="game-main">
      <!-- Enemy Area (Top) -->
      <div class="player-section enemy-area" id="playerA">
        <div class="player-area-label opponent">Opponent Area</div>
        <h3 id="playerATitle">Player A</h3>
        <div class="status">Hand: <span id="handSizeA">-</span> cards</div>
        <div class="status">Tableau: <span id="tableauSizeA">-</span> cards</div>
        <h4>Hand:</h4>
        <div class="hand" id="handA"></div>
        <h4>Tableau:</h4>
        <div class="tableau" id="tableauA"></div>
      </div>

      <!-- Your Area (Bottom) -->
      <div class="player-section player-area" id="playerB">
        <div class="player-area-label">Your Area</div>
        <h3 id="playerBTitle">Player B</h3>
        <div class="status">Hand: <span id="handSizeB">-</span> cards</div>
        <div class="status">Tableau: <span id="tableauSizeB">-</span> cards</div>
        <h4>Hand:</h4>
        <div class="hand" id="handB"></div>
        <h4>Tableau:</h4>
        <div class="tableau" id="tableauB"></div>
      </div>
    </div>
    
    <!-- Card Selection Panel (Fixed Position Between Areas) -->
    <div class="card-selection-panel" id="cardSelectionPanel">
      <div class="panel-header">
        <h3>Choose Between These Cards</h3>
        <div class="phase-info">Phase: <span id="currentPhase">PLAY_TWO_CARDS</span></div>
      </div>
      
      <div class="legend">
        <span class="legend-item">
          <span class="legend-color blue"></span>
          Blue = Effect for you
        </span>
        <span class="legend-item">
          <span class="legend-color orange"></span>
          Orange = Effect for opponent
        </span>
      </div>
      
      <div class="card-choice-container">
        <div class="card-choice" id="faceUpCard">
          <h4>Face Up Card</h4>
          <div class="card-preview" id="faceUpPreview">
            <div class="placeholder">Drag a card here</div>
          </div>
          <button class="choose-btn" id="chooseFaceUp" disabled>Choose This One</button>
        </div>
        
        <div class="card-choice" id="faceDownCard">
          <h4>Face Down Card</h4>
          <div class="card-preview" id="faceDownPreview">
            <div class="placeholder">Drag a card here</div>
          </div>
          <button class="choose-btn" id="chooseFaceDown" disabled>Choose This One</button>
        </div>
      </div>
      
      <div class="play-controls">
        <div class="status" id="selectionStatus">Selected: Face Up=<span id="selUp">-</span>, Face Down=<span id="selDown">-</span></div>
        <button id="playBtn" class="play-selected-btn" style="display: none;">🎯 Play Selected Cards</button>
      </div>
    </div>
    </div>
    
    <!-- Game Footer -->
    <div class="game-footer">
        <h3>Game Log</h3>
        <div id="gameLog" class="log"></div>
      </div>
    </div>
  </div>


  <script>
     // Auto-detect API URL based on environment
     const api = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' 
       ? '' // Local development - use same host
       : 'https://smarter-co00.onrender.com'; // Production - use remote API
     
     console.log('🌐 Environment detected:', window.location.hostname);
     console.log('🔗 Using API:', api || 'same host (' + window.location.origin + ')');
    let matchId = '';
    let playerSeat = null;
    let playerName = null;
    let gameState = null;
    let selUp = null, selDown = null;
    let turnTimer = null;
    let choiceTimer = null;
    let turnTimeLeft = 60; // Doubled from 30 to 60 seconds for card selection
    let choiceTimeLeft = 30; // Doubled from 15 to 30 seconds for choice selection

    // Screen management functions
    function showScreen(screenId) {
      const screens = ['homeScreen', 'createMatchScreen', 'joinMatchScreen', 'readyScreen', 'gameScreen'];
      screens.forEach(id => {
        document.getElementById(id).style.display = 'none';
      });
      document.getElementById(screenId).style.display = 'block';
      
      // Special handling for game screen
      if (screenId === 'gameScreen') {
        document.getElementById('gameContainer').style.display = 'grid';
      } else {
        document.getElementById('gameContainer').style.display = 'none';
      }
      console.log('Showing screen:', screenId);
    }

    // Game functions
    async function req(url, opts={}) {
      const r = await fetch(url, opts);
      if (!r.ok) throw new Error(await r.text());
      return r.json();
    }

    function log(msg){
      const el = document.getElementById('gameLog');
      if (el) {
        el.textContent += msg + "\n";
        el.scrollTop = el.scrollHeight;
      }
    }
    
    // Read matchId from URL and check for existing seat
    (function initMatchFromUrl(){
      const url = new URL(window.location.href);
      const pMatch = url.searchParams.get('match');
      if(pMatch){
        matchId = pMatch;
      } else {
        const parts = window.location.pathname.split('/');
        if(parts.length>=3 && parts[1]==='app' && parts[2].length>0){
          matchId = parts[2];
        }
      }
      
      // Check localStorage for existing seat
      const storedSeat = localStorage.getItem('match_' + matchId + '_seat');
      const storedName = localStorage.getItem('match_' + matchId + '_name');
      
      if(storedSeat !== null && storedName !== null){
        playerSeat = parseInt(storedSeat);
        playerName = storedName;
      }
      
      if(matchId){
        document.getElementById('displayMatchId').textContent = matchId;
        if(playerSeat !== null){
          startAutoRefresh();
          refresh();
        } else {
          showScreen('joinMatchScreen');
        }
      } else {
        showScreen('homeScreen');
      }
    })();

    // Event listeners
    document.getElementById('createMatchBtn').onclick = () => {
      showScreen('createMatchScreen');
    };

    document.getElementById('joinMatchBtn').onclick = () => {
      showScreen('joinMatchScreen');
    };

    document.getElementById('playBotBtn').onclick = () => {
      createMatchWithBot();
    };

    document.getElementById('confirmCreateBtn').onclick = createMatch;

    document.getElementById('confirmJoinBtn').onclick = joinMatch;

    async function createMatch() {
      const name = document.getElementById('createPlayerName').value.trim();
      if (!name) {
        alert('Please enter your name');
        return;
      }

      try {
        const data = await req(api + '/api/match', { method:'POST', headers:{'Content-Type':'application/json'}, body:'{}' });
        matchId = data.id;
        playerName = name;
        
        // Join the match we just created
        const response = await req(api + '/api/match/' + matchId + '/join', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: name })
        });

        playerSeat = response.seat;
        
        // Store in localStorage
        localStorage.setItem('match_' + matchId + '_seat', playerSeat);
        localStorage.setItem('match_' + matchId + '_name', playerName);
        localStorage.setItem('playerName', playerName);
        localStorage.setItem('wasVsBot', 'false'); // Player vs Player
        
        document.getElementById('displayMatchId').textContent = matchId;
        showScreen('readyScreen');
        startAutoRefresh();
        refresh();
        
        log('Created match and joined as Player ' + (playerSeat === 0 ? 'A' : 'B'));
      } catch (error) {
        alert('Failed to create match: ' + error.message);
      }
    }

    async function createMatchWithBot() {
      const name = prompt('Enter your name for the bot match:');
      if (!name) return;
      
      try {
        const data = await req(api + '/api/match/bot', { method:'POST', headers:{'Content-Type':'application/json'}, body:'{}' });
        matchId = data.id;
        
        // Join as Player B (human player)
        const response = await req(api + '/api/match/' + matchId + '/join', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: name })
        });

        playerSeat = response.seat;
        playerName = name;
        
        // Store in localStorage
        localStorage.setItem('match_' + matchId + '_seat', playerSeat);
        localStorage.setItem('match_' + matchId + '_name', playerName);
        localStorage.setItem('playerName', playerName);
        localStorage.setItem('wasVsBot', 'true');
        
        document.getElementById('displayMatchId').textContent = matchId;
        showScreen('readyScreen');
        startAutoRefresh();
        refresh();
        
        log('Created bot match and joined as Player ' + (playerSeat === 0 ? 'A' : 'B'));
      } catch (error) {
        alert('Failed to create bot match: ' + error.message);
      }
    }

    async function joinMatch(){
      const id = document.getElementById('joinMatchId').value.trim();
      const name = document.getElementById('joinPlayerName').value.trim();

      if(!id){ alert('Please enter a match id'); return; }
      if(!name){ alert('Please enter your name'); return; }

      matchId = id;
      await joinMatchDirect(id, name);
    }

    async function joinMatchDirect(id, name){
      try {
        const response = await req(api + '/api/match/' + id + '/join', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name })
        });

        playerSeat = response.seat;
        playerName = name;
        
        // Persist for reloads
        localStorage.setItem('match_' + id + '_seat', playerSeat);
        localStorage.setItem('match_' + id + '_name', playerName);
        localStorage.setItem('playerName', playerName);
        localStorage.setItem('wasVsBot', 'false'); // Player vs Player
        
        document.getElementById('displayMatchId').textContent = matchId;
        showScreen('readyScreen');
        startAutoRefresh();
        refresh();
        
        log('Joined match as Player ' + (playerSeat === 0 ? 'A' : 'B'));
      } catch (error) {
        alert('Failed to join match: ' + error.message);
      }
    }

    document.getElementById('backToHomeBtn').onclick = () => {
      showScreen('homeScreen');
    };

    document.getElementById('backToHomeBtn2').onclick = () => {
      showScreen('homeScreen');
    };

    // Enter key support
    document.getElementById('createPlayerName').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') document.getElementById('confirmCreateBtn').click();
    });

    document.getElementById('joinMatchId').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') document.getElementById('confirmJoinBtn').click();
    });

    document.getElementById('joinPlayerName').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') document.getElementById('confirmJoinBtn').click();
    });

    // Add all the game functions from the backup file
    // This includes refresh, render functions, game logic, etc.
    // For brevity, I'll add the essential functions

    async function refresh() {
      if (!matchId) return;
      
      const url = playerSeat !== null ? 
        api + '/api/match/' + matchId + '?seat=' + playerSeat :
        api + '/api/match/' + matchId;
      
      gameState = await req(url);
      
      // Handle lobby state
      if (!gameState.started) {
        showLobby();
        return;
      }
      
      // Game started - show game UI
      showGame();
      
      // Update player info based on perspective
      if (playerSeat === 0) {
        // Player A perspective - A sees themselves at bottom, opponent at top
        // After DOM reordering: playerA will be at bottom, playerB at top
        document.getElementById('handSizeA').textContent = gameState.handSizeA; // A's hand (will be at bottom)
        document.getElementById('handSizeB').textContent = gameState.handSizeB; // B's hand (will be at top)
        document.getElementById('tableauSizeA').textContent = gameState.tableauSizeA; // A's tableau (will be at bottom)
        document.getElementById('tableauSizeB').textContent = gameState.tableauSizeB; // B's tableau (will be at top)
      } else if (playerSeat === 1) {
        // Player B perspective - B sees themselves at bottom, opponent at top
        // Original order: playerA at top, playerB at bottom
        document.getElementById('handSizeA').textContent = gameState.handSizeA; // A's hand (at top)
        document.getElementById('handSizeB').textContent = gameState.handSizeB; // B's hand (at bottom)
        document.getElementById('tableauSizeA').textContent = gameState.tableauSizeA; // A's tableau (at top)
        document.getElementById('tableauSizeB').textContent = gameState.tableauSizeB; // B's tableau (at bottom)
      }
      document.getElementById('active').textContent = gameState.activePlayer === 0 ? 'A' : 'B';
      document.getElementById('phase').textContent = gameState.phase || 'PLAY_TWO_CARDS';
      
      // Update player names and area labels based on current player
      const playerAName = gameState.playerA || 'Player A';
      const playerBName = gameState.playerB || 'Player B';
      
      if (playerSeat === 0) {
        // Player A perspective - A sees themselves at bottom, opponent at top
        // After DOM reordering: playerA will be at bottom, playerB at top
        document.getElementById('playerATitle').textContent = playerAName; // A's name (will be at bottom)
        document.getElementById('playerBTitle').textContent = playerBName; // B's name (will be at top)
      } else if (playerSeat === 1) {
        // Player B perspective - B sees themselves at bottom, opponent at top
        // Original order: playerA at top, playerB at bottom
        document.getElementById('playerATitle').textContent = playerAName; // A's name (at top)
        document.getElementById('playerBTitle').textContent = playerBName; // B's name (at bottom)
      }
      
      // Make board symmetric - both players see themselves at bottom
      const gameMain = document.querySelector('.game-main');
      const playerA = document.getElementById('playerA');
      const playerB = document.getElementById('playerB');
      const cardSelectionPanel = document.getElementById('cardSelectionPanel');
      
      // Update area labels based on current player perspective
      const playerALabel = document.querySelector('#playerA .player-area-label');
      const playerBLabel = document.querySelector('#playerB .player-area-label');
      
      if (playerSeat === 0) {
        // Current player is Player A - they should see themselves at bottom
        // Reorder DOM: move playerA to bottom, playerB to top
        playerALabel.textContent = 'Your Area';
        playerALabel.className = 'player-area-label';
        playerBLabel.textContent = 'Opponent Area';
        playerBLabel.className = 'player-area-label opponent';
        
        // Move playerA to bottom (after playerB)
        gameMain.appendChild(playerA);
        
        // Ensure card selection panel is always in the middle
        // Insert it between playerB and playerA
        gameMain.insertBefore(cardSelectionPanel, playerA);
      } else if (playerSeat === 1) {
        // Current player is Player B - they should see themselves at bottom
        // Keep original order: playerA at top, playerB at bottom
        playerALabel.textContent = 'Opponent Area';
        playerALabel.className = 'player-area-label opponent';
        playerBLabel.textContent = 'Your Area';
        playerBLabel.className = 'player-area-label';
        
        // Ensure card selection panel is always in the middle
        // Insert it between playerA and playerB
        gameMain.insertBefore(cardSelectionPanel, playerB);
      }
      
      // Update dot counter with enhanced visual feedback
      const dotCounter = gameState.sharedDotCounter;
      const dotCounterElement = document.getElementById('dotCounter');
      dotCounterElement.textContent = dotCounter;
      
      // Update counter styling based on value
      dotCounterElement.className = 'dot-value';
      if (dotCounter >= 5) {
        dotCounterElement.style.color = '#4caf50'; // Green for Player A winning
        dotCounterElement.style.textShadow = '0 0 10px rgba(76, 175, 80, 0.5)';
      } else if (dotCounter <= -5) {
        dotCounterElement.style.color = '#f44336'; // Red for Player B winning
        dotCounterElement.style.textShadow = '0 0 10px rgba(244, 67, 54, 0.5)';
      } else {
        dotCounterElement.style.color = '#fff'; // White for neutral
        dotCounterElement.style.textShadow = '2px 2px 4px rgba(0,0,0,0.3)';
      }
      
      // Check win conditions
      checkWinConditions();
      
      // Update active player highlighting with enhanced visual feedback
      const playerAElement = document.getElementById('playerA');
      const playerBElement = document.getElementById('playerB');
      
      playerAElement.classList.toggle('active', gameState.activePlayer === 0);
      playerBElement.classList.toggle('active', gameState.activePlayer === 1);
      
      // Add active turn indicator to player titles
      const playerATitle = document.getElementById('playerATitle');
      const playerBTitle = document.getElementById('playerBTitle');
      
      if (gameState.activePlayer === 0) {
        playerATitle.innerHTML = (gameState.playerA || 'Player A') + ' <span style="color: #4caf50; font-size: 0.8em;">🟢 Your Turn</span>';
        playerBTitle.textContent = gameState.playerB || 'Player B';
      } else {
        playerATitle.textContent = gameState.playerA || 'Player A';
        playerBTitle.innerHTML = (gameState.playerB || 'Player B') + ' <span style="color: #4caf50; font-size: 0.8em;">🟢 Your Turn</span>';
      }
      
      // Update UI based on phase
      updateUIForPhase();
      
      // Render hands and tableaus
      renderHands();
      renderTableaus();
      
      // Render effect feedback
      renderEffectFeedback();
      
      // Render cards in central panel
      renderCentralCardPanel();
      
      // Setup drag and drop for central panel
      setupDragAndDrop();
      
      // Ensure interaction is properly toggled
      const isMyTurn = playerSeat !== null && playerSeat === gameState.activePlayer;
      toggleInteraction(isMyTurn);
      
      // Show/hide central panel based on phase and player
      updateCentralPanelVisibility();
      
      // Auto-play bot turns
      if (gameState.started) {
        const isPlayerABot = gameState.playerAIsBot;
        const isPlayerBBot = gameState.playerBIsBot;
        const activePlayer = gameState.activePlayer;
        const phase = gameState.phase;
        const inactivePlayer = 1 - activePlayer;
        
        console.log('Bot check: started=' + gameState.started + ', isPlayerABot=' + isPlayerABot + ', isPlayerBBot=' + isPlayerBBot + ', activePlayer=' + activePlayer + ', phase=' + phase);
        
        let shouldAct = false;
        let delay = 1000;
        let action = 'playing';
        
        if (phase === 'PLAY_TWO_CARDS') {
          // Submit phase: only active player bot acts
          if ((activePlayer === 0 && isPlayerABot) || (activePlayer === 1 && isPlayerBBot)) {
            shouldAct = true;
            delay = 1000; // 1 second to select cards
            action = 'selecting cards';
          }
        } else if (phase === 'OPPONENT_PICK') {
          // Choice phase: only inactive player bot acts
          if ((inactivePlayer === 0 && isPlayerABot) || (inactivePlayer === 1 && isPlayerBBot)) {
            shouldAct = true;
            delay = 3000; // 3 seconds to choose between cards
            action = 'choosing between cards';
          }
        }
        
        if (shouldAct) {
          console.log('Bot will ' + action + ' in ' + delay + 'ms');
          setTimeout(async () => {
            try {
              await req(api + '/api/match/' + matchId + '/bot-turn?seat=' + playerSeat, { method: 'POST' });
              log('Bot ' + action + ' automatically');
            } catch (error) {
              console.log('Bot auto-play failed:', error);
            }
          }, delay);
        }
      }
    }

    function showLobby() {
      showScreen('readyScreen');
      
      // Update lobby info
      document.getElementById('playerAName').textContent = gameState.playerA || '-';
      document.getElementById('playerBName').textContent = gameState.playerB || '-';
      
      const playerAReady = document.getElementById('playerAReady');
      const playerBReady = document.getElementById('playerBReady');
      
      playerAReady.textContent = gameState.readyA ? '(Ready)' : '(Not Ready)';
      playerBReady.textContent = gameState.readyB ? '(Ready)' : '(Not Ready)';
      playerAReady.className = gameState.readyA ? 'ready-status ready' : 'ready-status not-ready';
      playerBReady.className = gameState.readyB ? 'ready-status ready' : 'ready-status not-ready';
      
      // Show ready button if this player isn't ready yet
      const readyBtn = document.getElementById('readyBtn');
      const waitingMsg = document.getElementById('waitingMessage');
      
      if (playerSeat === 0 && !gameState.readyA) {
        readyBtn.style.display = 'block';
        waitingMsg.textContent = 'Click "I\'m Ready!" when you\'re ready to start';
      } else if (playerSeat === 1 && !gameState.readyB) {
        readyBtn.style.display = 'block';
        waitingMsg.textContent = 'Click "I\'m Ready!" when you\'re ready to start';
      } else if (!gameState.readyA || !gameState.readyB) {
        readyBtn.style.display = 'none';
        waitingMsg.textContent = 'Waiting for the other player to be ready...';
        } else {
        readyBtn.style.display = 'none';
        waitingMsg.textContent = 'Both players ready! Starting game...';
      }
    }

    function showGame() {
      showScreen('gameScreen');
    }

    // Add all other necessary game functions here...
    // (This is a simplified version - the full version would include all the render functions, game logic, etc.)

    // Auto-refresh every 2 seconds when there's an active match
    let refreshInterval;
    function startAutoRefresh() {
      if (refreshInterval) clearInterval(refreshInterval);
      refreshInterval = setInterval(async () => {
        if (matchId) {
          try {
            await refresh();
          } catch (e) {
            console.log('Auto-refresh failed:', e);
          }
        }
      }, 2000);
    }

    function stopAutoRefresh() {
      if (refreshInterval) {
        clearInterval(refreshInterval);
        refreshInterval = null;
      }
    }

    // Add event listeners for game controls
    document.getElementById('readyBtn').onclick = setReady;
    document.getElementById('copyMatchIdBtn').onclick = copyMatchId;
    document.getElementById('autoBtn').onclick = autoTurn;

    async function setReady() {
      try {
        await req(api + '/api/match/' + matchId + '/ready?seat=' + playerSeat, {
          method: 'POST'
        });
        log('Ready status sent');
        refresh();
      } catch (error) {
        alert('Failed to set ready status: ' + error.message);
      }
    }

    async function copyMatchId() {
      if (!matchId) return;
      
      try {
        // Copy just the match ID to clipboard
        await navigator.clipboard.writeText(matchId);
        
        // Show temporary feedback
        const btn = document.getElementById('copyMatchIdBtn');
        const originalText = btn.textContent;
        btn.textContent = '✅ Copied!';
        btn.style.backgroundColor = '#28a745';
        
        setTimeout(() => {
          btn.textContent = originalText;
          btn.style.backgroundColor = '';
        }, 1500);
        
        log('Match ID copied to clipboard: ' + matchId);
      } catch (error) {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = matchId;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        
        log('Match ID copied to clipboard (fallback)');
      }
    }

    async function autoTurn() {
      if (!matchId) return;
      const url = playerSeat !== null ? 
        api + '/api/match/' + matchId + '/auto?seat=' + playerSeat :
        api + '/api/match/' + matchId + '/auto';
      await req(url, { method:'POST' });
      log('Auto turn submitted');
      await refresh();
    }

    // Complete game functions implementation
    function renderCard(cardId, cardDef, isSelectable = false, realCardId = null) {
      const div = document.createElement('div');
      div.className = 'card-tooltip';
      
      const realId = realCardId || cardId;
      const displayId = cardId;
      
      const btn = document.createElement('button');
      btn.className = 'card hand-card' + (isSelectable && (selUp === displayId || selDown === displayId) ? ' selected' : '');
      btn.setAttribute('data-real-id', realId);
      
      if(cardDef){
          const title = document.createElement('div');
          title.className = 'card-title';
          title.textContent = cardDef.name;
          btn.appendChild(title);
          const ul = document.createElement('ul');
          ul.className = 'card-effects';
          cardDef.tiers.forEach((tier, idx)=>{
             const li=document.createElement('li');
             li.textContent = (idx+1)+'. '+ (tier.actions[0]?.description || '');
             ul.appendChild(li);
          });
          btn.appendChild(ul);
      } else {
          btn.textContent = displayId;
      }
      
      const canSelect = isSelectable && (!gameState || !gameState.waitingForOpponentChoice);
      
      if (canSelect) {
        // Make card draggable
        btn.draggable = true;
        
        // Add drag event listeners
        btn.addEventListener('dragstart', (e) => {
          e.dataTransfer.setData('text/plain', realId);
          btn.classList.add('dragging');
        });
        
        btn.addEventListener('dragend', (e) => {
          btn.classList.remove('dragging');
        });
        
        // Keep click functionality as backup
        btn.onclick = () => {
          if (!selUp) selUp = realId;
          else if (!selDown && realId !== selUp) selDown = realId; 
          else { selUp = realId; selDown = null; }
          document.getElementById('selUp').textContent = selUp || '-';
          document.getElementById('selDown').textContent = selDown || '-';
          updateCardSelection();
        };
      }
      
      if (cardDef) {
        const tooltip = document.createElement('div');
        tooltip.className = 'tooltip-content';
        tooltip.innerHTML = generateCardTooltip(cardDef);
        div.appendChild(tooltip);
      }
      
      div.appendChild(btn);
      return div;
    }

    function generateCardTooltip(cardDef) {
      let html = `<strong>${cardDef.name}</strong><br>`;
      html += `Tags: ${cardDef.tags.join(', ')}<br><br>`;
      
      cardDef.tiers.forEach((tier, index) => {
        html += `<strong>Tier ${index + 1}:</strong><br>`;
        tier.actions.forEach(action => {
          html += `• ${action.description}<br>`;
        });
        html += '<br>';
      });
      
      return html;
    }

    function getNextEffectLevel(cardId, playerTableau) {
      if (!cardId || !playerTableau) return 0;
      const count = playerTableau.filter(id => id === cardId).length;
      console.log(`Effect level calculation: cardId=${cardId}, tableau=[${playerTableau.join(', ')}], count=${count}, nextLevel=${Math.min(count, 2)}`);
      return Math.min(count, 2); // 0, 1, or 2 (tiers are 0-indexed)
    }

    function generateEffectsHTMLWithHighlighting(cardDef, myTableau, oppTableau) {
      if (!cardDef) return 'Unknown card';
      
      // The card being evaluated (from choice panel) needs to be matched against tableau IDs
      // We need to find what ID this card would have in the tableau
      const cardId = findCardIdInTableau(cardDef, myTableau, oppTableau);
      
      let html = '<ul class="card-effects">';
      cardDef.tiers.forEach((tier, index) => {
        tier.actions.forEach(action => {
          const myNextLevel = getNextEffectLevel(cardId, myTableau);
          const oppNextLevel = getNextEffectLevel(cardId, oppTableau);
          
          let className = '';
          if (index === myNextLevel) {
            className = 'effect-mine';
          } else if (index === oppNextLevel) {
            className = 'effect-opponent';
          }
          
          html += `<li class="${className}"><strong>Tier ${index + 1}:</strong> ${action.description}</li>`;
        });
      });
      html += '</ul>';
      return html;
    }
    
    function findCardIdInTableau(cardDef, myTableau, oppTableau) {
      // Find the tableau ID that corresponds to this card
      const allTableauIds = [...myTableau, ...oppTableau];
      
      // Look for a tableau ID whose definition matches this card's name
      for (const tableauId of allTableauIds) {
        const tableauCardDef = gameState.cardDefinitions[tableauId];
        if (tableauCardDef && tableauCardDef.name === cardDef.name) {
          console.log(`✅ Found match: ${cardDef.name} → ${tableauId}`);
          return tableauId;
        }
      }
      
      console.log(`❌ No match found for ${cardDef.name} in tableaus:`, {
        cardName: cardDef.name,
        myTableau: myTableau,
        oppTableau: oppTableau,
        cardDefinitions: Object.keys(gameState.cardDefinitions).map(id => ({
          id: id,
          name: gameState.cardDefinitions[id]?.name
        }))
      });
      
      // Fallback to card definition ID or name
      return cardDef.id || cardDef.name;
    }

    function generateEffectsHTML(cardDef) {
      if (!cardDef) return 'Unknown card';
      
      let html = '<ul class="card-effects">';
      cardDef.tiers.forEach((tier, index) => {
        tier.actions.forEach(action => {
          html += `<li><strong>Tier ${index + 1}:</strong> ${action.description}</li>`;
        });
      });
      html += '</ul>';
      return html;
    }

    function updateCardSelection() {
      const handCards = document.querySelectorAll('.hand .card');
      handCards.forEach(card => {
        const realId = card.getAttribute('data-real-id');
        if (realId === selUp || realId === selDown) {
          card.classList.add('selected');
        } else {
          card.classList.remove('selected');
        }
      });
      
      // Update card previews
      updateCardPreviews();
    }
    
    function updateCardPreviews() {
      const faceUpPreview = document.getElementById('faceUpPreview');
      const faceDownPreview = document.getElementById('faceDownPreview');
      
      // Clear previous content and reset classes
      faceUpPreview.innerHTML = '<div class="placeholder">Drag a card here</div>';
      faceUpPreview.className = 'card-preview';
      faceDownPreview.innerHTML = '<div class="placeholder">Drag a card here</div>';
      faceDownPreview.className = 'card-preview';
      
      // Render face up card details if selected
      if (selUp && gameState && gameState.cardDefinitions) {
        const cardDef = gameState.cardDefinitions[selUp];
        if (cardDef) {
          faceUpPreview.innerHTML = createCardPreviewContent(cardDef);
          faceUpPreview.className = 'card-preview has-card';
        }
      }
      
      // Render face down card details if selected
      if (selDown && gameState && gameState.cardDefinitions) {
        const cardDef = gameState.cardDefinitions[selDown];
        if (cardDef) {
          faceDownPreview.innerHTML = createCardPreviewContent(cardDef);
          faceDownPreview.className = 'card-preview has-card';
        }
      }
    }
    
    function createCardPreviewContent(cardDef) {
      let content = `
        <div class="card-preview-content">
          <div class="card-preview-name">${cardDef.name}</div>
          <div class="card-preview-tiers">
      `;
      
      // Get tableau information for highlighting
      const myTableau = playerSeat === 0 ? gameState.tableauCardIdsA : gameState.tableauCardIdsB;
      const oppTableau = playerSeat === 0 ? gameState.tableauCardIdsB : gameState.tableauCardIdsA;
      
      // Find the card ID in tableaus for effect level calculation
      const cardId = findCardIdInTableau(cardDef, myTableau, oppTableau);
      const myNextLevel = getNextEffectLevel(cardId, myTableau);
      const oppNextLevel = getNextEffectLevel(cardId, oppTableau);
      
      // Add tiers with color coding and highlighting
      cardDef.tiers.forEach((tier, index) => {
        // Determine if this tier will be active for me or opponent
        let tierHighlightClass = '';
        if (index === myNextLevel) {
          tierHighlightClass = 'effect-mine';
        } else if (index === oppNextLevel) {
          tierHighlightClass = 'effect-opponent';
        }
        
        content += `
          <div class="tier-preview ${tierHighlightClass}">
            <div class="tier-preview-header">Tier ${index + 1}</div>
        `;
        
        tier.actions.forEach(action => {
          // Determine if this is a self or opponent effect
          const isSelfEffect = action.target === 'self' || action.target === 'both';
          const tierClass = isSelfEffect ? 'self-effect' : 'opponent-effect';
          
          content += `
            <div class="tier-preview-action ${tierClass}">
              ${action.description}
            </div>
          `;
        });
        
        content += `</div>`;
      });
      
      content += `
          </div>
        </div>
      `;
      
      return content;
    }
    
    function updateChooseButtons() {
      const chooseFaceUp = document.getElementById('chooseFaceUp');
      const chooseFaceDown = document.getElementById('chooseFaceDown');
      const playBtn = document.getElementById('playBtn');
      
      if (!gameState) return;
      
      const isOpponentPickPhase = gameState.phase === 'OPPONENT_PICK';
      const isPlayTwoCardsPhase = gameState.phase === 'PLAY_TWO_CARDS';
      
      if (isOpponentPickPhase) {
        // In opponent pick phase, always enable buttons (cards are already selected by active player)
        if (chooseFaceUp) {
          chooseFaceUp.disabled = false;
          chooseFaceUp.style.display = 'block';
        }
        if (chooseFaceDown) {
          chooseFaceDown.disabled = false;
          chooseFaceDown.style.display = 'block';
        }
        if (playBtn) playBtn.style.display = 'none';
      } else if (isPlayTwoCardsPhase) {
        // In play two cards phase, show play button when both cards are selected
        if (chooseFaceUp) chooseFaceUp.style.display = 'none';
        if (chooseFaceDown) chooseFaceDown.style.display = 'none';
        if (playBtn) {
          playBtn.style.display = selUp && selDown ? 'block' : 'none';
        }
      } else {
        // Other phases - disable everything
        if (chooseFaceUp) {
          chooseFaceUp.disabled = true;
          chooseFaceUp.style.display = 'block';
        }
        if (chooseFaceDown) {
          chooseFaceDown.disabled = true;
          chooseFaceDown.style.display = 'block';
        }
        if (playBtn) playBtn.style.display = 'none';
      }
    }
    
    function updateCentralPanelVisibility() {
      const cardSelectionPanel = document.getElementById('cardSelectionPanel');
      if (!cardSelectionPanel || !gameState) return;
      
      // Always show the panel, but control interaction based on phase and player
      cardSelectionPanel.style.display = 'block';
      
      const isOpponentPickPhase = gameState.phase === 'OPPONENT_PICK';
      const isPlayTwoCardsPhase = gameState.phase === 'PLAY_TWO_CARDS';
      const isInactivePlayer = playerSeat !== null && playerSeat !== gameState.activePlayer;
      const isActivePlayer = playerSeat !== null && playerSeat === gameState.activePlayer;
      
      if (isOpponentPickPhase && isInactivePlayer) {
        // Inactive player can choose between the two cards
        enableCentralPanelInteraction(true);
        updatePanelTitle('Choose Between These Cards');
      } else if (isPlayTwoCardsPhase && isActivePlayer) {
        // Active player can select two cards to play
        enableCentralPanelInteraction(true);
        updatePanelTitle('Select Your Cards to Play');
      } else {
        // Disable interaction for other cases
        enableCentralPanelInteraction(false);
        updatePanelTitle('Waiting...');
      }
    }
    
    function updatePanelTitle(title) {
      const panelTitle = document.querySelector('#cardSelectionPanel h3');
      if (panelTitle) {
        panelTitle.textContent = title;
      }
    }
    
    function enableCentralPanelInteraction(enabled) {
      const faceUpPreview = document.getElementById('faceUpPreview');
      const faceDownPreview = document.getElementById('faceDownPreview');
      const chooseFaceUp = document.getElementById('chooseFaceUp');
      const chooseFaceDown = document.getElementById('chooseFaceDown');
      
      if (enabled) {
        // Enable drag and drop
        if (faceUpPreview) faceUpPreview.style.pointerEvents = 'auto';
        if (faceDownPreview) faceDownPreview.style.pointerEvents = 'auto';
        
        // Enable choose buttons based on current phase
        const isOpponentPickPhase = gameState && gameState.phase === 'OPPONENT_PICK';
        const isPlayTwoCardsPhase = gameState && gameState.phase === 'PLAY_TWO_CARDS';
        
        if (isOpponentPickPhase) {
          // In opponent pick phase, always enable buttons (cards are already selected by active player)
          if (chooseFaceUp) chooseFaceUp.disabled = false;
          if (chooseFaceDown) chooseFaceDown.disabled = false;
        } else if (isPlayTwoCardsPhase) {
          // In play two cards phase, show play button when both cards are selected
          if (chooseFaceUp) chooseFaceUp.style.display = 'none';
          if (chooseFaceDown) chooseFaceDown.style.display = 'none';
          // Show play button instead
          const playBtn = document.getElementById('playBtn');
          if (playBtn) {
            playBtn.style.display = selUp && selDown ? 'block' : 'none';
          }
        }
      } else {
        // Disable drag and drop
        if (faceUpPreview) faceUpPreview.style.pointerEvents = 'none';
        if (faceDownPreview) faceDownPreview.style.pointerEvents = 'none';
        
        // Disable all buttons
        if (chooseFaceUp) {
          chooseFaceUp.disabled = true;
          chooseFaceUp.style.display = 'block';
        }
        if (chooseFaceDown) {
          chooseFaceDown.disabled = true;
          chooseFaceDown.style.display = 'block';
        }
        const playBtn = document.getElementById('playBtn');
        if (playBtn) playBtn.style.display = 'none';
      }
    }
    
    function setupDragAndDrop() {
      const faceUpPreview = document.getElementById('faceUpPreview');
      const faceDownPreview = document.getElementById('faceDownPreview');
      
      if (!faceUpPreview || !faceDownPreview) return;
      
      // Face Up drop zone
      faceUpPreview.addEventListener('dragover', (e) => {
        e.preventDefault();
        if (faceUpPreview.style.pointerEvents !== 'none') {
          faceUpPreview.classList.add('drag-over');
        }
      });
      
      faceUpPreview.addEventListener('dragleave', (e) => {
        faceUpPreview.classList.remove('drag-over');
      });
      
      faceUpPreview.addEventListener('drop', (e) => {
        e.preventDefault();
        faceUpPreview.classList.remove('drag-over');
        
        if (faceUpPreview.style.pointerEvents !== 'none') {
          const cardId = e.dataTransfer.getData('text/plain');
          if (cardId) {
            selUp = cardId;
            updateCardSelection();
            updateCardPreviews();
            updateChooseButtons();
          }
        }
      });
      
      // Face Down drop zone
      faceDownPreview.addEventListener('dragover', (e) => {
        e.preventDefault();
        if (faceDownPreview.style.pointerEvents !== 'none') {
          faceDownPreview.classList.add('drag-over');
        }
      });
      
      faceDownPreview.addEventListener('dragleave', (e) => {
        faceDownPreview.classList.remove('drag-over');
      });
      
      faceDownPreview.addEventListener('drop', (e) => {
        e.preventDefault();
        faceDownPreview.classList.remove('drag-over');
        
        if (faceDownPreview.style.pointerEvents !== 'none') {
          const cardId = e.dataTransfer.getData('text/plain');
          if (cardId) {
            selDown = cardId;
            updateCardSelection();
            updateCardPreviews();
            updateChooseButtons();
          }
        }
      });
      
      // Choose button event listeners
      const chooseFaceUp = document.getElementById('chooseFaceUp');
      const chooseFaceDown = document.getElementById('chooseFaceDown');
      
      if (chooseFaceUp) {
        chooseFaceUp.addEventListener('click', () => {
          if (!chooseFaceUp.disabled) {
            // Handle face up selection
            console.log('Chose face up card');
            // Submit the choice to the backend
            submitOpponentChoice('faceUp');
          }
        });
      }
      
      if (chooseFaceDown) {
        chooseFaceDown.addEventListener('click', () => {
          if (!chooseFaceDown.disabled) {
            // Handle face down selection
            console.log('Chose face down card');
            // Submit the choice to the backend
            submitOpponentChoice('faceDown');
          }
        });
      }
    }

    // Prevent multiple simultaneous submissions
    let isSubmittingChoice = false;
    
    async function submitOpponentChoice(choice) {
      if (!matchId || !gameState) {
        console.error('Missing matchId or gameState:', { matchId, gameState: !!gameState });
        return;
      }
      
      // Prevent multiple simultaneous submissions
      if (isSubmittingChoice) {
        console.log('Choice already being submitted, ignoring duplicate');
        return;
      }
      
      isSubmittingChoice = true;
      
      try {
        const chooseFaceUp = choice === 'faceUp';
        const url = `${api}/api/match/${matchId}/choose`;
        const body = { chooseFaceUp: chooseFaceUp };
        
        console.log('Submitting opponent choice:', {
          choice,
          chooseFaceUp,
          url,
          body,
          currentPhase: gameState.phase,
          activePlayer: gameState.activePlayer,
          playerSeat
        });
        
        const response = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
        
        console.log('Response status:', response.status);
        console.log('Response ok:', response.ok);
        
        if (response.ok) {
          console.log('Opponent choice submitted successfully');
          await refresh();
        } else {
          const errorText = await response.text();
          console.error('Failed to submit opponent choice:', response.status, errorText);
        }
      } catch (error) {
        console.error('Error submitting opponent choice:', error);
      } finally {
        isSubmittingChoice = false;
      }
    }

    function renderHands() {
      if (!gameState || playerSeat === null) return;
      
      // Determine which hand divs belong to me vs opponent
      const myHandDiv = playerSeat === 0 ? document.getElementById('handA') : document.getElementById('handB');
      const oppHandDiv = playerSeat === 0 ? document.getElementById('handB') : document.getElementById('handA');
      
      // Clear both hands
      myHandDiv.innerHTML = '';
      oppHandDiv.innerHTML = '';
      
      // Render my hand with real cards
      if (gameState.activeHandCardIds && gameState.activeHandCardIds.length > 0) {
        const cardCounts = {};
        gameState.activeHandCardIds.forEach(id => {
          cardCounts[id] = (cardCounts[id] || 0) + 1;
        });
        
        Object.keys(cardCounts).forEach(id => {
          const count = cardCounts[id];
          const cardDef = gameState.cardDefinitions[id];
          for (let i = 0; i < count; i++) {
            const uniqueId = count > 1 ? `${id}_${i}` : id;
            myHandDiv.appendChild(renderCard(uniqueId, cardDef, true, id));
          }
        });
      }
      
      // Render opponent hand with card backs
      const oppHandSize = playerSeat === 0 ? gameState.handSizeB : gameState.handSizeA;
      for (let i = 0; i < oppHandSize; i++) {
        const cardBack = document.createElement('div');
        cardBack.className = 'card-tooltip';
        cardBack.style.width = '140px';
        cardBack.style.height = '200px';
        cardBack.style.border = '2px solid #666';
        cardBack.style.borderRadius = '8px';
        cardBack.style.backgroundColor = '#333';
        cardBack.style.display = 'flex';
        cardBack.style.alignItems = 'center';
        cardBack.style.justifyContent = 'center';
        cardBack.style.fontSize = '24px';
        cardBack.style.color = '#fff';
        cardBack.textContent = '?';
        oppHandDiv.appendChild(cardBack);
      }
    }
    function renderTableaus() {
      if (!gameState || playerSeat === null) return;
      
      // Determine which tableau divs belong to me vs opponent based on current perspective
      const myTableauDiv = playerSeat === 0 ? document.getElementById('tableauA') : document.getElementById('tableauB');
      const oppTableauDiv = playerSeat === 0 ? document.getElementById('tableauB') : document.getElementById('tableauA');
      
      // Get the correct tableau data based on perspective
      const myTableauIds = playerSeat === 0 ? gameState.tableauCardIdsA : gameState.tableauCardIdsB;
      const oppTableauIds = playerSeat === 0 ? gameState.tableauCardIdsB : gameState.tableauCardIdsA;
      
      // Clear both tableaus
      myTableauDiv.innerHTML = '';
      oppTableauDiv.innerHTML = '';
      
      // Render my tableau
      const cardCountsMy = {};
      myTableauIds.forEach(id => {
        cardCountsMy[id] = (cardCountsMy[id] || 0) + 1;
      });
      
      Object.keys(cardCountsMy).forEach(id => {
        const count = cardCountsMy[id];
        const cardDef = gameState.cardDefinitions[id];
        const stackedCard = renderStackedCard(id, cardDef, count);
        myTableauDiv.appendChild(stackedCard);
      });
      
      // Render opponent tableau
      const cardCountsOpp = {};
      oppTableauIds.forEach(id => {
        cardCountsOpp[id] = (cardCountsOpp[id] || 0) + 1;
      });
      
      Object.keys(cardCountsOpp).forEach(id => {
        const count = cardCountsOpp[id];
        const cardDef = gameState.cardDefinitions[id];
        const stackedCard = renderStackedCard(id, cardDef, count);
        oppTableauDiv.appendChild(stackedCard);
      });
    }
    
    function renderEffectFeedback() {
      if (!gameState || !gameState.recentEffects) return;
      
      const effectContainer = document.getElementById('effectFeedback');
      if (!effectContainer) return;
      
      // Clear previous effects
      effectContainer.innerHTML = '';
      
      // Show only the last 5 effects
      const recentEffects = gameState.recentEffects.slice(-5);
      
      recentEffects.forEach(effect => {
        const effectDiv = document.createElement('div');
        effectDiv.className = 'effect-item';
        
        // Determine effect type for styling
        if (effect.effectDescription.includes('cura') || effect.effectDescription.includes('heal')) {
          effectDiv.classList.add('heal');
        } else if (effect.effectDescription.includes('daño') || effect.effectDescription.includes('damage')) {
          effectDiv.classList.add('damage');
        } else if (effect.dotChange !== 0) {
          effectDiv.classList.add('dot-change');
        }
        
        // Create effect text
        let effectText = `<strong>${effect.playerName}</strong>: ${effect.effectDescription}`;
        
        // Add change indicators
        if (effect.dotChange !== 0) {
          const changeText = effect.dotChange > 0 ? `+${effect.dotChange}` : `${effect.dotChange}`;
          effectText += ` <span style="color: #ff9800;">[${changeText} puntos]</span>`;
        }
        
        if (effect.lpChangeA !== 0 || effect.lpChangeB !== 0) {
          const lpChanges = [];
          if (effect.lpChangeA !== 0) lpChanges.push(`A: ${effect.lpChangeA > 0 ? '+' : ''}${effect.lpChangeA}`);
          if (effect.lpChangeB !== 0) lpChanges.push(`B: ${effect.lpChangeB > 0 ? '+' : ''}${effect.lpChangeB}`);
          effectText += ` <span style="color: #666;">[${lpChanges.join(', ')} LP]</span>`;
        }
        
        effectDiv.innerHTML = effectText;
        effectContainer.appendChild(effectDiv);
      });
      
      // Scroll to bottom to show latest effects
      effectContainer.scrollTop = effectContainer.scrollHeight;
    }
    
    function renderCentralCardPanel() {
      // Update phase display
      if (gameState && gameState.phase) {
        const phaseElement = document.getElementById('currentPhase');
        if (phaseElement) {
          phaseElement.textContent = gameState.phase;
        }
      }
      
      // Load selected cards in OPPONENT_PICK phase
      if (gameState && gameState.phase === 'OPPONENT_PICK') {
        loadSelectedCardsForOpponentPick();
      } else {
        // Update card previews for other phases
        updateCardPreviews();
      }
      
      // Update choose buttons
      updateChooseButtons();
    }
    
    function loadSelectedCardsForOpponentPick() {
      const faceUpPreview = document.getElementById('faceUpPreview');
      const faceDownPreview = document.getElementById('faceDownPreview');
      
      if (!faceUpPreview || !faceDownPreview || !gameState) return;
      
      // Get the selected cards from game state
      const selectedFaceUpCard = gameState.faceUpCardId;
      const selectedFaceDownCard = gameState.faceDownCardId;
      
      // Load Face Up Card
      if (selectedFaceUpCard && gameState.cardDefinitions) {
        const cardDef = gameState.cardDefinitions[selectedFaceUpCard];
        if (cardDef) {
          faceUpPreview.innerHTML = createCardPreviewContent(cardDef);
          faceUpPreview.className = 'card-preview has-card';
        }
      } else {
        faceUpPreview.innerHTML = '<div class="placeholder">No card selected</div>';
        faceUpPreview.className = 'card-preview';
      }
      
      // Load Face Down Card (mystery card)
      if (selectedFaceDownCard && gameState.cardDefinitions) {
        const cardDef = gameState.cardDefinitions[selectedFaceDownCard];
        if (cardDef) {
          // Show as mystery card with ???
          faceDownPreview.innerHTML = `
            <div class="card-preview-content">
              <div class="card-preview-name">???</div>
              <div class="card-preview-tiers">
                <div class="tier-preview">
                  <div class="tier-preview-header">Hidden Card</div>
                  <div class="tier-preview-action">This card's effects are hidden</div>
                </div>
              </div>
            </div>
          `;
          faceDownPreview.className = 'card-preview has-card mystery-card';
          // Disable drag and drop for mystery card
          faceDownPreview.style.pointerEvents = 'none';
        }
      } else {
        faceDownPreview.innerHTML = '<div class="placeholder">No card selected</div>';
        faceDownPreview.className = 'card-preview';
        // Disable drag and drop when no card
        faceDownPreview.style.pointerEvents = 'none';
      }
    }
    
    function selectCard(cardId, position) {
      if (position === 'up') {
        selUp = cardId;
      } else {
        selDown = cardId;
      }
      
      updateCardSelection();
      updateCardPreviews();
    }

    function renderStackedCard(cardId, cardDef, count) {
      const div = document.createElement('div');
      div.className = 'card-tooltip stacked-card';
      
      const btn = document.createElement('button');
      btn.className = 'tableau-card';
      btn.style.width = '140px';
      btn.style.minHeight = '200px';
      btn.style.position='relative';
      
      if(cardDef){
          const title=document.createElement('div');
          title.className='card-title';
          title.textContent=cardDef.name;
          btn.appendChild(title);
          const ul=document.createElement('ul');
          ul.className='card-effects';
          cardDef.tiers.forEach((tier,idx)=>{
              const li=document.createElement('li');
              li.textContent=(idx+1)+'. '+(tier.actions[0]?.description||'');
              if(idx===Math.min(count-1,2)) li.classList.add('active');
              ul.appendChild(li);
          });
          btn.appendChild(ul);
      } else {
          btn.textContent=cardId;
      }
      
      // Add count badge if more than 1
      if (count > 1) {
        const badge = document.createElement('span');
        badge.className = 'card-count-badge';
        badge.textContent = count;
        btn.appendChild(badge);
      }
      
      if (cardDef) {
        const tooltip = document.createElement('div');
        tooltip.className = 'tooltip-content';
        tooltip.innerHTML = generateCardTooltip(cardDef);
        div.appendChild(tooltip);
      }
      
      div.appendChild(btn);
      return div;
    }
    function startTurnTimer() {
      clearTimers();
      turnTimeLeft = 60; // Doubled from 30 to 60 seconds
      updateTimerDisplay();
      
      turnTimer = setInterval(() => {
        turnTimeLeft--;
        updateTimerDisplay();
        
        if (turnTimeLeft <= 0) {
          clearTimers();
          log('Turn timer expired! Auto-selecting random cards...');
          autoSelectRandomCards();
        }
      }, 1000);
    }

    function startChoiceTimer() {
      clearTimers();
      choiceTimeLeft = 30; // Doubled from 15 to 30 seconds
      updateTimerDisplay();
      
      choiceTimer = setInterval(() => {
        choiceTimeLeft--;
        updateTimerDisplay();
        
        if (choiceTimeLeft <= 0) {
          clearTimers();
          log('Choice timer expired! Auto-selecting random choice...');
          autoSelectRandomChoice();
        }
      }, 1000);
    }
    
    function updateTimerDisplay() {
      const timerElement = document.getElementById('timer');
      if (!timerElement) return;
      
      const currentTime = turnTimer ? turnTimeLeft : choiceTimeLeft;
      timerElement.textContent = currentTime + 's';
      
      // Update timer styling based on time remaining (proportional to timer type)
      timerElement.className = 'timer-display';
      const isChoicePhase = choiceTimer !== null;
      
      if (isChoicePhase) {
        // Choice phase: 30 seconds total
        if (currentTime <= 5) {
          timerElement.classList.add('danger');
        } else if (currentTime <= 10) {
          timerElement.classList.add('warning');
        }
      } else {
        // Turn phase: 60 seconds total  
        if (currentTime <= 10) {
          timerElement.classList.add('danger');
        } else if (currentTime <= 20) {
          timerElement.classList.add('warning');
        }
      }
    }

    function clearTimers() {
      if (turnTimer) {
        clearInterval(turnTimer);
        turnTimer = null;
      }
      if (choiceTimer) {
        clearInterval(choiceTimer);
        choiceTimer = null;
      }
    }

    async function autoSelectRandomCards() {
      if (!matchId || !gameState || gameState.waitingForOpponentChoice) return;
      
      const handIds = gameState.activeHandCardIds;
      if (handIds.length < 2) return;
      
      // Select two random cards
      const random1 = handIds[Math.floor(Math.random() * handIds.length)];
      let random2 = handIds[Math.floor(Math.random() * handIds.length)];
      while (random2 === random1 && handIds.length > 1) {
        random2 = handIds[Math.floor(Math.random() * handIds.length)];
      }
      
      selUp = random1;
      selDown = random2;
      document.getElementById('selUp').textContent = selUp;
      document.getElementById('selDown').textContent = selDown;
      
      // Make the API call
      clearTimers();
      const body = JSON.stringify({ faceUpId: selUp, faceDownId: selDown });
      const url = playerSeat !== null ? 
        api + '/api/match/' + matchId + '/play?seat=' + playerSeat :
        api + '/api/match/' + matchId + '/play';
      gameState = await req(url, { method:'POST', headers:{'Content-Type':'application/json'}, body });
      log('Auto-played: up=' + selUp + ', down=' + selDown);
      
      // Reset selection after playing
      resetSelection();
      
      await refresh();
    }

    async function autoSelectRandomChoice() {
      if (!matchId || !gameState || !gameState.waitingForOpponentChoice) return;
      
      const chooseFaceUpOption = Math.random() < 0.5;
      if (chooseFaceUpOption) {
        await chooseFaceUp();
        } else {
        await chooseFaceDown();
      }
    }

    function resetSelection() {
      selUp = null;
      selDown = null;
      document.getElementById('selUp').textContent = '-';
      document.getElementById('selDown').textContent = '-';
      updateCardSelection();
    }

    function updateUIForPhase() {
      const isWaitingForChoice = gameState.waitingForOpponentChoice;
      const phase = gameState.phase || 'PLAY_TWO_CARDS';
      const isMyTurn = playerSeat !== null && playerSeat === gameState.activePlayer;
      
      // Show/hide selection status
      const selectionStatus = document.getElementById('selectionStatus');
      if (selectionStatus) {
        selectionStatus.style.display = isWaitingForChoice ? 'none' : 'block';
      }
      
      // Show/hide buttons
      const playBtn = document.getElementById('playBtn');
      if (playBtn) {
        playBtn.style.display = !isWaitingForChoice ? 'block' : 'none';
      }
      
      // Start appropriate timer only if not already running
      if (isWaitingForChoice && !choiceTimer) {
        startChoiceTimer();
      } else if (!isWaitingForChoice && !turnTimer) {
        startTurnTimer();
      }
      
      // Toggle interaction based on turn
      toggleInteraction(isMyTurn);
      
      if (isWaitingForChoice) {
        // Show the cards that need to be chosen between
        const faceUpDef = gameState.cardDefinitions[gameState.faceUpCardId];
        const faceDownDef = gameState.cardDefinitions[gameState.faceDownCardId];
        
        // Only show choice buttons to the opponent (not the player who submitted the cards)
        const isOpponentTurn = playerSeat !== null && playerSeat !== gameState.activePlayer;
        const isCardSubmitter = playerSeat !== null && playerSeat === gameState.activePlayer;
        
        // Get current player's tableaus for effect highlighting
        const myTableau = playerSeat === 0 ? gameState.tableauCardIdsA : gameState.tableauCardIdsB;
        const oppTableau = playerSeat === 0 ? gameState.tableauCardIdsB : gameState.tableauCardIdsA;
        
        // Debug: Log current state
        console.log('Choice Panel Debug:');
        console.log('  My tableau:', myTableau.map(id => `${id} = ${gameState.cardDefinitions[id]?.name || 'Unknown'}`));
        console.log('  Opp tableau:', oppTableau.map(id => `${id} = ${gameState.cardDefinitions[id]?.name || 'Unknown'}`));
        console.log('  Face up card ID:', gameState.faceUpCardId);
        console.log('  Face down card ID:', gameState.faceDownCardId);
        console.log('  Face up def:', faceUpDef);
        console.log('  Face down def:', faceDownDef);
        
        // Update Face Up Card display
        const faceUpTitle = document.querySelector('#faceUpCardDisplay .modal-card-title');
        const faceUpEffects = document.querySelector('#faceUpCardDisplay .modal-card-effects');
        
        if (faceUpDef && faceUpTitle && faceUpEffects) {
          faceUpTitle.textContent = faceUpDef.name;
          faceUpEffects.innerHTML = generateEffectsHTMLWithHighlighting(faceUpDef, myTableau, oppTableau);
        } else if (faceUpTitle && faceUpEffects) {
          // Fallback if card definition is missing
          faceUpTitle.textContent = gameState.faceUpCardId || 'Face Up Card';
          faceUpEffects.innerHTML = '<p>Card details loading...</p>';
        }
        
        // Update Face Down Card display
        const faceDownTitle = document.querySelector('#faceDownCardDisplay .modal-card-title');
        const faceDownEffects = document.querySelector('#faceDownCardDisplay .modal-card-effects');
        if (faceDownTitle && faceDownEffects) {
          // If backend sends "???" but we are the card submitter, use our stored card
          let actualFaceDownDef = faceDownDef;
          if (isCardSubmitter && !faceDownDef && myLastFaceDownCard) {
            actualFaceDownDef = gameState.cardDefinitions[myLastFaceDownCard];
            console.log('🎭 Using stored face-down card:', myLastFaceDownCard, '→', actualFaceDownDef?.name);
          }
          
          console.log('Face Down Card logic:', {
            isCardSubmitter: isCardSubmitter,
            backendFaceDownId: gameState.faceDownCardId,
            myStoredCard: myLastFaceDownCard,
            faceDownDef: faceDownDef,
            actualFaceDownDef: actualFaceDownDef,
            playerSeat: playerSeat,
            activePlayer: gameState.activePlayer
          });
          
          if (isCardSubmitter && actualFaceDownDef) {
            // Show complete details to the player who submitted the cards (they know what it is)
            faceDownTitle.textContent = actualFaceDownDef.name + ' (You selected this)';
            faceDownTitle.className = 'modal-card-title';
            faceDownTitle.style.fontStyle = 'italic';
            faceDownTitle.style.color = '#666';
            faceDownEffects.innerHTML = generateEffectsHTMLWithHighlighting(actualFaceDownDef, myTableau, oppTableau);
        } else {
            // Opponent cannot see the face down card details
          faceDownTitle.textContent = '???';
          faceDownTitle.className = 'modal-card-title';
            faceDownTitle.style.fontStyle = 'normal';
            faceDownTitle.style.color = 'inherit';
            faceDownEffects.innerHTML = '<p>Hidden card</p>';
          }
        }
        
        // Show the choice modal
        // Modal removed - using central panel instead
      } else {
        // Modal removed - using central panel instead
      }
    }
    function toggleInteraction(isMyTurn) {
      const phase = gameState.phase || 'PLAY_TWO_CARDS';
      const canInteract = isMyTurn && phase === 'PLAY_TWO_CARDS';
      
      // Enable/disable hand cards
      const handCards = document.querySelectorAll('.hand .card');
      handCards.forEach(card => {
        if (canInteract) {
          card.style.pointerEvents = 'auto';
          card.style.opacity = '1';
        } else {
          card.style.pointerEvents = 'none';
          card.style.opacity = '0.5';
        }
      });
      
      // Show/hide play button and selection status
      const playBtn = document.getElementById('playBtn');
      const selectionStatus = document.getElementById('selectionStatus');
      
      if (canInteract && playBtn && selectionStatus) {
        playBtn.style.display = 'block';
        selectionStatus.style.display = 'block';
      } else {
        if (playBtn) playBtn.style.display = 'none';
        if (selectionStatus) selectionStatus.style.display = 'none';
      }
    }

    function checkWinConditions() {
      const dots = gameState.sharedDotCounter;
      const winnerDisplay = document.getElementById('winnerDisplay');
      const winnerText = document.getElementById('winnerText');
      
      if (winnerDisplay && winnerText) {
      if (dots >= 5) {
        // Player A wins
        winnerDisplay.style.display = 'block';
        winnerText.textContent = '🎉 Player A Wins! (+5 dots)';
        winnerText.style.color = '#4CAF50';
        log('🎉 Player A wins with ' + dots + ' dots!');
        disableGameControls();
      } else if (dots <= -5) {
        // Player B wins
        winnerDisplay.style.display = 'block';
        winnerText.textContent = '🎉 Player B Wins! (-5 dots)';
        winnerText.style.color = '#4CAF50';
        log('🎉 Player B wins with ' + dots + ' dots!');
        disableGameControls();
      } else {
        // No winner yet
        winnerDisplay.style.display = 'none';
        }
      }
    }

    function disableGameControls() {
      // Disable all game controls when someone wins
      const controls = ['playBtn', 'autoBtn', 'chooseFaceUpBtn', 'chooseFaceDownBtn'];
      controls.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
          element.disabled = true;
          element.style.opacity = '0.5';
        }
      });
      
      // Clear timers
      clearTimers();
      
      // Disable card selection
      const handCards = document.querySelectorAll('.hand .card');
      handCards.forEach(card => {
        card.style.pointerEvents = 'none';
        card.style.opacity = '0.5';
      });

      // Show rematch and back to home buttons
      const rematchBtn = document.getElementById('rematchBtn');
      const gameBackToHomeBtn = document.getElementById('gameBackToHomeBtn');
      if (rematchBtn) {
        rematchBtn.disabled = false;
        rematchBtn.style.opacity = '1';
        rematchBtn.style.display = 'inline-block';
      }
      if (gameBackToHomeBtn) {
        gameBackToHomeBtn.disabled = false;
        gameBackToHomeBtn.style.opacity = '1';
        gameBackToHomeBtn.style.display = 'inline-block';
      }
    }

    async function chooseFaceUp() {
      if (!matchId) return;
      clearTimers();
      // Hide modal immediately
      // Modal removed - using central panel instead
      const body = JSON.stringify({ chooseFaceUp: true });
      const url = playerSeat !== null ? 
        api + '/api/match/' + matchId + '/choose?seat=' + playerSeat :
        api + '/api/match/' + matchId + '/choose';
      gameState = await req(url, { method:'POST', headers:{'Content-Type':'application/json'}, body });
      log('Opponent chose Face Up card');
      await refresh();
    }

    async function chooseFaceDown() {
      if (!matchId) return;
      clearTimers();
      // Hide modal immediately
      // Modal removed - using central panel instead
      const body = JSON.stringify({ chooseFaceUp: false });
      const url = playerSeat !== null ? 
        api + '/api/match/' + matchId + '/choose?seat=' + playerSeat :
        api + '/api/match/' + matchId + '/choose';
      gameState = await req(url, { method:'POST', headers:{'Content-Type':'application/json'}, body });
      log('Opponent chose Face Down card');
      await refresh();
    }

    // Store the last face-down card we submitted (so we can show it to ourselves later)
    let myLastFaceDownCard = null;

    // Missing function for play selected cards
    async function playSelected() {
      if (!matchId || !selUp || !selDown) { 
        log('Pick two cards'); 
        return; 
      }
      clearTimers();
      
      // Store our face-down card selection locally
      myLastFaceDownCard = selDown;
      console.log('🎭 Storing my face-down card:', selDown);
      
      const body = JSON.stringify({ faceUpId: selUp, faceDownId: selDown });
      const url = playerSeat !== null ? 
        api + '/api/match/' + matchId + '/play?seat=' + playerSeat :
        api + '/api/match/' + matchId + '/play';
      gameState = await req(url, { method:'POST', headers:{'Content-Type':'application/json'}, body });
      log('Played: up=' + selUp + ', down=' + selDown);
      
      // Reset selection after playing
      resetSelection();
      
      await refresh();
    }

    // Add event listener for play button
    const playBtn = document.getElementById('playBtn');
    if (playBtn) {
      playBtn.onclick = playSelected;
    }

    // Add event listeners for rematch and back to home buttons
    const rematchBtn = document.getElementById('rematchBtn');
    if (rematchBtn) {
      rematchBtn.onclick = startRematch;
    }

    const gameBackToHomeBtn = document.getElementById('gameBackToHomeBtn');
    if (gameBackToHomeBtn) {
      gameBackToHomeBtn.onclick = () => {
        // Clear game state and return to home
        clearGameState();
        showScreen('homeScreen');
      };
    }

    async function startRematch() {
      try {
        log('🔄 Starting rematch with same players...');
        
        // Hide winner display immediately
        const winnerDisplay = document.getElementById('winnerDisplay');
        if (winnerDisplay) {
          winnerDisplay.style.display = 'none';
        }
        
        // Show loading message
        log('Resetting game state...');
        
        // Reset all game visuals but keep matchId and playerSeat
        resetGameVisuals();
        
        // Try to call backend rematch endpoint
        try {
          await req(api + '/api/match/' + matchId + '/rematch', { method: 'POST' });
          log('✅ Backend rematch successful');
        } catch (backendError) {
          // If backend endpoint doesn't exist, that's OK - we'll handle it manually
          if (backendError.message.includes('404') || backendError.message.includes('Not Found')) {
            log('⚠️ Backend rematch endpoint not available, using manual reset');
          } else {
            throw backendError; // Re-throw non-404 errors
          }
        }
        
        // Show ready screen for both players to confirm they want to play again
        if (matchId) {
          document.getElementById('displayMatchId').textContent = matchId;
          showScreen('readyScreen');
          
          log('🎮 Ready screen shown. Both players need to set ready again.');
          
          // Start refreshing to get latest state
          await refresh();
          startAutoRefresh();
        } else {
          throw new Error('Match ID is missing');
        }
        
      } catch (error) {
        log('❌ Error starting rematch: ' + error.message);
        alert('Failed to start rematch. Returning to home screen.');
        
        // If any error, go back to home screen
        clearGameState();
        showScreen('homeScreen');
      }
    }
    
    function resetGameVisuals() {
      console.log('🎮 Resetting game visuals for rematch...');
      
      // Reset only visual elements, keep matchId and playerSeat
      gameState = null;
      selUp = null;
      selDown = null;
      myLastFaceDownCard = null; // Clear stored face-down card for new game
      
      // Clear timers
      clearTimers();
      
      // Reset UI elements
      document.getElementById('selUp').textContent = '-';
      document.getElementById('selDown').textContent = '-';
      
      // Clear tableaus and hands
      const tableauA = document.getElementById('tableauA');
      const tableauB = document.getElementById('tableauB');
      const handA = document.getElementById('handA');
      const handB = document.getElementById('handB');
      
      if (tableauA) tableauA.innerHTML = '';
      if (tableauB) tableauB.innerHTML = '';
      if (handA) handA.innerHTML = '';
      if (handB) handB.innerHTML = '';
      
      // Reset dot counter display
      const sharedDotCounter = document.getElementById('sharedDotCounter');
      if (sharedDotCounter) {
        sharedDotCounter.textContent = '0';
      }
      
      // Reset timer display
      const timer = document.getElementById('timer');
      if (timer) {
        timer.textContent = '';
        timer.className = 'timer-display';
      }
      
      // Hide choice modal
      // Modal removed - using central panel instead
      
      // Hide winner display
      const winnerDisplay = document.getElementById('winnerDisplay');
      if (winnerDisplay) {
        winnerDisplay.style.display = 'none';
      }
      
      // Re-enable game controls
      const controls = ['playBtn', 'autoBtn', 'chooseFaceUpBtn', 'chooseFaceDownBtn'];
      controls.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
          element.disabled = false;
          element.style.opacity = '1';
        }
      });
      
      log('Game visuals reset for rematch');
    }

    function clearGameState() {
      // Clear all game-related variables
      gameState = null;
      matchId = null;
      playerSeat = null;
      selUp = null;
      selDown = null;
      myLastFaceDownCard = null; // Clear stored face-down card
      
      // Clear timers
      clearTimers();
      
      // Stop auto refresh
      if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
        autoRefreshInterval = null;
      }
      
      // Reset UI elements
      document.getElementById('selUp').textContent = '-';
      document.getElementById('selDown').textContent = '-';
      
      // Clear tableaus and hands
      const tableauA = document.getElementById('tableauA');
      const tableauB = document.getElementById('tableauB');
      const handA = document.getElementById('handA');
      const handB = document.getElementById('handB');
      
      if (tableauA) tableauA.innerHTML = '';
      if (tableauB) tableauB.innerHTML = '';
      if (handA) handA.innerHTML = '';
      if (handB) handB.innerHTML = '';
      
      // Reset dot counter display
      const sharedDotCounter = document.getElementById('sharedDotCounter');
      if (sharedDotCounter) {
        sharedDotCounter.textContent = '0';
      }
      
      // Reset timer display
      const timer = document.getElementById('timer');
      if (timer) {
        timer.textContent = '';
        timer.className = 'timer-display';
      }
      
      // Reset player displays
      const playerAName = document.getElementById('playerAName');
      const playerBName = document.getElementById('playerBName');
      const playerAStatus = document.getElementById('playerAStatus');
      const playerBStatus = document.getElementById('playerBStatus');
      
      if (playerAName) playerAName.textContent = '';
      if (playerBName) playerBName.textContent = '';
      if (playerAStatus) playerAStatus.textContent = '';
      if (playerBStatus) playerBStatus.textContent = '';
      
      // Reset active player display
      const activePlayerText = document.querySelector('.game-header p');
      if (activePlayerText) {
        activePlayerText.textContent = 'Active Player: -';
      }
      
      // Reset phase display
      const phaseText = document.querySelector('.game-header p:last-child');
      if (phaseText) {
        phaseText.textContent = 'Phase: WAITING';
      }
      
      // Hide choice modal
      // Modal removed - using central panel instead
      
      // Hide winner display
      const winnerDisplay = document.getElementById('winnerDisplay');
      if (winnerDisplay) {
        winnerDisplay.style.display = 'none';
      }
      
      // Re-enable game controls
      const controls = ['playBtn', 'autoBtn', 'chooseFaceUpBtn', 'chooseFaceDownBtn'];
      controls.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
          element.disabled = false;
          element.style.opacity = '1';
        }
      });
      
      log('Game state cleared completely for rematch');
    }

    // Force show home screen on load
    document.addEventListener('DOMContentLoaded', function() {
      console.log('DOM loaded, showing home screen');
      showScreen('homeScreen');
    });

    // Also show home screen immediately
    showScreen('homeScreen');
  </script>
</body>
</html>

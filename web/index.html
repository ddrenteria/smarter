<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Deception Tour - New UI v17.2 - Fixed Card Interaction</title>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <script>
    // Force refresh if cached - v17.2
    console.log('Loading Deception Tour v17.2 - Fixed Card Interaction');
    if(window.location.search.indexOf('v=') === -1) {
      window.location.href = window.location.href + '?v=' + Date.now();
    }
  </script>
  <style>
    body { 
      font-family: sans-serif; 
      margin: 0; 
      padding: 20px; 
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      min-height: 100vh;
      overflow-y: auto;     /* Enable vertical scrolling */
      overflow-x: hidden;   /* Prevent horizontal scroll */
    }
    
    h1 {
      text-align: center;
      color: #333;
      margin-bottom: 30px;
      font-size: 2.5em;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    
    /* Screen Management Styles */
    .screen {
      min-height: 70vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    
    .screen-content {
      background: white;
      padding: 40px;
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
      text-align: center;
      max-width: 500px;
      width: 100%;
    }
    
    .screen-content h2 {
      color: #333;
      margin-bottom: 20px;
      font-size: 2em;
    }
    
    .screen-content p {
      color: #666;
      margin-bottom: 30px;
      font-size: 1.1em;
    }
    
    /* Home Screen Styles */
    .home-buttons {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .home-btn {
      background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%);
      color: white;
      border: none;
      padding: 20px 30px;
      border-radius: 12px;
      font-size: 1.2em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 16px rgba(33, 150, 243, 0.3);
    }
    
    .home-btn:hover {
      background: linear-gradient(135deg, #1976d2 0%, #1565c0 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(33, 150, 243, 0.4);
    }
    
    .home-btn:active {
      transform: translateY(0);
    }
    
    /* Input Group Styles */
    .input-group {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin: 20px 0;
    }
    
    .input-group input {
      padding: 15px;
      border: 2px solid #ddd;
      border-radius: 8px;
      font-size: 1em;
      transition: border-color 0.3s ease;
    }
    
    .input-group input:focus {
      outline: none;
      border-color: #2196f3;
      box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
    }
    
    .action-btn {
      background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
      color: white;
      border: none;
      padding: 15px 30px;
      border-radius: 8px;
      font-size: 1.1em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 16px rgba(76, 175, 80, 0.3);
    }
    
    .action-btn:hover {
      background: linear-gradient(135deg, #45a049 0%, #3d8b40 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
    }
    
    .secondary-btn {
      background: transparent;
      color: #666;
      border: 2px solid #ddd;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 1em;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-top: 20px;
    }
    
    .secondary-btn:hover {
      background: #f5f5f5;
      border-color: #bbb;
    }

    /* Responsive Design for Initial Screens */
    @media (min-width: 1200px) {
      .screen-content {
        max-width: 600px;
        margin: 0 auto;
      }
    }
    
    @media (max-width: 768px) {
      .screen {
        min-height: 100vh;
        padding: 10px;
      }
      
      .screen-content {
        padding: 20px;
        margin: 10px;
        max-width: none;
        width: calc(100% - 20px);
      }
      
      .screen-content h2 {
        font-size: 1.5em;
        margin-bottom: 15px;
      }
      
      .screen-content p {
        font-size: 1em;
        margin-bottom: 20px;
      }
      
      .home-btn {
        padding: 15px 20px;
        font-size: 1.1em;
      }
      
      .input-group input {
        padding: 12px;
        font-size: 16px; /* Prevents zoom on iOS */
      }
      
      .action-btn {
        padding: 12px 25px;
        font-size: 1em;
      }
      
      .secondary-btn {
        padding: 10px 20px;
        font-size: 0.9em;
      }
      
      .match-info {
        padding: 15px;
        margin: 15px 0;
      }
      
      .match-info h3 {
        font-size: 1.2em;
      }
      
      .match-info p {
        font-size: 0.9em;
      }
    }
    
    @media (max-width: 480px) {
      .screen-content {
        padding: 15px;
        margin: 5px;
        width: calc(100% - 10px);
      }
      
      .screen-content h2 {
        font-size: 1.3em;
      }
      
      .home-btn {
        padding: 12px 15px;
        font-size: 1em;
      }
      
      .input-group {
        gap: 10px;
      }
      
      .input-group input {
        padding: 10px;
      }
      
      .action-btn {
        padding: 10px 20px;
        font-size: 0.9em;
      }
      
      .secondary-btn {
        padding: 8px 15px;
        font-size: 0.8em;
      }
    }

    /* Game Styles */
    .game-container { 
      display: grid; 
      grid-template-columns: 1fr; 
      grid-template-rows: auto 1fr auto; 
      gap: 20px; 
      min-height: 100vh;
      width: 100%;
      height: 100vh;
      overflow-y: auto;     /* Allow vertical scrolling */
      overflow-x: hidden;   /* Prevent horizontal scroll */
    }
    .game-header { grid-column: 1; grid-row: 1; }
    .game-main { grid-column: 1; grid-row: 2; }
    .game-footer { grid-column: 1; grid-row: 3; }
    
    /* DISABLED: Collapsible sections removed to prevent hover interference */
    
    /* Hover effects for focus - DISABLED to prevent interference with card interaction */
    /* .game-main:hover .collapsed:not(:hover) {
      opacity: 0.2;
      transform: scale(0.9);
    } */
    
    .player-section {
      transition: all 0.3s ease;
      border-radius: 12px;
      padding: 15px;
      margin: 10px 0;
    }
    
    .player-section:hover {
      transform: scale(1.02);
      box-shadow: 0 8px 25px rgba(0,0,0,0.15);
      z-index: 10;
    }
    
    .player-section.collapsed {
      padding: 8px;
      margin: 5px 0;
    }
    
    .player-section.collapsed .hand,
    .player-section.collapsed .tableau {
      display: flex;
    }
    
    .player-section.collapsed .player-area-label {
      font-size: 0.9em;
      margin-bottom: 5px;
    }
    
    /* Card selection panel responsive */
    .card-selection-panel {
      transition: all 0.3s ease;
      position: relative;
      z-index: 20;
    }
    
    .card-selection-panel.collapsed {
      transform: scale(0.8);
      opacity: 0.7;
    }
    
    .card-selection-panel:hover {
      transform: scale(1.05);
      z-index: 30;
    }
    
    /* Floating Elements */
    .floating-counter {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 100;
      pointer-events: none;
    }
    
    .floating-timer {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 100;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 10px 15px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 14px;
    }
    
    .floating-timer .timer-label {
      font-weight: bold;
    }
    
    .floating-timer .timer {
      font-family: monospace;
      font-size: 16px;
    }
    
    
    .winner-display {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 200;
      background: white;
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      text-align: center;
    }
    
    /* Player section headers with stats */
    .player-area-label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .player-stats-inline {
      display: flex;
      gap: 15px;
      font-size: 0.9em;
      color: #666;
    }
    
    .stat-inline {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .stat-inline .label {
      font-size: 0.8em;
      color: #999;
    }
    
    .stat-inline .value {
      font-weight: bold;
      color: #333;
    }
    
    
    /* Hidden elements */
    .hidden {
      display: none !important;
    }
    
    /* Eye button styling */
    .eye-button {
      background: none;
      border: none;
      font-size: 14px;
      cursor: pointer;
      margin-left: 8px;
      padding: 2px 6px;
      border-radius: 4px;
      transition: all 0.2s;
      opacity: 0.7;
    }
    
    .eye-button:hover {
      background-color: rgba(0,0,0,0.1);
      opacity: 1;
      transform: scale(1.1);
    }
    
    /* Toast Styles */
    .toast-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: none;
    }
    
    .toast {
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      font-size: 14px;
      font-weight: 500;
      max-width: 300px;
      word-wrap: break-word;
      opacity: 0;
      transform: translateX(100%);
      transition: all 0.3s ease;
      pointer-events: auto;
      cursor: pointer;
    }
    
    .toast.show {
      opacity: 1;
      transform: translateX(0);
    }
    
    .toast.hide {
      opacity: 0;
      transform: translateX(100%);
    }
    
    .toast.success {
      background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
    }
    
    .toast.info {
      background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%);
    }
    
    .toast.warning {
      background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
    }
    
    .toast.error {
      background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
    }
    
    .toast.effect {
      background: linear-gradient(135deg, #9c27b0 0%, #7b1fa2 100%);
    }
    
    /* Responsive Game Board */
    @media (max-width: 768px) {
      .game-container {
        gap: 5px;
        min-height: 100vh;
        overflow-y: auto;
      }
      
      .game-header {
        text-align: center;
        padding: 10px;
        display: none; /* Hide on mobile to save space */
      }
      
      .game-main {
        padding: 5px;
        overflow-y: auto;
        max-height: calc(100vh - 80px);
      }
      
      .game-footer {
        padding: 10px;
        display: none; /* Hide on mobile to save space */
      }
      
      .player-section {
        margin: 3px 0;
        padding: 8px;
      }
      
      .hand {
        gap: 4px;
        flex-wrap: wrap;
      }
      
      .card {
        width: 100px !important;
        min-height: 100px !important;
        font-size: 9px !important;
        margin: 2px !important;
      }
      
      .player-section.collapsed {
        padding: 5px;
        margin: 3px 0;
      }
      
      .card-selection-panel {
        margin: 10px 5px;
        padding: 15px;
      }
      
      .card-choice-container {
        flex-direction: column;
        gap: 15px;
      }
      
      .card-choice {
        width: 100%;
        margin: 0;
      }
      
      .floating-timer {
        top: 10px;
        right: 10px;
        padding: 8px 12px;
        font-size: 12px;
      }
      
      
      .player-stats-inline {
        gap: 10px;
        font-size: 0.8em;
      }
    }
    
    /* Layout horizontal para pantallas muy bajas */
    @media (max-height: 700px) and (min-width: 1000px) {
      .game-main {
        display: flex;
        flex-direction: row;
        gap: 10px;
        align-items: flex-start;
        overflow-x: auto;
        padding: 5px;
        max-height: none;
      }
      
      .player-section {
        flex: 1;
        min-width: 250px;
        max-width: 350px;
        margin: 0;
      }
      
      .card-selection-panel {
        flex: 0 0 300px;
        order: 2;
        margin: 0;
      }
      
      /* Layout order: opponent, panel, self */
      #playerB { order: 1; }              /* Opponent Area at top */
      #cardSelectionPanel { order: 2; }   /* Choose Panel in middle */
      #playerA { order: 3; }              /* Your Area at bottom */
      
      .card-choice-container {
        flex-direction: row;
        gap: 5px;
      }
      
      /* Responsive design for choose panel */
      @media (max-width: 1200px) {
        .card-selection-panel {
          padding: 15px;
          margin: 10px;
        }
        
        .card-choice {
          min-width: 140px;
        }
        
        .card-preview {
          min-height: 80px;
          padding: 8px;
        }
        
        .legend {
          margin: 8px 0;
        }
      }
      
      @media (max-width: 900px) {
        .card-selection-panel {
          padding: 12px;
          margin: 8px;
        }
        
        .card-choice-container {
          flex-direction: column;
          gap: 10px;
          align-items: center;
        }
        
        .card-choice {
          min-width: 120px;
          max-width: 200px;
        }
        
        .card-preview {
          min-height: 60px;
          padding: 6px;
        }
        
        .choose-btn {
          padding: 8px 12px;
          font-size: 0.9em;
        }
        
        .dot-counter-display {
          right: 10px !important;  /* Right side on mobile */
          left: auto !important;    /* Clear left */
          min-width: 50px;
          max-width: 50px;
          padding: 6px;
          font-size: 0.9em;
        }
      }
      
      @media (max-width: 600px) {
        .card-selection-panel {
          padding: 10px;
          margin: 5px;
        }
        
        .card-choice {
          min-width: 100px;
          max-width: 150px;
        }
        
        .card-preview {
          min-height: 50px;
          padding: 4px;
          font-size: 0.8em;
        }
        
        .choose-btn {
          padding: 6px 10px;
          font-size: 0.8em;
        }
        
        .legend {
          margin: 5px 0;
          font-size: 0.9em;
        }
        
        .legend-item {
          margin: 0 8px;
        }
        
        .panel-header h3 {
          font-size: 1.1em;
          margin: 5px 0;
        }
        
        .dot-counter-display {
          right: 5px !important;   /* Right side on small screens */
          left: auto !important;    /* Clear left */
          min-width: 45px;
          max-width: 45px;
          padding: 4px;
          font-size: 0.8em;
        }
      }
      
      .card-choice {
        flex: 1;
        padding: 5px;
      }
      
      .card-preview {
        min-height: 50px;
      }
      
      .dot-counter-floating {
        left: 2px;
        padding: 6px;
        min-width: 70px;
        max-width: 70px;
        font-size: 0.8em;
      }
    }
    
    @media (max-width: 480px) {
      .game-container {
        gap: 5px;
      }
      
      .player-section {
        padding: 8px;
        margin: 3px 0;
      }
      
      .card-selection-panel {
        margin: 5px;
        padding: 10px;
      }
      
      .card-choice-container {
        gap: 10px;
      }
      
      .floating-timer {
        top: 5px;
        right: 5px;
        padding: 6px 10px;
        font-size: 11px;
      }
      
      .player-stats-inline {
        gap: 8px;
        font-size: 0.7em;
      }
    }
    
    /* Player Info Section - Left Side */
    .player-info-section {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 12px;
      padding: 15px;
      margin: 0; /* Sin margen porque usamos gap en el contenedor */
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      width: 90%;
    }
    
    .player-info-section h4 {
      margin: 0 0 10px 0;
      color: #333;
      font-size: 1.1em;
      font-weight: 600;
      text-align: center;
    }
    
    .player-stats {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .stat-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 10px;
      background: rgba(248, 249, 250, 0.8);
      border-radius: 6px;
      font-size: 0.9em;
    }
    
    .stat-label {
      font-weight: 500;
      color: #666;
    }
    
    .stat-value {
      font-weight: 600;
      color: #333;
    }
    
    /* Hide any remaining old player info elements */
    .player-info-horizontal {
      display: none !important;
    }
    .player-section { border: 2px solid #ddd; padding: 20px; border-radius: 12px; background: white; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    
    .card-selection-panel {
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      border: 2px solid #dee2e6;
      border-radius: 8px;
      padding: 10px;
      margin: 5px 0;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      position: relative;
      z-index: 10;
      min-height: 150px;
    }
    
    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding-bottom: 15px;
      border-bottom: 2px solid #dee2e6;
    }
    
    .panel-header h3 {
      margin: 0;
      color: #333;
      font-size: 1.5em;
      font-weight: bold;
    }
    
    .phase-info {
      background: #007bff;
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      font-weight: bold;
      font-size: 0.9em;
    }
    
    .legend {
      display: flex;
      justify-content: center;
      gap: 30px;
      margin-bottom: 20px;
      font-size: 0.9em;
      color: #666;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .legend-color {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      display: inline-block;
    }
    
    .legend-color.blue {
      background: #007bff;
    }
    
    .legend-color.orange {
      background: #ff9800;
    }
    
    .card-choice-container {
      display: flex;
      gap: 15px;              /* Reduced from 20px */
      justify-content: center;
      align-items: center;
      margin-bottom: 10px;    /* Reduced from 15px */
    }
    
    .card-choice {
      background: white;
      border: 2px solid #dee2e6;
      border-radius: 6px;     /* Reduced from 8px */
      padding: 10px;          /* Reduced from 15px */
      text-align: center;
      min-width: 160px;       /* Reduced from 200px */
      max-width: 180px;       /* Added max-width */
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .card-choice h4 {
      margin: 0 0 8px 0;      /* Reduced from 10px */
      color: #333;
      font-size: 1em;         /* Reduced from 1.1em */
    }
    
    .card-preview {
      min-height: 90px;       /* Reduced from 120px */
      border: 2px dashed #dee2e6;
      border-radius: 6px;
      padding: 8px;           /* Reduced from 10px */
      margin-bottom: 8px;     /* Reduced from 10px */
      background: #f8f9fa;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .card-preview.has-card {
      border: 2px solid #007bff;
      background: white;
    }
    
    .placeholder {
      color: #999;
      font-style: italic;
    }
    
    .choose-btn {
      background: #28a745;
      color: white;
      border: none;
      padding: 6px 12px;      /* Reduced from 8px 16px */
      border-radius: 4px;     /* Reduced from 6px */
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 0.85em;      /* Reduced from 0.9em */
    }
    
    .choose-btn:hover:not(:disabled) {
      background: #218838;
    }
    
    .choose-btn:disabled {
      background: #6c757d;
      cursor: not-allowed;
    }
    
    .play-controls {
      background: white;
      border-radius: 8px;
      padding: 10px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      text-align: center;
    }
    
    .selected-cards {
      display: flex;
      gap: 20px;
      justify-content: center;
      margin-bottom: 15px;
    }
    
    .selected-card {
      background: white;
      border: 2px solid #007bff;
      border-radius: 10px;
      padding: 15px;
      text-align: center;
      min-width: 200px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .selected-card h4 {
      margin: 0 0 10px 0;
      color: #007bff;
      font-size: 1em;
    }
    
    .card-preview {
      min-height: 100px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f8f9fa;
      border-radius: 8px;
      border: 1px dashed #6c757d;
      color: #6c757d;
      font-style: italic;
    }
    
    .card-preview.has-card {
      background: white;
      border: 2px solid #28a745;
      color: #333;
      font-style: normal;
    }
    
    .play-controls {
      text-align: center;
    }
    
    .play-controls .status {
      margin-bottom: 10px;
      font-weight: bold;
      color: #495057;
    }
    
    .preview-card {
      text-align: center;
    }
    
    .preview-name {
      font-weight: bold;
      font-size: 1.1em;
      color: #333;
      margin-bottom: 5px;
    }
    
    .preview-tags {
      font-size: 0.9em;
      color: #666;
      font-style: italic;
    }
    
    .central-card {
      background: white;
      border: 2px solid #dee2e6;
      border-radius: 10px;
      padding: 15px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      transition: all 0.3s ease;
      cursor: pointer;
    }
    
    .central-card:hover {
      border-color: #007bff;
      box-shadow: 0 4px 8px rgba(0,123,255,0.2);
    }
    
    .central-card.selected {
      border-color: #28a745;
      background: #f8fff9;
      box-shadow: 0 4px 8px rgba(40,167,69,0.3);
    }
    
    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .card-header h4 {
      margin: 0;
      color: #333;
      font-size: 1.1em;
    }
    
    .card-count {
      background: #007bff;
      color: white;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 0.8em;
      font-weight: bold;
    }
    
    .card-tags {
      color: #666;
      font-size: 0.9em;
      font-style: italic;
      margin-bottom: 15px;
    }
    
    .card-tiers {
      margin-bottom: 15px;
    }
    
    .tier {
      margin-bottom: 10px;
      padding: 8px;
      background: #f8f9fa;
      border-radius: 6px;
      border-left: 3px solid #007bff;
    }
    
    .tier-header {
      font-weight: bold;
      color: #007bff;
      font-size: 0.9em;
      margin-bottom: 5px;
    }
    
    .tier-actions {
      font-size: 0.8em;
      color: #555;
    }
    
    .action {
      margin-bottom: 3px;
      padding-left: 10px;
    }
    
    .card-actions {
      display: flex;
      gap: 8px;
    }
    
    .card-actions button {
      flex: 1;
      padding: 8px 12px;
      border: none;
      border-radius: 6px;
      font-size: 0.8em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .select-face-up {
      background: #28a745;
      color: white;
    }
    
    .select-face-up:hover {
      background: #218838;
    }
    
    .select-face-down {
      background: #ffc107;
      color: #212529;
    }
    
    .select-face-down:hover {
      background: #e0a800;
    }
    
    /* Drag and Drop Styles */
    .hand-card {
      cursor: grab;
      transition: all 0.3s ease;
    }
    
    .hand-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    
    .hand-card.dragging {
      opacity: 0.5;
      transform: rotate(5deg);
    }
    
    .card-preview.drag-over {
      border-color: #007bff;
      background: #e3f2fd;
      border-style: solid;
    }
    
    .card-preview.drag-over .placeholder {
      color: #007bff;
      font-weight: bold;
    }
    
    .card-preview.has-card .placeholder {
      display: none;
    }
    
    .card-preview.has-card {
      border-style: solid;
    }
    
    .card-preview-content {
      width: 100%;
      text-align: left;
    }
    
    .card-preview-name {
      font-weight: bold;
      color: #333;
      margin-bottom: 6px;
      font-size: 1em;
    }
    
    .card-preview-tiers {
      font-size: 0.8em;
    }
    
    .tier-preview {
      margin-bottom: 2px;     /* Reduced from 4px */
      padding: 2px;           /* Reduced from 3px */
      background: #f8f9fa;
      border-radius: 3px;
      border-left: 3px solid #007bff;
      font-size: 0.85em;      /* Smaller text */
    }
    
    .tier-preview.self-effect {
      border-left-color: #007bff;
    }
    
    .tier-preview.opponent-effect {
      border-left-color: #ff9800;
    }
    
    .tier-preview-header {
      font-weight: bold;
      color: #007bff;
      font-size: 0.8em;
      margin-bottom: 3px;
    }
    
    .tier-preview-action {
      color: #555;
      font-size: 0.8em;
    }
    
    .mystery-card {
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      border: 2px dashed #6c757d;
    }
    
    .mystery-card .card-preview-name {
      color: #6c757d;
      font-style: italic;
    }
    
    .mystery-card .tier-preview {
      background: #f8f9fa;
      border-left-color: #6c757d;
    }
    
    .mystery-card .tier-preview-header {
      color: #6c757d;
    }
    
    .mystery-card .tier-preview-action {
      color: #6c757d;
      font-style: italic;
    }
    .player-section.active { background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); border-color: #2196f3; box-shadow: 0 4px 16px rgba(33, 150, 243, 0.3); }
    .player-section h3 { margin: 0 0 15px 0; font-size: 1.2em; color: #333; }
    .player-section h4 { margin: 0 0 10px 0; font-size: 1em; color: #333; font-weight: 600; }
    .player-area-label { 
      display: inline-block; 
      background: #2196f3; 
      color: white; 
      padding: 4px 12px; 
      border-radius: 20px; 
      font-size: 0.8em; 
      margin-bottom: 10px; 
    }
    .player-area-label.opponent { background: #ff5722; }
    
    .hand-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }
    
    .hand-header h4 {
      margin: 0;
    }
    
    .toggle-hand-btn {
      background: #f8f9fa;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 4px 8px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s ease;
      color: #333;
      font-weight: bold;
    }
    
    .toggle-hand-btn:hover {
      background: #e9ecef;
      border-color: #adb5bd;
      transform: scale(1.1);
    }
    
    .opponent-hand.hidden {
      display: none !important;
    }
    
    .panel-header {
      text-align: center;
      margin-bottom: 10px;
    }
    
    .panel-header h3 {
      margin: 0;
    }
    
    
    .dot-counter-display {
      position: fixed !important;
      right: 20px !important;           /* Right side with padding */
      top: 50% !important;             /* Vertically centered */
      transform: translateY(-50%) !important; /* Perfect vertical center */
      text-align: center;
      min-width: 60px;                  /* Narrower */
      max-width: 60px;
      background: rgba(0, 0, 0, 0.1) !important;  /* Almost transparent dark background */
      border: 1px solid rgba(255, 255, 255, 0.2) !important; /* Subtle transparent border */
      border-radius: 8px;
      padding: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1) !important; /* Subtle shadow */
      z-index: 99999 !important;        /* High z-index */
      backdrop-filter: blur(3px);       /* Light glass effect */
    }
    
    .visual-counter-display {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
    }
    
    .visual-counter-display .player-name {
      font-size: 0.6em;
      font-weight: normal;
      color: rgba(255, 255, 255, 0.6);  /* More subtle white text */
      margin: 2px 0;
    }
    
    .active-indicator {
      font-size: 0.8em;
      margin-left: 5px;
      animation: pulse 1s infinite;
    }
    
    .player-name-pill {
      display: inline-block;
      background: #6c757d;
      color: white;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 0.7em;
      font-weight: normal;
      margin-left: 10px;
      margin-bottom: 8px;
    }
    
    /* CSS-only reordering for Player A's view of Player B */
    .player-a-view-opponent {
      display: flex;
      flex-direction: column;
    }
    
    .player-a-view-opponent .player-area-label {
      order: 1;
    }
    
    .player-a-view-opponent .player-name-pill {
      order: 2;
    }
    
    /* Swap the h4 elements: make "Hand:" (originally 2nd) appear first */
    .player-a-view-opponent h4:nth-of-type(2) {
      order: 3; /* "Hand:" header */
    }
    
    .player-a-view-opponent #handB {
      order: 4; /* Hand div */
    }
    
    /* Make "Tableau:" (originally 1st) appear second */
    .player-a-view-opponent h4:nth-of-type(1) {
      order: 5; /* "Tableau:" header */
    }
    
    .player-a-view-opponent #tableauB {
      order: 6; /* Tableau div */
    }
    
    .player-a-view-opponent .status-effects {
      order: 8;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    /* Horizontal player info layout */
    .player-info-horizontal {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.05);
      border-radius: 8px;
      border: 1px solid rgba(0, 0, 0, 0.1);
    }
    
    .player-info-horizontal h3 {
      margin: 0;
      font-size: 1.1em;
      color: #333;
      font-weight: 600;
    }
    
    .player-stats {
      display: flex;
      gap: 15px;
      align-items: center;
    }
    
    .player-stats .status {
      margin: 0;
      font-size: 0.9em;
      color: #555;
      background: rgba(0, 0, 0, 0.2);
      padding: 4px 8px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .hand { display: flex; gap: 8px; margin: 10px 0; flex-wrap: wrap; }
    .card {
      width: 140px;
      min-height: 160px;
      padding: 8px;
      border: 2px solid #888;
      border-radius: 8px;
      cursor: pointer !important;
      pointer-events: auto !important;
      background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
      display: flex;
      flex-direction: column;
      align-items: stretch;
      justify-content: flex-start;
      text-align: center;
      transition: all 0.3s ease;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      position: relative;
      font-size: 11px;
      overflow: hidden;
    }
    
    /* Recently added card indicator */
    .card.newly-added {
      animation: glow 2s ease-in-out;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
      border: 2px solid #ffd700;
      transform: scale(1.05);
      position: relative;
    }
    
    .card.newly-added::before {
      content: "✨";
      position: absolute;
      top: -10px;
      right: -10px;
      background: #ffd700;
      color: #000;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
      z-index: 10;
    }
    
    @keyframes glow {
      0%, 100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8); }
      50% { box-shadow: 0 0 30px rgba(255, 215, 0, 1); }
    }
    
    .card:hover { 
      background: #f0f8ff; 
      border-color: #2196f3; 
      transform: translateY(-2px) scale(1.15);
      box-shadow: 0 8px 25px rgba(0,0,0,0.25);
      z-index: 100;
      font-size: 13px;
      width: 180px;
      padding: 12px;
      overflow: hidden;
    }
    
    .card:hover .card-title {
      font-size: 14px;
      margin-bottom: 6px;
    }
    
    .card:hover .card-effects {
      font-size: 11px;
    }
    
    .card:hover .card-effects li {
      margin: 2px 0;
      line-height: 1.2;
    }
    .card.selected { 
      background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); 
      border-color: #2196f3; 
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
    }
    .card-title { font-weight: bold; margin-bottom: 4px; font-size: 12px; }
    .card-effects { list-style: none; padding: 0; margin: 0; font-size: 10px; text-align: left; }
    .card-effects li { color: #000; }
    .card-effects li.active { color: #28a745; font-weight: bold; }
    
    /* Effect highlighting for choose modal */
    .card-effects li.effect-mine { 
      color: #3da7ff !important; 
      font-weight: bold; 
      background: rgba(61, 167, 255, 0.1);
      padding: 2px 6px;
      border-radius: 4px;
      margin: 1px 0;
    }
    .card-effects li.effect-opponent { 
      color: #ff9d46 !important; 
      font-weight: bold; 
      background: rgba(255, 157, 70, 0.1);
      padding: 2px 6px;
      border-radius: 4px;
      margin: 1px 0;
    }
    
    /* Tier highlighting for central panel */
    .tier-preview.effect-mine {
      border: 2px solid #3da7ff !important;
      background: rgba(61, 167, 255, 0.1) !important;
      box-shadow: 0 0 8px rgba(61, 167, 255, 0.3);
    }
    .tier-preview.effect-opponent {
      border: 2px solid #ff9d46 !important;
      background: rgba(255, 157, 70, 0.1) !important;
      box-shadow: 0 0 8px rgba(255, 157, 70, 0.3);
    }
    
    /* Effect coloring for hand cards */
    .card-effects li.effect-mine {
      background: rgba(61, 167, 255, 0.15);
      border-left: 3px solid #3da7ff;
      padding: 2px 4px;
      margin: 1px 0;
      border-radius: 3px;
    }
    
    .card-effects li.effect-opponent {
      background: rgba(255, 157, 70, 0.15);
      border-left: 3px solid #ff9d46;
      padding: 2px 4px;
      margin: 1px 0;
      border-radius: 3px;
    }
    
    .card-effects li.effect-both {
      background: linear-gradient(90deg, rgba(61, 167, 255, 0.15) 50%, rgba(255, 157, 70, 0.15) 50%);
      border-left: 3px solid;
      border-image: linear-gradient(180deg, #3da7ff 50%, #ff9d46 50%) 1;
      padding: 2px 4px;
      margin: 1px 0;
      border-radius: 3px;
    }
    
    /* Legend styling for color reference */
    .legend {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin: 10px 0;
      font-size: 0.9em;
      font-weight: bold;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    
    .legend-dot {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      display: inline-block;
      border: 2px solid rgba(255, 255, 255, 0.3);
    }
    
    .legend-dot.you {
      background: #3da7ff;
      box-shadow: 0 0 6px rgba(61, 167, 255, 0.6);
      border-color: #3da7ff;
    }
    
    .legend-dot.opp {
      background: #ff9d46;
      box-shadow: 0 0 6px rgba(255, 157, 70, 0.6);
      border-color: #ff9d46;
    }
    
    .legend-item {
      color: #333;  /* Neutral text color, let the dots show the colors */
      font-weight: 600;
    }
    
    /* Play button styling */
    .play-controls {
      text-align: center;
      margin-top: 10px;
    }
    
    .play-selected-btn {
      background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-weight: bold;
      font-size: 1em;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
      min-width: 150px;
    }
    
    .play-selected-btn:hover {
      background: linear-gradient(135deg, #218838 0%, #1abc9c 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(40, 167, 69, 0.4);
    }
    
    .play-selected-btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 8px rgba(40, 167, 69, 0.3);
    }
    
    /* Recently added card highlighting */
    .newly-added {
      animation: newCardGlow 2s ease-in-out;
      border: 3px solid #ffd700 !important;
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.6) !important;
      background: rgba(255, 215, 0, 0.1) !important;
    }
    
    @keyframes newCardGlow {
      0% {
        border-color: #ffd700;
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        background: rgba(255, 215, 0, 0.2);
      }
      50% {
        border-color: #ffed4e;
        box-shadow: 0 0 25px rgba(255, 237, 78, 0.9);
        background: rgba(255, 237, 78, 0.15);
      }
      100% {
        border-color: #ffd700;
        box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
        background: rgba(255, 215, 0, 0.1);
      }
    }
    .tableau { display: flex; gap: 4px; margin: 10px 0; flex-wrap: wrap; }
    .tableau-card {
      width: 140px;
      min-height: 160px;
      padding: 8px;
      border: 2px solid #ccc;
      border-radius: 8px;
      background: linear-gradient(135deg, #f9f9f9 0%, #f0f0f0 100%);
      font-size: 11px;
      position: relative;
      display: flex;
      flex-direction: column;
      text-align: center;
      transition: all 0.3s ease;
      cursor: pointer;
      overflow: hidden;
    }
    
    .tableau-card:hover {
      transform: translateY(-2px) scale(1.15);
      box-shadow: 0 8px 25px rgba(0,0,0,0.25);
      z-index: 100;
      font-size: 13px;
      width: 180px;
      padding: 12px;
      border-color: #4caf50;
      background: linear-gradient(135deg, #f1f8e9 0%, #e8f5e8 100%);
      overflow: hidden;
    }
    
    .tableau-card:hover .card-title {
      font-size: 14px;
      margin-bottom: 6px;
    }
    
    .tableau-card:hover .card-effects {
      font-size: 11px;
    }
    
    .tableau-card:hover .card-effects li {
      margin: 2px 0;
      line-height: 1.2;
    }
    
    /* Recently added tableau card indicator */
    .tableau-card.newly-added {
      animation: glow 2s ease-in-out;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
      border: 2px solid #ffd700;
      transform: scale(1.05);
      position: relative;
    }
    
    .tableau-card.newly-added::before {
      content: "✨";
      position: absolute;
      top: -10px;
      right: -10px;
      background: #ffd700;
      color: #000;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
      z-index: 10;
    }
    .stacked-card { position: relative; }
    .card-count-badge { 
      position: absolute; 
      top: -8px; 
      right: -8px; 
      background: #ff4444; 
      color: white; 
      border-radius: 50%; 
      width: 20px; 
      height: 20px; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      font-size: 10px; 
      font-weight: bold; 
      border: 2px solid white;
    }
    .card-tooltip { 
      position: relative; 
      transition: all 0.3s ease;
      cursor: pointer;
    }
    .card-tooltip:hover .tooltip-content { display: none; }
    .card-tooltip:hover {
      transform: translateY(-2px) scale(1.15);
      box-shadow: 0 8px 25px rgba(0,0,0,0.25);
      z-index: 100;
    }
    .revealed-card:hover {
      transform: translateY(-2px) scale(1.15);
      box-shadow: 0 8px 25px rgba(0,0,0,0.25);
      z-index: 100;
      width: 180px !important;
      font-size: 13px;
      padding: 12px;
      overflow: hidden;
    }
    .tooltip-content { 
      display: none; position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); 
      background: #333; color: white; padding: 8px; border-radius: 4px; white-space: nowrap; 
      z-index: 1000; font-size: 12px; max-width: 300px; white-space: normal;
    }
    .log { white-space: pre-wrap; font-family: monospace; max-height: 200px; overflow: auto; border: 1px solid #eee; padding: 8px; background: #f9f9f9; }
    .status { font-weight: bold; margin: 10px 0; }
    .choice-cards {
      display: flex;
      gap: 20px;
      margin: 10px 0;
    }
    .choice-card {
      border: 2px solid #28a745;
      border-radius: 8px;
      padding: 15px;
      background: #f8f9fa;
      text-align: center;
      flex: 1;
    }
    .choice-card button {
      margin-top: 10px;
      padding: 8px 16px;
      background: #28a745;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .choice-card button:hover {
      background: #218838;
    }
    .shared-counter {
      text-align: center;
      margin: 15px 0;
      padding: 15px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 12px;
      color: white;
      min-width: 180px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    .dot-display {
      margin: 15px 0;
    }
    .dot-value {
      font-size: 48px;
      font-weight: bold;
      margin: 10px 0;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    
    .visual-counter {
      font-size: 24px !important;
    }
    
    .visual-counter-display {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }
    
    .player-name {
      font-size: 12px;
      font-weight: bold;
      color: rgba(255, 255, 255, 0.9);
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    }
    
    .stones-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      font-size: 20px;
    }
    
    .stone {
      display: inline-block;
      width: 16px;
      height: 16px;
      line-height: 16px;
      text-align: center;
      background: rgba(255, 255, 255, 0.15);
      border: 1px solid rgba(255, 255, 255, 0.25);
      border-radius: 50%;
      transition: all 0.3s ease;
      margin: 1px;
      font-size: 0.9em;
    }
    
    .stone.active {
      color: #ffd700;
      background: rgba(255, 215, 0, 0.3);
      border: 2px solid #ffd700;
      text-shadow: 0 0 8px rgba(255, 215, 0, 0.8);
      transform: scale(1.3);
      box-shadow: 0 0 12px rgba(255, 215, 0, 0.6);
    }
    
    .stone.inactive {
      color: rgba(255, 255, 255, 0.4);
      background: rgba(255, 255, 255, 0.1);
    }
    
    .stone.center {
      color: rgba(255, 255, 255, 0.8);
      background: rgba(255, 255, 255, 0.2);
      border: 2px solid rgba(255, 255, 255, 0.5);
      font-weight: bold;
    }
    .dot-labels {
      display: flex;
      justify-content: space-between;
      font-size: 14px;
      margin-top: 10px;
    }
    .player-label {
      background: rgba(255,255,255,0.2);
      padding: 5px 10px;
      border-radius: 15px;
    }
    .neutral-label {
      background: rgba(255,255,255,0.3);
      padding: 5px 10px;
      border-radius: 15px;
      font-weight: bold;
    }
    .winner-display {
      margin-top: 15px;
      padding: 15px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      border: 2px solid #fff;
    }
    .winner-display h2 {
      margin: 0;
      color: #fff;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }
    
    .winner-display .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      text-decoration: none;
      display: inline-block;
      margin: 0 5px;
    }

    .winner-display .btn-primary {
      background: linear-gradient(45deg, #4CAF50, #45a049);
      color: white;
    }

    .winner-display .btn-primary:hover {
      background: linear-gradient(45deg, #45a049, #3d8b40);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
    }

    .winner-display .btn-secondary {
      background: linear-gradient(45deg, #6c757d, #5a6268);
      color: white;
    }

    .winner-display .btn-secondary:hover {
      background: linear-gradient(45deg, #5a6268, #495057);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(108, 117, 125, 0.4);
    }
    /* Enhanced Timer Styling */
    .timer-display {
      display: inline-block;
      padding: 8px 16px;
      border-radius: 20px;
      font-weight: bold;
      font-size: 1.1em;
      transition: all 0.3s ease;
      background: #4caf50;
      color: white;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    .timer-display.warning { background: #ff9800; }
    .timer-display.danger { background: #f44336; animation: pulse 1s infinite; }
    @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
    
    /* Enhanced Choice Modal - Bottom Sheet Style */
    .choice-modal {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 45vh;
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      border-top: 4px solid #2196f3;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transform: translateY(100%);
      transition: transform 0.3s ease-in-out;
      box-shadow: 0 -8px 32px rgba(0,0,0,0.3);
    }
    .choice-modal.show {
      transform: translateY(0);
    }
    .choice-modal-content {
      background: transparent;
      padding: 20px;
      width: 100%;
      max-width: 800px;
    }
    
    /* Desktop sidebar variant */
    @media (min-width: 900px) {
      .choice-modal {
        position: fixed;
        top: 0;
        right: 0;
        width: 35%;
        height: 100vh;
        left: auto;
        bottom: auto;
        transform: translateX(100%);
        border-top: none;
        border-left: 4px solid #2196f3;
      }
      .choice-modal.show {
        transform: translateX(0);
      }
    }
    
    .choice-btn {
      background: #2196f3;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 1.1em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 2px 8px rgba(33, 150, 243, 0.3);
    }
    
    .choice-btn:hover {
      background: #1976d2;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
    }
    
    .choice-btn:active {
      transform: translateY(0);
    }
    
    /* Layout specific styles */
    .game-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 0;
    }
    
    .timer-display-container {
      margin-top: 15px;
      padding: 12px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      text-align: center;
    }
    
    .timer-display-container .status {
      margin-bottom: 10px;
      font-weight: bold;
    }
    
    /* Recent Effects Full Width Section */
    .recent-effects-full-width {
      grid-column: 1 / -1; /* Span full width */
      margin: 0 0 15px 0; /* Margen inferior para separar del contenido */
      padding: 15px;
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      border-radius: 16px;
      border: 2px solid #dee2e6;
      height: 150px; /* Altura reducida para evitar solapamiento */
      overflow: hidden;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    
    .recent-effects-header {
      margin-bottom: 15px;
      border-bottom: 2px solid #dee2e6;
      padding-bottom: 10px;
    }
    
    .recent-effects-header h3 {
      margin: 0;
      color: #495057;
      font-size: 1.2em;
      text-align: center;
      font-weight: 600;
      text-shadow: none;
    }
    
    .effect-feedback-list-horizontal {
      display: flex;
      flex-direction: column;
      gap: 4px;
      height: 90px; /* Altura reducida para coincidir con el panel más pequeño */
      overflow-y: auto;
      padding-right: 8px;
      padding: 5px 0;
    }
    
    .effect-feedback-list-horizontal::-webkit-scrollbar {
      width: 8px;
    }
    
    .effect-feedback-list-horizontal::-webkit-scrollbar-track {
      background: #e9ecef;
      border-radius: 4px;
    }
    
    .effect-feedback-list-horizontal::-webkit-scrollbar-thumb {
      background: #6c757d;
      border-radius: 4px;
    }
    
    .effect-feedback-list-horizontal::-webkit-scrollbar-thumb:hover {
      background: #495057;
    }
    
    .effect-item {
      padding: 10px 15px;
      background: white;
      color: #333;
      border-radius: 8px;
      border-left: 4px solid #007bff;
      font-size: 0.85em;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      word-wrap: break-word;
      flex-shrink: 0;
      margin-bottom: 6px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      transition: all 0.2s ease;
      position: relative;
    }
    
    .effect-item:hover {
      transform: translateX(4px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
    }
    
    /* Player Status Effects Display */
    .status-effects {
      margin-top: 10px;
      padding: 10px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .status-effects h4 {
      margin: 0 0 8px 0;
      color: #fff;
      font-size: 0.9em;
      font-weight: bold;
    }
    
    .status-effects-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    
    .status-effect {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      font-size: 0.75em;
      color: #fff;
      border: 1px solid rgba(255, 255, 255, 0.3);
    }
    
    .status-effect.shield {
      background: rgba(76, 175, 80, 0.8);
      border-color: #4caf50;
    }
    
    .status-effect.thorns {
      background: rgba(255, 152, 0, 0.8);
      border-color: #ff9800;
    }
    
    .status-effect.reflect {
      background: rgba(156, 39, 176, 0.8);
      border-color: #9c27b0;
    }
    
    .status-effect.random {
      background: rgba(255, 193, 7, 0.8);
      border-color: #ffc107;
      color: #000;
    }
    
    .status-effect.global {
      background: rgba(244, 67, 54, 0.8);
      border-color: #f44336;
    }
    
    .status-effect-icon {
      font-size: 0.8em;
    }
    
    .status-effect-duration {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      padding: 1px 4px;
      font-size: 0.7em;
      font-weight: bold;
    }
    
    /* Status Effect Tooltips */
    .status-effect {
      position: relative;
      cursor: help;
    }
    
    .status-effect-tooltip {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 0.75em;
      white-space: nowrap;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s, visibility 0.2s;
      margin-bottom: 5px;
      max-width: 250px;
      white-space: normal;
      text-align: center;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    
    .status-effect-tooltip::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 5px solid transparent;
      border-top-color: rgba(0, 0, 0, 0.9);
    }
    
    .status-effect:hover .status-effect-tooltip {
      opacity: 1;
      visibility: visible;
    }
    
    .effect-item.heal {
      border-left-color: #28a745;
      background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
    }
    
    .effect-item.damage {
      border-left-color: #dc3545;
      background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
    }
    
    .effect-item.dot-change {
      border-left-color: #ffc107;
      background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
    }
    
    /* Push number styling */
    .push-positive {
      color: #4caf50;
      font-weight: bold;
    }
    
    .push-negative {
      color: #f44336;
      font-weight: bold;
    }
    
    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(-20px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }
    
    
    .enemy-area {
      margin-bottom: 20px;
    }
    
    .player-area {
      margin-top: 20px;
    }
    
    /* Play Cards Section */
    .play-cards-section {
      margin-top: 20px;
      padding: 15px;
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      border-radius: 8px;
      border: 2px solid #dee2e6;
    }
    
    .play-selected-btn {
      background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 1.1em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
      width: 100%;
      margin-top: 10px;
    }
    
    .play-selected-btn:hover {
      background: linear-gradient(135deg, #218838 0%, #1aa179 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(40, 167, 69, 0.4);
    }
    
    .play-selected-btn:active {
      transform: translateY(0);
    }
    
    .play-selected-btn:disabled {
      background: #6c757d;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    /* Modal Card Display */
    .modal-card-display {
      background: white;
      border: 2px solid #ddd;
      border-radius: 8px;
      padding: 15px;
      margin: 10px 0;
      min-height: 120px;
      display: flex;
      flex-direction: column;
    }
    
    .modal-card-title {
      font-weight: bold;
      font-size: 1.1em;
      color: #333;
      margin-bottom: 10px;
      text-align: center;
    }
    
    .modal-card-effects {
      font-size: 0.9em;
      color: #666;
      line-height: 1.4;
    }
    
    .modal-card-effects ul {
      margin: 0;
      padding-left: 20px;
      list-style-type: disc;
    }
    
    .modal-card-effects li {
      margin: 4px 0;
    }
    
    .modal-card-title.hidden-card {
      color: #666 !important;
      font-style: italic !important;
      position: relative;
    }
    
    .modal-card-title.hidden-card::after {
      content: " (Hidden)";
      font-size: 0.8em;
      color: #999;
    }

    /* Ready Screen Styles */
    .match-info {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 8px;
      margin: 20px 0;
    }
    
    .copy-btn {
      background: #ff9800;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 0.9em;
      cursor: pointer;
      margin-left: 10px;
      transition: all 0.3s ease;
    }
    
    .copy-btn:hover {
      background: #f57c00;
    }
    
    .players-status {
      margin: 30px 0;
    }
    
    .player-status {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 15px;
      margin: 10px 0;
      background: #f8f9fa;
      border-radius: 8px;
      border-left: 4px solid #2196f3;
    }
    
    .player-label {
      font-weight: bold;
      color: #333;
    }
    
    .ready-status {
      font-weight: bold;
    }
    
    .ready-status.ready {
      color: #4caf50;
    }
    
    .ready-status.not-ready {
      color: #f44336;
    }
    
    .ready-btn {
      background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
      color: white;
      border: none;
      padding: 20px 40px;
      border-radius: 12px;
      font-size: 1.3em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 16px rgba(76, 175, 80, 0.3);
      margin: 20px 0;
    }
    
    .ready-btn:hover {
      background: linear-gradient(135deg, #45a049 0%, #3d8b40 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
    }
    
    .waiting-message {
      color: #666;
      font-style: italic;
      margin-top: 20px;
    }
    
    /* Timer configuration styling */
    .timer-config {
      background: rgba(255, 255, 255, 0.9);
      border: 2px solid #ddd;
      border-radius: 12px;
      padding: 20px;
      margin: 20px 0;
      text-align: center;
    }
    
    .timer-config h3 {
      margin: 0 0 15px 0;
      color: #333;
      font-size: 1.2em;
    }
    
    .timer-inputs {
      display: flex;
      gap: 20px;
      justify-content: center;
      flex-wrap: wrap;
    }
    
    .timer-input-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      min-width: 180px;
    }
    
    .timer-input-group label {
      font-weight: bold;
      color: #555;
      font-size: 0.9em;
    }
    
    .timer-input-group select {
      padding: 8px 12px;
      border: 2px solid #ddd;
      border-radius: 6px;
      background: white;
      font-size: 0.9em;
      cursor: pointer;
      transition: border-color 0.2s ease;
    }
    
    .timer-input-group select:focus {
      outline: none;
      border-color: #4CAF50;
      box-shadow: 0 0 5px rgba(76, 175, 80, 0.3);
    }
    
    /* Active Effects Styling */
    .status-effects {
      margin-top: 15px;
      padding: 10px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .status-effects h4 {
      margin: 0 0 10px 0;
      font-size: 0.9em;
      color: #ccc;
      text-align: center;
    }
    
    .status-effects-list {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    
    .status-effect {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 5px 8px;
      border-radius: 4px;
      font-size: 0.8em;
      font-weight: bold;
    }
    
    .status-effect.self-effect {
      background: rgba(76, 175, 80, 0.2);
      border: 1px solid rgba(76, 175, 80, 0.4);
      color: #4CAF50;
    }
    
    .status-effect.opponent-effect {
      background: rgba(255, 152, 0, 0.2);
      border: 1px solid rgba(255, 152, 0, 0.4);
      color: #FF9800;
    }
    
    .effect-name {
      flex: 1;
      text-align: left;
    }
    
    .effect-value {
      font-weight: bold;
      min-width: 30px;
      text-align: right;
    }
    
    .no-effects {
      text-align: center;
      color: #666;
      font-style: italic;
      font-size: 0.8em;
      padding: 8px;
    }
  </style>
</head>
<body>
  
  <!-- Screen 1: Home Screen -->
  <div id="homeScreen" class="screen" style="display: block;">
    <div class="screen-content">
      <h2>🎮 Welcome to Deception Tour!</h2>
      <p>Choose how you want to play:</p>
      <div class="home-buttons">
        <button id="createMatchBtn" class="home-btn">🏢 Create Match</button>
        <button id="joinMatchBtn" class="home-btn">🔗 Join Match</button>
        <button id="playBotBtn" class="home-btn">🤖 Play vs Bot</button>
    </div>
    </div>
  </div>

  <!-- Screen 2: Create Match Screen -->
  <div id="createMatchScreen" class="screen" style="display: none;">
    <div class="screen-content">
      <h2>Create New Match</h2>
      <p>Enter your name to create a match:</p>
      <div class="input-group">
        <input id="createPlayerName" type="text" placeholder="Your name (max 15 chars)" maxlength="15" />
        <button id="confirmCreateBtn" class="action-btn">Create Match</button>
      </div>
      <button id="backToHomeBtn" class="secondary-btn">← Back to Home</button>
    </div>
  </div>
  
  <!-- Screen 2: Join Match Screen -->
  <div id="joinMatchScreen" class="screen" style="display: none;">
    <div class="screen-content">
      <h2>Join Existing Match</h2>
      <p>Enter the match ID and your name:</p>
      <div class="input-group">
        <input id="joinMatchId" type="text" placeholder="Match ID" />
        <input id="joinPlayerName" type="text" placeholder="Your name (max 15 chars)" maxlength="15" />
        <button id="confirmJoinBtn" class="action-btn">Join Match</button>
      </div>
      <button id="backToHomeBtn2" class="secondary-btn">← Back to Home</button>
    </div>
  </div>

  <!-- Screen 3: Ready Screen -->
  <div id="readyScreen" class="screen" style="display: none;">
    <div class="screen-content">
      <h2>Waiting Room</h2>
      <div class="match-info">
        <p><strong>Match IDD:</strong> <span id="displayMatchId">-</span></p>
        <button id="copyMatchIdBtn" class="copy-btn">📋 Copy Match ID</button>
      </div>
      <div class="players-status">
        <div class="player-status">
          <span class="player-label">Player A:</span>
          <span id="playerAName">-</span>
          <span id="playerAReady" class="ready-status">(Not Ready)</span>
        </div>
        <div class="player-status">
          <span class="player-label">Player B:</span>
          <span id="playerBName">-</span>
          <span id="playerBReady" class="ready-status">(Not Ready)</span>
        </div>
      </div>
      
      <!-- Timer Configuration -->
      <div class="timer-config" id="timerConfig" style="display: none;">
        <h3>⏱️ Timer Settings</h3>
        <div class="timer-inputs">
          <div class="timer-input-group">
            <label for="playTwoCardsTime">Play Two Cards Phase:</label>
            <select id="playTwoCardsTime">
              <option value="30">30 seconds</option>
              <option value="60">60 seconds</option>
              <option value="90">90 seconds</option>
              <option value="120" selected>2 minutes</option>
              <option value="180">3 minutes</option>
              <option value="300">5 minutes</option>
            </select>
          </div>
          <div class="timer-input-group">
            <label for="opponentPickTime">Opponent Pick Phase:</label>
            <select id="opponentPickTime">
              <option value="15">15 seconds</option>
              <option value="30">30 seconds</option>
              <option value="45">45 seconds</option>
              <option value="60" selected>60 seconds</option>
              <option value="120">2 minutes</option>
            </select>
          </div>
        </div>
      </div>
      
      <button id="readyBtn" class="ready-btn" style="display: none;">I'm Ready!</button>
      <div id="waitingMessage" class="waiting-message">Waiting for both players to be ready...</div>
    </div>
  </div>

  <!-- Screen 4: Game Screen -->
  <div id="gameScreen" class="screen" style="display: none;">
    <div class="game-container" id="gameContainer">
    
    <!-- Floating Counter - Over the game board -->
    <div class="floating-counter">
      <div id="visualCounter" class="visual-counter">
        <!-- Stones will be generated here -->
      </div>
    </div>
    
    <!-- Timer - Top right corner -->
    <div class="floating-timer">
      <div class="timer-label">Timer:</div>
      <div id="gameTimer" class="timer">0s</div>
    </div>
    
    <!-- Winner Display - Center -->
    <div id="winnerDisplay" class="winner-display" style="display: none;">
      <h2 id="winnerText">Game Over!</h2>
      <div style="margin-top: 15px;">
        <button id="rematchBtn" class="btn btn-primary" style="margin-right: 10px;">🔄 Rematch</button>
        <button id="gameBackToHomeBtn" class="btn btn-secondary">🏠 Back to Home</button>
      </div>
    </div>
    
    <!-- Game Header - HIDDEN to save space -->
    <div class="game-header" style="display: none;">
      <div class="status">Active Player: <span id="active">-</span></div>
      <div class="status">Phase: <span id="phase">-</span></div>
    </div>
    
    <!-- Toast Container -->
    <div id="toastContainer" class="toast-container">
      <!-- Toasts will be displayed here -->
    </div>
    
    <!-- Main Game Area -->
    <div class="game-main">
      <!-- Opponent Area (Top) -->
      <div class="player-section enemy-area" id="playerB">
        <div class="player-area-label opponent">
          <span>Opponent</span>
          <div class="player-stats-inline" id="opponentStatsInline">
            <div class="stat-inline">
              <div class="label">Hand</div>
              <div class="value" id="opponentHandCount">0</div>
            </div>
            <div class="stat-inline">
              <div class="label">Tableau</div>
              <div class="value" id="opponentTableauCount">0</div>
            </div>
          </div>
        </div>
        <h4>Hand: <button class="eye-button" onclick="toggleOpponentHand()">👁️</button></h4>
        <div class="hand opponent-hand hidden" id="handB"></div>
        <h4>Tableau: <button class="eye-button" onclick="toggleOpponentTableau()">👁️</button></h4>
        <div class="tableau" id="tableauB"></div>
        <div class="status-effects" id="statusEffectsB">
          <h4>Estados Activos</h4>
          <div class="status-effects-list" id="statusEffectsListB">
            <!-- Status effects will be displayed here -->
        </div>
      </div>
    </div>
    
      <!-- Card Selection Panel (Between Areas) -->
    <div class="card-selection-panel" id="cardSelectionPanel">
      <div class="panel-header">
        <h3 id="panelTitle">Choose Cards <button class="eye-button" onclick="toggleChoosePanel()">👁️</button></h3>
      </div>
      
      <div class="legend">
        <span class="legend-item"><span class="legend-dot you"></span> You</span>
        <span class="legend-item"><span class="legend-dot opp"></span> Opp</span>
      </div>
      
      <div class="card-choice-container">
        <div class="card-choice" id="faceUpCard">
          <h4>Face Up</h4>
          <div class="card-preview" id="faceUpPreview">
            <div class="placeholder">Drag a card here</div>
          </div>
          <button class="choose-btn" id="chooseFaceUp" disabled>Choose This One</button>
        </div>
        
        <div class="card-choice" id="faceDownCard">
          <h4>Face Down</h4>
          <div class="card-preview" id="faceDownPreview">
            <div class="placeholder">Drag a card here</div>
          </div>
          <button class="choose-btn" id="chooseFaceDown" disabled>Choose This One</button>
        </div>
      </div>
      
      <div class="play-controls">
        <button id="playBtn" class="play-selected-btn" style="display: none;">▶️ Play Cards</button>
      </div>
    </div>

      <!-- Your Area (Bottom) -->
      <div class="player-section player-area" id="playerA">
        <div class="player-area-label">
          <span>You</span>
          <div class="player-stats-inline" id="playerStatsInline">
            <div class="stat-inline">
              <div class="label">Hand</div>
              <div class="value" id="playerHandCount">0</div>
            </div>
            <div class="stat-inline">
              <div class="label">Tableau</div>
              <div class="value" id="playerTableauCount">0</div>
            </div>
          </div>
        </div>
        <h4>Tableau: <button class="eye-button" onclick="toggleSelfTableau()">👁️</button></h4>
        <div class="tableau" id="tableauA"></div>
        <h4>Hand: <button class="eye-button" onclick="toggleSelfHand()">👁️</button></h4>
        <div class="hand" id="handA"></div>
        <div class="status-effects" id="statusEffectsA">
          <h4>Estados Activos</h4>
          <div class="status-effects-list" id="statusEffectsListA">
            <!-- Status effects will be displayed here -->
      </div>
    </div>
    </div>
      
    </div>  <!-- End game-main -->
    
    <!-- Game Footer -->
    <div class="game-footer">
        <!-- Game log removed - using toasts instead -->
      </div>
    </div>
    
    <!-- Floating Dot Counter -->
    <div id="dotCounter" class="dot-counter-display"></div>
  </div>


  <script>
     // Auto-detect API URL based on environment
     const api = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' 
       ? '' // Local development - use same host
       : 'https://smarter-co00.onrender.com'; // Production - use remote API
     
     console.log('🌐 Environment detected:', window.location.hostname);
     console.log('🔗 Using API:', api || 'same host (' + window.location.origin + ')');
    let matchId = '';
    let playerSeat = null;
    let playerName = null;
    let playerToken = null;
    let gameState = null;
    let selUp = null, selDown = null;
    let turnTimer = null;
    let choiceTimer = null;
    let turnTimeLeft = 30; // Default timer for card selection phase
    let choiceTimeLeft = 15; // Default timer for opponent choice phase

    // Screen management functions
    function showScreen(screenId) {
      const screens = ['homeScreen', 'createMatchScreen', 'joinMatchScreen', 'readyScreen', 'gameScreen'];
      screens.forEach(id => {
        document.getElementById(id).style.display = 'none';
      });
      document.getElementById(screenId).style.display = 'block';
      
      // Special handling for game screen
      if (screenId === 'gameScreen') {
        document.getElementById('gameContainer').style.display = 'grid';
      } else {
        document.getElementById('gameContainer').style.display = 'none';
      }
      console.log('Showing screen:', screenId);
    }

    // Game functions
    async function req(url, opts={}) {
      const r = await fetch(url, opts);
      if (!r.ok) throw new Error(await r.text());
      return r.json();
    }

    function log(msg, type = 'info'){
      console.log(msg);
      showToast(msg, type);
    }
    
    function showToast(message, type = 'info', duration = 3000) {
      const container = document.getElementById('toastContainer');
      if (!container) return;
      
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.textContent = message;
      
      container.appendChild(toast);
      
      // Trigger animation
      setTimeout(() => {
        toast.classList.add('show');
      }, 10);
      
      // Auto remove
      setTimeout(() => {
        toast.classList.add('hide');
        setTimeout(() => {
          if (toast.parentNode) {
            toast.parentNode.removeChild(toast);
          }
        }, 300);
      }, duration);
      
      // Click to dismiss
      toast.addEventListener('click', () => {
        toast.classList.add('hide');
        setTimeout(() => {
          if (toast.parentNode) {
            toast.parentNode.removeChild(toast);
          }
        }, 300);
      });
    }
    
    // Read matchId from URL and check for existing seat
    (function initMatchFromUrl(){
      const url = new URL(window.location.href);
      const pMatch = url.searchParams.get('match');
      if(pMatch){
        matchId = pMatch;
      } else {
        const parts = window.location.pathname.split('/');
        if(parts.length>=3 && parts[1]==='app' && parts[2].length>0){
          matchId = parts[2];
        }
      }
      
      // Check localStorage for existing seat
      const storedSeat = localStorage.getItem('match_' + matchId + '_seat');
      const storedName = localStorage.getItem('match_' + matchId + '_name');
      const storedToken = localStorage.getItem('match_' + matchId + '_token');
      
      if(storedSeat !== null && storedName !== null && storedToken !== null){
        playerSeat = parseInt(storedSeat);
        playerName = storedName;
        playerToken = storedToken;
      }
      
      if(matchId){
        document.getElementById('displayMatchId').textContent = matchId;
        if(playerSeat !== null){
          startAutoRefresh();
          refresh();
        } else {
          showScreen('joinMatchScreen');
        }
      } else {
        showScreen('homeScreen');
      }
    })();

    // Event listeners
    document.getElementById('createMatchBtn').onclick = () => {
      showScreen('createMatchScreen');
    };

    document.getElementById('joinMatchBtn').onclick = () => {
      showScreen('joinMatchScreen');
    };

    document.getElementById('playBotBtn').onclick = () => {
      createMatchWithBot();
    };

    document.getElementById('confirmCreateBtn').onclick = createMatch;

    document.getElementById('confirmJoinBtn').onclick = joinMatch;

    async function createMatch() {
      const name = document.getElementById('createPlayerName').value.trim();
      if (!name) {
        alert('Please enter your name');
        return;
      }

      try {
        const data = await req(api + '/api/match', { method:'POST', headers:{'Content-Type':'application/json'}, body:'{}' });
        matchId = data.id;
        playerName = name;
        
        // Join the match we just created
        const response = await req(api + '/api/match/' + matchId + '/join', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: name })
        });

        playerSeat = response.seat;
        playerToken = response.token;
        
        // Store in localStorage
        localStorage.setItem('match_' + matchId + '_seat', playerSeat);
        localStorage.setItem('match_' + matchId + '_name', playerName);
        localStorage.setItem('match_' + matchId + '_token', playerToken);
        localStorage.setItem('playerName', playerName);
        localStorage.setItem('wasVsBot', 'false'); // Player vs Player
        
        document.getElementById('displayMatchId').textContent = matchId;
        showScreen('readyScreen');
        startAutoRefresh();
        refresh();
        
        log('Created match and joined successfully');
      } catch (error) {
        alert('Failed to create match: ' + error.message);
      }
    }

    async function createMatchWithBot() {
      const name = prompt('Enter your name for the bot match:');
      if (!name) return;
      
      try {
        const data = await req(api + '/api/match/bot', { method:'POST', headers:{'Content-Type':'application/json'}, body:'{}' });
        matchId = data.id;
        
        // Join as Player B (human player)
        const response = await req(api + '/api/match/' + matchId + '/join', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: name })
        });

        playerSeat = response.seat;
        playerToken = response.token;
        playerName = name;
        
        // Store in localStorage
        localStorage.setItem('match_' + matchId + '_seat', playerSeat);
        localStorage.setItem('match_' + matchId + '_name', playerName);
        localStorage.setItem('match_' + matchId + '_token', playerToken);
        localStorage.setItem('playerName', playerName);
        localStorage.setItem('wasVsBot', 'true');
        
        document.getElementById('displayMatchId').textContent = matchId;
        showScreen('readyScreen');
        startAutoRefresh();
        refresh();
        
        log('Created bot match and joined successfully');
      } catch (error) {
        alert('Failed to create bot match: ' + error.message);
      }
    }

    async function joinMatch(){
      const id = document.getElementById('joinMatchId').value.trim();
      const name = document.getElementById('joinPlayerName').value.trim();

      if(!id){ alert('Please enter a match id'); return; }
      if(!name){ alert('Please enter your name'); return; }

      matchId = id;
      await joinMatchDirect(id, name);
    }

    async function joinMatchDirect(id, name){
      try {
        const response = await req(api + '/api/match/' + id + '/join', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name })
        });

        playerSeat = response.seat;
        playerToken = response.token;
        playerName = name;
        
        // Persist for reloads
        localStorage.setItem('match_' + id + '_seat', playerSeat);
        localStorage.setItem('match_' + id + '_name', playerName);
        localStorage.setItem('match_' + id + '_token', playerToken);
        localStorage.setItem('playerName', playerName);
        localStorage.setItem('wasVsBot', 'false'); // Player vs Player
        
        document.getElementById('displayMatchId').textContent = matchId;
        showScreen('readyScreen');
        startAutoRefresh();
        refresh();
        
        log('Joined match successfully');
      } catch (error) {
        alert('Failed to join match: ' + error.message);
      }
    }

    document.getElementById('backToHomeBtn').onclick = () => {
      showScreen('homeScreen');
    };

    document.getElementById('backToHomeBtn2').onclick = () => {
      showScreen('homeScreen');
    };

    // Enter key support
    document.getElementById('createPlayerName').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') document.getElementById('confirmCreateBtn').click();
    });

    document.getElementById('joinMatchId').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') document.getElementById('confirmJoinBtn').click();
    });

    document.getElementById('joinPlayerName').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') document.getElementById('confirmJoinBtn').click();
    });

    // Add all the game functions from the backup file
    // This includes refresh, render functions, game logic, etc.
    // For brevity, I'll add the essential functions

    // Generate visual stone counter display
    function generateVisualCounter(dotCounter, topPlayerName, bottomPlayerName, playerSeat = null) {
      // Don't adjust the counter value here, keep original for stone calculation
      const clampedCounter = Math.max(-5, Math.min(5, dotCounter));
      
      console.log('DEBUG generateVisualCounter: dotCounter =', dotCounter, 'clampedCounter =', clampedCounter, 'playerSeat =', playerSeat);
      
      // Truncate player names to max 10 characters
      const nameTop = topPlayerName.length > 10 ? topPlayerName.substring(0, 10) + '...' : topPlayerName;
      const nameBottom = bottomPlayerName.length > 10 ? bottomPlayerName.substring(0, 10) + '...' : bottomPlayerName;
      
      // Generate stones array: 5 toward opponent (top), 1 neutral (center), 5 toward self (bottom)
      const stones = [];
      
      // FIXED: Invert for correct "push" visualization - positive = push toward opponent (top)
      let effectiveCounter = -clampedCounter;
      console.log('DEBUG generateVisualCounter: Input counter:', clampedCounter, '→ Visual counter (inverted for push logic):', effectiveCounter);
      
      // Top stones (when pushing toward opponent) - positive values
      console.log('DEBUG generateVisualCounter: Generating opponent-side stones (when you\'re winning)');
      for (let i = 5; i >= 1; i--) {
        const stoneIndex = stones.length;
        if (effectiveCounter === i) {
          console.log('DEBUG generateVisualCounter: Activating opponent-side stone for value', i, 'at array position', stoneIndex);
          stones.push('<span class="stone active">●</span>'); // You're pushing toward opponent
        } else {
          stones.push('<span class="stone inactive">○</span>'); // Inactive stone
        }
      }
      
      // Center neutral stone (0)
      const centerIndex = stones.length;
      if (effectiveCounter === 0) {
        console.log('DEBUG generateVisualCounter: Activating center stone at array position', centerIndex);
        stones.push('<span class="stone active">●</span>'); // Neutral/balanced
      } else {
        stones.push('<span class="stone center">○</span>'); // Inactive center stone
      }
      
      // Bottom stones (when being pushed toward self) - negative values
      console.log('DEBUG generateVisualCounter: Generating self-side stones (when you\'re losing)');
      for (let i = 1; i <= 5; i++) {
        const stoneIndex = stones.length;
        if (effectiveCounter === -i) {
          console.log('DEBUG generateVisualCounter: Activating self-side stone for value', -i, 'at array position', stoneIndex);
          stones.push('<span class="stone active">●</span>'); // Opponent is pushing toward you
        } else {
          stones.push('<span class="stone inactive">○</span>'); // Inactive stone
        }
      }
      
      // Combine everything with vertical layout
      console.log('DEBUG generateVisualCounter: Final stones array:', stones.map((stone, index) => {
        const isActive = stone.includes('active');
        const isCenter = stone.includes('center');
        return `Stone ${index}: ${isActive ? 'ACTIVE' : (isCenter ? 'center' : 'inactive')} - HTML: ${stone}`;
      }));
      
      return `<div class="visual-counter-display">
        <div class="player-name">${nameTop}</div>
        <div class="stones-container">${stones.join('')}</div>
        <div class="player-name">${nameBottom}</div>
      </div>`;
    }

    /**
     * Normalize gameState to always have self/opponent format
     * This handles both legacy (playerA/playerB) and new (self/opponent) API responses
     */
    function normalizeGameState(gameState) {
      console.log('🔍 DEBUG normalizeGameState: input gameState =', gameState);
      
      // If already in new format, return as-is
      if (gameState.self && gameState.opponent) {
        console.log('🔍 DEBUG normalizeGameState: using NEW format');
        console.log('🔍 DEBUG normalizeGameState: gameState.playTwoCardsTimeSeconds =', gameState.playTwoCardsTimeSeconds);
        console.log('🔍 DEBUG normalizeGameState: gameState.opponentPickTimeSeconds =', gameState.opponentPickTimeSeconds);
        
        const result = {
          ...gameState,
          self: gameState.self,
          opponent: gameState.opponent,
          selfDotCounter: gameState.selfDotCounter !== undefined ? gameState.selfDotCounter : gameState.sharedDotCounter,
          phase: gameState.phase,
          faceUpCardId: gameState.faceUpCardId,
          faceDownCardId: gameState.faceDownCardId,
          waitingForOpponentChoice: gameState.waitingForOpponentChoice,
          isMyTurn: gameState.isMyTurn !== undefined ? gameState.isMyTurn : false,
          canChooseCards: gameState.canChooseCards !== undefined ? gameState.canChooseCards : false,
          winner: gameState.winner || null,
          cardDefinitions: gameState.cardDefinitions,
          recentEffects: gameState.recentEffects || [],
          started: gameState.started,
          playTwoCardsTimeSeconds: gameState.playTwoCardsTimeSeconds || 30,
          opponentPickTimeSeconds: gameState.opponentPickTimeSeconds || 15
        };
        
        console.log('🔍 DEBUG normalizeGameState: result.playTwoCardsTimeSeconds =', result.playTwoCardsTimeSeconds);
        console.log('🔍 DEBUG normalizeGameState: result.opponentPickTimeSeconds =', result.opponentPickTimeSeconds);
        return result;
      }
      
      // Legacy format - convert based on playerSeat
      const isPlayerA = playerSeat === 0;
      
      const selfPlayer = {
        name: isPlayerA ? gameState.playerA : gameState.playerB,
        handSize: isPlayerA ? gameState.handSizeA : gameState.handSizeB,
        handCardIds: gameState.activeHandCardIds || [],
        tableauSize: isPlayerA ? gameState.tableauSizeA : gameState.tableauSizeB,
        tableauCardIds: isPlayerA ? gameState.tableauCardIdsA : gameState.tableauCardIdsB,
        revealedCards: isPlayerA ? gameState.revealedCardsA : gameState.revealedCardsB,
        recentlyAddedCards: isPlayerA ? gameState.recentlyAddedCardsA : gameState.recentlyAddedCardsB,
        activeStatuses: isPlayerA ? gameState.activeStatusesA : gameState.activeStatusesB,
        ready: isPlayerA ? gameState.readyA : gameState.readyB,
        isBot: isPlayerA ? gameState.playerAIsBot : gameState.playerBIsBot
      };
      
      const opponentPlayer = {
        name: isPlayerA ? gameState.playerB : gameState.playerA,
        handSize: isPlayerA ? gameState.handSizeB : gameState.handSizeA,
        handCardIds: [], // Opponent hand is always hidden
        tableauSize: isPlayerA ? gameState.tableauSizeB : gameState.tableauSizeA,
        tableauCardIds: isPlayerA ? gameState.tableauCardIdsB : gameState.tableauCardIdsA,
        revealedCards: isPlayerA ? gameState.revealedCardsB : gameState.revealedCardsA,
        recentlyAddedCards: isPlayerA ? gameState.recentlyAddedCardsB : gameState.recentlyAddedCardsA,
        activeStatuses: isPlayerA ? gameState.activeStatusesB : gameState.activeStatusesA,
        ready: isPlayerA ? gameState.readyB : gameState.readyA,
        isBot: isPlayerA ? gameState.playerBIsBot : gameState.playerAIsBot
      };
      
      return {
        matchId: gameState.id,
        self: selfPlayer,
        opponent: opponentPlayer,
        selfDotCounter: isPlayerA ? gameState.sharedDotCounter : -gameState.sharedDotCounter,
        phase: gameState.phase,
        faceUpCardId: gameState.faceUpCardId,
        faceDownCardId: gameState.faceDownCardId,
        waitingForOpponentChoice: gameState.waitingForOpponentChoice,
        isMyTurn: playerSeat !== null && playerSeat === gameState.activePlayer,
        canChooseCards: (gameState.phase === 'OPPONENT_PICK') && (playerSeat !== null && playerSeat !== gameState.activePlayer),
        winner: null, // Legacy format doesn't have winner info, calculate in frontend if needed
        cardDefinitions: gameState.cardDefinitions,
        recentEffects: gameState.recentEffects || [],
        started: gameState.started,
        playTwoCardsTimeSeconds: gameState.playTwoCardsTimeSeconds || 120,
        opponentPickTimeSeconds: gameState.opponentPickTimeSeconds || 60,
        // Keep legacy fields for backward compatibility during transition
        activePlayer: gameState.activePlayer,
        playerA: gameState.playerA,
        playerB: gameState.playerB
      };
    }
    
    function toggleOpponentHand() {
      const oppHandDiv = document.getElementById('handB');
      if (oppHandDiv) {
        oppHandDiv.classList.toggle('hidden');
      }
    }
    
    function toggleOpponentTableau() {
      const oppTableauDiv = document.getElementById('tableauB');
      if (oppTableauDiv) {
        oppTableauDiv.classList.toggle('hidden');
      }
    }
    
    function toggleChoosePanel() {
      const choosePanelContent = document.querySelector('#cardSelectionPanel .legend, #cardSelectionPanel .card-choice-container, #cardSelectionPanel .play-controls');
      const elements = document.querySelectorAll('#cardSelectionPanel .legend, #cardSelectionPanel .card-choice-container, #cardSelectionPanel .play-controls');
      elements.forEach(el => {
        if (el) el.classList.toggle('hidden');
      });
    }
    
    function toggleSelfTableau() {
      const selfTableauDiv = document.getElementById('tableauA');
      if (selfTableauDiv) {
        selfTableauDiv.classList.toggle('hidden');
      }
    }
    
    function toggleSelfHand() {
      const selfHandDiv = document.getElementById('handA');
      if (selfHandDiv) {
        selfHandDiv.classList.toggle('hidden');
      }
    }
    
    /**
     * Helper function to make API calls using token-based or legacy endpoints
     */
    async function apiCall(endpoint, body = null) {
      if (playerToken) {
        // Use new token-based endpoints
        let url, method;
        if (endpoint === 'play') {
          url = api + '/api/match/' + matchId + '/play-token';
          method = 'POST';
        } else if (endpoint === 'choose') {
          url = api + '/api/match/' + matchId + '/choose-token';
          method = 'POST';
        } else if (endpoint === 'ready') {
          url = api + '/api/match/' + matchId + '/ready-token';
          method = 'POST';
        } else {
          throw new Error('Unknown endpoint: ' + endpoint);
        }
        
        const response = await req(url, {
          method: method,
          headers: { 
            'Content-Type': 'application/json',
            'X-Player-Token': playerToken
          },
          body: body ? JSON.stringify(body) : undefined
        });
        
        // Update gameState with response (token endpoints return full state)
        gameState = response;
        return response;
      } else {
        // Fallback to legacy endpoints
        let url;
        if (endpoint === 'play') {
          url = playerSeat !== null ? 
            api + '/api/match/' + matchId + '/play?seat=' + playerSeat :
            api + '/api/match/' + matchId + '/play';
        } else if (endpoint === 'choose') {
          url = playerSeat !== null ? 
            api + '/api/match/' + matchId + '/choose?seat=' + playerSeat :
            api + '/api/match/' + matchId + '/choose';
        } else if (endpoint === 'ready') {
          url = api + '/api/match/' + matchId + '/ready?seat=' + playerSeat;
        } else {
          throw new Error('Unknown endpoint: ' + endpoint);
        }
        
        const response = await req(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: body ? JSON.stringify(body) : undefined
        });
        
        // For legacy endpoints, we need to refresh separately
        if (endpoint !== 'ready') {
          gameState = response;
        }
        return response;
      }
    }

    async function refresh() {
      if (!matchId) return;
      console.log('DEBUG refresh: Starting refresh for matchId =', matchId);
      
      // Use new token-based endpoint if we have a token
      let gameState_response;
      if (playerToken) {
        gameState_response = await req(api + '/api/match/' + matchId + '/state', {
          method: 'GET',
          headers: { 'X-Player-Token': playerToken }
        });
      } else {
        // Fallback to old endpoint for backward compatibility
      const url = playerSeat !== null ? 
        api + '/api/match/' + matchId + '?seat=' + playerSeat :
        api + '/api/match/' + matchId;
        gameState_response = await req(url);
      }
      
      gameState = gameState_response;
      console.log('DEBUG refresh: gameState =', gameState);
      
      // For new token-based API, we have different structure
      if (playerToken && gameState.self && gameState.opponent) {
        console.log('DEBUG refresh: using new API format with self/opponent');
        console.log('DEBUG refresh: gameState.self =', gameState.self);
        console.log('DEBUG refresh: gameState.opponent =', gameState.opponent);
      } else {
        console.log('DEBUG refresh: using legacy API format');
      console.log('DEBUG refresh: gameState.recentlyAddedCardsA =', gameState.recentlyAddedCardsA);
      console.log('DEBUG refresh: gameState.recentlyAddedCardsB =', gameState.recentlyAddedCardsB);
      console.log('DEBUG refresh: gameState.activeHandCardIds =', gameState.activeHandCardIds);
      }
      
      // Handle lobby state
      if (!gameState.started) {
        showLobby();
        return;
      }
      
      // Game started - show game UI
      showGame();
      
      // Normalize gameState to always have self/opponent format
      const normalizedState = normalizeGameState(gameState);
      
      // Update player info in sidebar (simple self/opponent)
        const opponentHandCount = document.getElementById('opponentHandCount');
        const opponentTableauCount = document.getElementById('opponentTableauCount');
        const playerHandCount = document.getElementById('playerHandCount');
        const playerTableauCount = document.getElementById('playerTableauCount');
        
      if (opponentHandCount) opponentHandCount.textContent = normalizedState.opponent.handSize;
      if (opponentTableauCount) opponentTableauCount.textContent = normalizedState.opponent.tableauSize;
      if (playerHandCount) playerHandCount.textContent = normalizedState.self.handSize;
      if (playerTableauCount) playerTableauCount.textContent = normalizedState.self.tableauSize;
      
      const activeElement = document.getElementById('active');
      const phaseElement = document.getElementById('phase');
      // For now, keep legacy active player display until we fully migrate
      if (activeElement) activeElement.textContent = normalizedState.activePlayer === 0 ? normalizedState.playerA : normalizedState.playerB;
      if (phaseElement) phaseElement.textContent = normalizedState.phase || 'PLAY_TWO_CARDS';
      
      
      // Simplified layout - just update labels, no complex DOM manipulation
      // Add name pills using normalized state
      addPlayerNamePill(document.getElementById('playerA'), normalizedState.self.name);
      addPlayerNamePill(document.getElementById('playerB'), normalizedState.opponent.name);
      
      // Ensure self hand (handA) is always visible
      const selfHand = document.getElementById('handA');
      if (selfHand) {
        selfHand.classList.remove('opponent-hand', 'hidden');
      }
      
      // Ensure opponent hand (handB) starts hidden
      const oppHand = document.getElementById('handB');
      if (oppHand) {
        oppHand.classList.add('opponent-hand', 'hidden');
      }
      
      // Update dot counter with visual stone system (now relative to player)
      const dotCounter = normalizedState.selfDotCounter;
      const dotCounterElement = document.getElementById('dotCounter');
      
      if (dotCounterElement) {
        console.log('DEBUG: dotCounterElement found, updating with dotCounter =', dotCounter);
        console.log('DEBUG: dotCounterElement position =', dotCounterElement.getBoundingClientRect());
        console.log('DEBUG: dotCounterElement computed style =', window.getComputedStyle(dotCounterElement));
        
        // Generate visual stone display - unified self/opponent approach
        const topPlayerName = normalizedState.opponent.name;
        const bottomPlayerName = normalizedState.self.name;
        
        const visualCounter = generateVisualCounter(dotCounter, topPlayerName, bottomPlayerName, playerSeat);
        dotCounterElement.innerHTML = visualCounter;
        console.log('DEBUG: dotCounterElement updated, innerHTML =', dotCounterElement.innerHTML);
        
        // Force visibility and position
        dotCounterElement.style.display = 'block';
        dotCounterElement.style.visibility = 'visible';
        dotCounterElement.style.opacity = '1';
        dotCounterElement.style.position = 'fixed';
        dotCounterElement.style.right = '20px';  /* Right side */
        dotCounterElement.style.left = '';       /* Clear left */
        dotCounterElement.style.top = '50%';
        dotCounterElement.style.transform = 'translateY(-50%)';
        dotCounterElement.style.zIndex = '99999';
        console.log('DEBUG: Forced visibility and position styles applied');
      } else {
        console.log('DEBUG: dotCounterElement NOT FOUND');
      }
      
      // Update counter styling based on value
      if (dotCounterElement) {
        dotCounterElement.className = 'dot-counter-display'; // Keep the main CSS class
        if (dotCounter >= 5) {
          dotCounterElement.style.color = '#4caf50'; // Green for Player A winning
          dotCounterElement.style.textShadow = '0 0 10px rgba(76, 175, 80, 0.5)';
        } else if (dotCounter <= -5) {
          dotCounterElement.style.color = '#f44336'; // Red for Player B winning
          dotCounterElement.style.textShadow = '0 0 10px rgba(244, 67, 54, 0.5)';
        } else {
          dotCounterElement.style.color = '#fff'; // White for neutral
          dotCounterElement.style.textShadow = '2px 2px 4px rgba(0,0,0,0.3)';
        }
      }
      
      // Check win conditions
      checkWinConditions();
      
      // Apply responsive collapse logic
      applyResponsiveCollapse();
      
      // Update active player highlighting with enhanced visual feedback
      const playerAElement = document.getElementById('playerA');
      const playerBElement = document.getElementById('playerB');
      
      playerAElement.classList.toggle('active', gameState.activePlayer === 0);
      playerBElement.classList.toggle('active', gameState.activePlayer === 1);
      
      
      // Update UI based on phase
      updateUIForPhase();
      
      // Render hands and tableaus
      renderHands();
      renderTableaus();
      
      // Render effect feedback
      renderEffectFeedback();
      
      // Render status effects
      renderStatusEffects();
      
      // Render cards in central panel
      renderCentralCardPanel();
      
      // Setup drag and drop for central panel
      setupDragAndDrop();
      
      // Use the backend-provided isMyTurn flag for accurate turn determination
      const isMyTurn = normalizedState.isMyTurn && normalizedState.phase === 'PLAY_TWO_CARDS';
      console.log('DEBUG TURNS: normalizedState.isMyTurn =', normalizedState.isMyTurn);
      console.log('DEBUG TURNS: normalizedState.phase =', normalizedState.phase);
      console.log('DEBUG TURNS: calculated isMyTurn =', isMyTurn);
      toggleInteraction(isMyTurn);
      
      // Show/hide central panel based on phase and player
      updateCentralPanelVisibility();
      
      // Auto-play bot turns using normalized state
      if (normalizedState.started) {
        const isSelfBot = normalizedState.self.isBot;
        const isOpponentBot = normalizedState.opponent.isBot;
        const phase = normalizedState.phase;
        const isMyTurn = normalizedState.isMyTurn;
        const canChooseCards = normalizedState.canChooseCards;
        
        console.log('Bot check: started=' + normalizedState.started + ', isSelfBot=' + isSelfBot + ', isOpponentBot=' + isOpponentBot + ', isMyTurn=' + isMyTurn + ', phase=' + phase + ', canChooseCards=' + canChooseCards);
        console.log('Bot check: selfName=' + normalizedState.self.name + ', opponentName=' + normalizedState.opponent.name);
        
        let shouldAct = false;
        let delay = 1000;
        let action = 'playing';
        
        if (phase === 'PLAY_TWO_CARDS' && isMyTurn && isSelfBot) {
          // It's our turn and we're a bot - select cards
            shouldAct = true;
            delay = 1000; // 1 second to select cards
            action = 'selecting cards';
        } else if (phase === 'OPPONENT_PICK' && canChooseCards && isSelfBot) {
          // We can choose cards and we're a bot - choose between cards
            shouldAct = true;
            delay = 3000; // 3 seconds to choose between cards
            action = 'choosing between cards';
        }
        
        if (shouldAct) {
          console.log('Bot will ' + action + ' in ' + delay + 'ms');
          setTimeout(async () => {
            try {
              console.log('Bot executing action:', action, 'for phase:', phase);
              if (phase === 'PLAY_TWO_CARDS') {
                // Bot selects two random cards from hand
                console.log('Bot PLAY_TWO_CARDS: handCardIds =', normalizedState.self.handCardIds);
                if (normalizedState.self.handCardIds && normalizedState.self.handCardIds.length >= 2) {
                  const cards = normalizedState.self.handCardIds;
                  const faceUpCard = cards[Math.floor(Math.random() * cards.length)];
                  let faceDownCard = cards[Math.floor(Math.random() * cards.length)];
                  // Ensure different cards
                  while (faceDownCard === faceUpCard && cards.length > 1) {
                    faceDownCard = cards[Math.floor(Math.random() * cards.length)];
                  }
                  
                  console.log('Bot about to play cards:', faceUpCard, faceDownCard);
                  // Use new token-based endpoint if available
                  await apiCall('play', {
                      faceUpId: faceUpCard,
                      faceDownId: faceDownCard
                  });
                  console.log('Bot selected cards automatically:', faceUpCard, faceDownCard);
                } else {
                  console.log('Bot PLAY_TWO_CARDS: Not enough cards in hand, handCardIds =', normalizedState.self.handCardIds);
                }
              } else if (phase === 'OPPONENT_PICK') {
                // Bot chooses randomly between face up and face down
                console.log('Bot OPPONENT_PICK: canChooseCards =', canChooseCards);
                const choice = Math.random() < 0.5 ? 'faceUp' : 'faceDown';
                
                console.log('Bot about to choose:', choice);
                // Use new token-based endpoint if available
                await apiCall('choose', {
                    chooseFaceUp: choice === 'faceUp'
                });
                console.log('Bot chose automatically:', choice);
              }
              log('Bot ' + action + ' automatically');
            } catch (error) {
              console.log('Bot auto-play failed:', error);
            }
          }, delay);
        }
      }
    }

    function showLobby() {
      showScreen('readyScreen');
      
      // Normalize gameState to handle both legacy and new formats
      const normalizedState = normalizeGameState(gameState);
      
      // Update lobby info using self/opponent format
      if (normalizedState.self && normalizedState.opponent) {
        // New format: use self/opponent
        // For lobby display, we need to show "You" and "Opponent" or actual names
        
        // Simplified: Always show self and opponent in consistent positions
        // For now, we'll use the existing HTML structure but populate it consistently
        // TODO: Later we should change HTML to have selfName/opponentName instead of playerA/playerB
        
        // Show self as "You" and opponent by name, regardless of which slot they're in
        const selfLabel = normalizedState.self.name || 'You';
        const opponentLabel = normalizedState.opponent.name || 'Waiting...';
        
        // For consistency, always put self in the first slot and opponent in second
        document.getElementById('playerAName').textContent = selfLabel;
        document.getElementById('playerBName').textContent = opponentLabel;
        
        const playerAReady = document.getElementById('playerAReady');
        const playerBReady = document.getElementById('playerBReady');
        
        playerAReady.textContent = normalizedState.self.ready ? '(Ready)' : '(Not Ready)';
        playerBReady.textContent = normalizedState.opponent.ready ? '(Ready)' : '(Not Ready)';
        playerAReady.className = normalizedState.self.ready ? 'ready-status ready' : 'ready-status not-ready';
        playerBReady.className = normalizedState.opponent.ready ? 'ready-status ready' : 'ready-status not-ready';
        
        // Update labels to be more semantic
        document.querySelector('#playerAName').previousElementSibling.textContent = 'You:';
        document.querySelector('#playerBName').previousElementSibling.textContent = 'Opponent:';
        
        // Show timer configuration for the host
        const timerConfig = document.getElementById('timerConfig');
        let isHost = false;
        
        console.log('🎯 HOST DEBUG: normalizedState.self.isBot =', normalizedState.self.isBot);
        console.log('🎯 HOST DEBUG: normalizedState.opponent.isBot =', normalizedState.opponent.isBot);
        console.log('🎯 HOST DEBUG: playerSeat =', playerSeat);
        
        // Determine host based on game type
        if (normalizedState.self.isBot && !normalizedState.opponent.isBot) {
          // Bot vs Human: Human is host (regardless of seat)
          isHost = !normalizedState.self.isBot;
          console.log('🎯 HOST DEBUG: Bot vs Human case, isHost =', isHost);
        } else if (!normalizedState.self.isBot && normalizedState.opponent.isBot) {
          // Human vs Bot: Human is host
          isHost = !normalizedState.self.isBot;
          console.log('🎯 HOST DEBUG: Human vs Bot case, isHost =', isHost);
        } else if (!normalizedState.self.isBot && !normalizedState.opponent.isBot) {
          // Human vs Human: Player A (seat 0) is host
          isHost = (playerSeat === 0);
          console.log('🎯 HOST DEBUG: Human vs Human case, isHost =', isHost);
        }
        
        console.log('🎯 HOST DEBUG: Final isHost =', isHost);
        
        if (timerConfig) {
          timerConfig.style.display = isHost ? 'block' : 'none';
          console.log('🎯 HOST DEBUG: Timer config display =', timerConfig.style.display);
          
          // Set timer values from backend only if they haven't been initialized yet
          if (isHost) {
            const playTwoCardsSelect = document.getElementById('playTwoCardsTime');
            const opponentPickSelect = document.getElementById('opponentPickTime');
            
            console.log('🎯 HOST DEBUG: playTwoCardsSelect =', playTwoCardsSelect);
            console.log('🎯 HOST DEBUG: opponentPickSelect =', opponentPickSelect);
            
            // Only set values from backend if:
            // 1. They haven't been initialized yet AND
            // 2. The backend values are different from defaults (120, 60) OR
            // 3. The user hasn't changed them manually (no userModified flag)
            if (playTwoCardsSelect && !playTwoCardsSelect.dataset.initialized && !playTwoCardsSelect.dataset.userModified) {
              // Only set from backend if it's different from the frontend default (30s)
              if (normalizedState.playTwoCardsTimeSeconds && normalizedState.playTwoCardsTimeSeconds !== parseInt(playTwoCardsSelect.value)) {
                playTwoCardsSelect.value = normalizedState.playTwoCardsTimeSeconds;
                console.log('🎯 HOST DEBUG: Set playTwoCardsTime to backend value', normalizedState.playTwoCardsTimeSeconds);
              }
              playTwoCardsSelect.dataset.initialized = 'true';
            }
            
            if (opponentPickSelect && !opponentPickSelect.dataset.initialized && !opponentPickSelect.dataset.userModified) {
              // Only set from backend if it's different from the frontend default (15s)  
              if (normalizedState.opponentPickTimeSeconds && normalizedState.opponentPickTimeSeconds !== parseInt(opponentPickSelect.value)) {
                opponentPickSelect.value = normalizedState.opponentPickTimeSeconds;
                console.log('🎯 HOST DEBUG: Set opponentPickTime to backend value', normalizedState.opponentPickTimeSeconds);
              }
              opponentPickSelect.dataset.initialized = 'true';
            }
            
            // Ensure event listeners are attached when host sees timer config
            if (playTwoCardsSelect && !playTwoCardsSelect.dataset.listenerAttached) {
              playTwoCardsSelect.removeEventListener('change', updateTimerSettings);
              playTwoCardsSelect.addEventListener('change', updateTimerSettings);
              playTwoCardsSelect.dataset.listenerAttached = 'true';
              console.log('🎯 HOST DEBUG: Added change listener to playTwoCardsTime');
            }
            
            if (opponentPickSelect && !opponentPickSelect.dataset.listenerAttached) {
              opponentPickSelect.removeEventListener('change', updateTimerSettings);
              opponentPickSelect.addEventListener('change', updateTimerSettings);
              opponentPickSelect.dataset.listenerAttached = 'true';
              console.log('🎯 HOST DEBUG: Added change listener to opponentPickTime');
            }
          }
        }
        
        // Show ready button if this player isn't ready yet
        const readyBtn = document.getElementById('readyBtn');
        const waitingMsg = document.getElementById('waitingMessage');
        
        if (!normalizedState.self.ready) {
          readyBtn.style.display = 'block';
          waitingMsg.textContent = 'Click "I\'m Ready!" when you\'re ready to start';
        } else if (!normalizedState.opponent.ready) {
          readyBtn.style.display = 'none';
          waitingMsg.textContent = 'Waiting for the other player to be ready...';
        } else {
          readyBtn.style.display = 'none';
        }
      } else {
        // Legacy format fallback
      document.getElementById('playerAName').textContent = gameState.playerA || '-';
      document.getElementById('playerBName').textContent = gameState.playerB || '-';
      
      const playerAReady = document.getElementById('playerAReady');
      const playerBReady = document.getElementById('playerBReady');
      
      playerAReady.textContent = gameState.readyA ? '(Ready)' : '(Not Ready)';
      playerBReady.textContent = gameState.readyB ? '(Ready)' : '(Not Ready)';
      playerAReady.className = gameState.readyA ? 'ready-status ready' : 'ready-status not-ready';
      playerBReady.className = gameState.readyB ? 'ready-status ready' : 'ready-status not-ready';
      
      // Show ready button if this player isn't ready yet
      const readyBtn = document.getElementById('readyBtn');
      const waitingMsg = document.getElementById('waitingMessage');
      
      if (playerSeat === 0 && !gameState.readyA) {
        readyBtn.style.display = 'block';
        waitingMsg.textContent = 'Click "I\'m Ready!" when you\'re ready to start';
      } else if (playerSeat === 1 && !gameState.readyB) {
        readyBtn.style.display = 'block';
        waitingMsg.textContent = 'Click "I\'m Ready!" when you\'re ready to start';
      } else if (!gameState.readyA || !gameState.readyB) {
        readyBtn.style.display = 'none';
        waitingMsg.textContent = 'Waiting for the other player to be ready...';
        } else {
        readyBtn.style.display = 'none';
        waitingMsg.textContent = 'Both players ready! Starting game...';
        }
      }
    }

    function showGame() {
      showScreen('gameScreen');
    }

    // Add all other necessary game functions here...
    // (This is a simplified version - the full version would include all the render functions, game logic, etc.)

    // Auto-refresh every 2 seconds when there's an active match
    let refreshInterval;
    function startAutoRefresh() {
      if (refreshInterval) clearInterval(refreshInterval);
      refreshInterval = setInterval(async () => {
        if (matchId) {
          try {
            await refresh();
          } catch (e) {
            console.log('Auto-refresh failed:', e);
          }
        }
      }, 2000);
    }

    function stopAutoRefresh() {
      if (refreshInterval) {
        clearInterval(refreshInterval);
        refreshInterval = null;
      }
    }

    // Add event listeners for game controls
    document.getElementById('readyBtn').onclick = setReady;
    document.getElementById('copyMatchIdBtn').onclick = copyMatchId;

    async function setReady() {
      console.log('🎯 READY DEBUG: setReady() called');
      
      try {
        // First, send timer settings if user is host and has configured them
        const timerConfig = document.getElementById('timerConfig');
        console.log('🎯 READY DEBUG: timerConfig =', timerConfig);
        console.log('🎯 READY DEBUG: timerConfig.style.display =', timerConfig ? timerConfig.style.display : 'N/A');
        
        if (timerConfig && timerConfig.style.display !== 'none') {
          console.log('⏰ Host is setting ready - sending timer settings first...');
          
          // If we have pending timer settings, use those, otherwise get current values
          if (window.pendingTimerSettings) {
            console.log('⏰ Using pending timer settings:', window.pendingTimerSettings);
            
            // Send the pending settings now that we have matchId and token
            try {
              const response = await fetch(`/api/matches/${matchId}/timer-settings`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'X-Player-Token': playerToken
                },
                body: JSON.stringify(window.pendingTimerSettings)
              });
              
              if (response.ok) {
                console.log('✅ Pending timer settings sent successfully');
                delete window.pendingTimerSettings;
              } else {
                const errorText = await response.text();
                console.warn('❌ Failed to send pending timer settings:', errorText);
              }
            } catch (error) {
              console.error('❌ Error sending pending timer settings:', error);
            }
          } else {
            // Fallback to current updateTimerSettings function
            await updateTimerSettings();
          }
        }
        
        await apiCall('ready');
        log('Ready status sent');
        refresh();
      } catch (error) {
        alert('Failed to set ready status: ' + error.message);
      }
    }

    async function copyMatchId() {
      if (!matchId) return;
      
      try {
        // Copy just the match ID to clipboard
        await navigator.clipboard.writeText(matchId);
        
        // Show temporary feedback
        const btn = document.getElementById('copyMatchIdBtn');
        const originalText = btn.textContent;
        btn.textContent = '✅ Copied!';
        btn.style.backgroundColor = '#28a745';
        
        setTimeout(() => {
          btn.textContent = originalText;
          btn.style.backgroundColor = '';
        }, 1500);
        
        log('Match ID copied to clipboard: ' + matchId);
      } catch (error) {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = matchId;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        
        log('Match ID copied to clipboard (fallback)');
      }
    }


    // Complete game functions implementation
    function renderCard(cardId, cardDef, isSelectable = false, realCardId = null, applyEffectColors = false) {
      const div = document.createElement('div');
      div.className = 'card-tooltip';
      
      const realId = realCardId || cardId;
      const displayId = cardId;
      
      const btn = document.createElement('button');
      btn.className = 'card hand-card' + (isSelectable && (selUp === displayId || selDown === displayId) ? ' selected' : '');
      btn.setAttribute('data-real-id', realId);
      
      if(cardDef){
          const title = document.createElement('div');
          title.className = 'card-title';
          title.textContent = cardDef.name;
          btn.appendChild(title);
          const ul = document.createElement('ul');
          ul.className = 'card-effects';
          
          if (applyEffectColors && gameState) {
            // Apply effect coloring for hand cards - they can go to either player's tableau
            const normalizedState = normalizeGameState(gameState);
            const myTableau = normalizedState.self.tableauCardIds || [];
            const oppTableau = normalizedState.opponent.tableauCardIds || [];
            
            // Use the realId for tableau calculations
            const cardTableauId = realId;
            
            cardDef.tiers.forEach((tier, idx)=>{
               const li=document.createElement('li');
               
               // For hand cards, determine what level this card would have in each tableau
               const myNextLevel = getNextEffectLevel(cardTableauId, myTableau);
               const oppNextLevel = getNextEffectLevel(cardTableauId, oppTableau);
               
               // Determine effect colors - for hand cards, show both colors since either player can get it
               let effectClass = '';
               const actionDescription = tier.actions[0]?.description || '';
               
               // Check if this tier would be active for either player
               const wouldBeActiveForMe = idx === myNextLevel;
               const wouldBeActiveForOpp = idx === oppNextLevel;
               
               if (wouldBeActiveForMe && wouldBeActiveForOpp) {
                 // This tier would be active for BOTH players - show both colors
                 effectClass = 'effect-both';
               } else if (wouldBeActiveForMe) {
                 // This tier would be active only for ME - show blue
                 effectClass = 'effect-mine';
               } else if (wouldBeActiveForOpp) {
                 // This tier would be active only for OPPONENT - show orange
                 effectClass = 'effect-opponent';
               }
               
               li.className = effectClass;
               li.innerHTML = (idx+1)+'. '+ actionDescription;
               ul.appendChild(li);
            });
          } else {
            // Original rendering without colors
          cardDef.tiers.forEach((tier, idx)=>{
             const li=document.createElement('li');
             li.innerHTML = (idx+1)+'. '+ (tier.actions[0]?.description || '');
             ul.appendChild(li);
          });
          }
          btn.appendChild(ul);
      } else {
          btn.textContent = displayId;
      }
      
      const canSelect = isSelectable && (!gameState || !gameState.waitingForOpponentChoice);
      
      if (canSelect) {
        // Make card draggable
        btn.draggable = true;
        console.log('DEBUG renderCard: Made card draggable:', realId, 'canSelect:', canSelect);
        
        // Add drag event listeners
        btn.addEventListener('dragstart', (e) => {
          console.log('DEBUG dragstart: Starting drag for card:', realId);
          e.dataTransfer.setData('text/plain', realId);
          btn.classList.add('dragging');
        });
        
        btn.addEventListener('dragend', (e) => {
          console.log('DEBUG dragend: Ending drag for card:', realId);
          btn.classList.remove('dragging');
        });
        
        // Keep click functionality as backup
        btn.onclick = () => {
          if (!selUp) selUp = realId;
          else if (!selDown && realId !== selUp) selDown = realId; 
          else { selUp = realId; selDown = null; }
          document.getElementById('selUp').textContent = selUp || '-';
          document.getElementById('selDown').textContent = selDown || '-';
          updateCardSelection();
        };
      }
      
      if (cardDef) {
        const tooltip = document.createElement('div');
        tooltip.className = 'tooltip-content';
        tooltip.innerHTML = generateCardTooltip(cardDef);
        div.appendChild(tooltip);
      }
      
      div.appendChild(btn);
      return div;
    }

    function generateCardTooltip(cardDef) {
      let html = `<strong>${cardDef.name}</strong><br>`;
      html += `Tags: ${cardDef.tags.join(', ')}<br><br>`;
      
      cardDef.tiers.forEach((tier, index) => {
        html += `<strong>Tier ${index + 1}:</strong><br>`;
        tier.actions.forEach(action => {
          if (action.description && action.description.trim() !== '') {
            html += `• ${action.description}<br>`;
          }
        });
        html += '<br>';
      });
      
      return html;
    }

    function getNextEffectLevel(cardId, playerTableau) {
      if (!cardId || !playerTableau) return 0;
      const count = playerTableau.filter(id => id === cardId).length;
      console.log(`Effect level calculation: cardId=${cardId}, tableau=[${playerTableau.join(', ')}], count=${count}, nextLevel=${Math.min(count, 2)}`);
      return Math.min(count, 2); // 0, 1, or 2 (tiers are 0-indexed)
    }

    function generateEffectsHTMLWithHighlighting(cardDef, myTableau, oppTableau) {
      if (!cardDef) return 'Unknown card';
      
      // The card being evaluated (from choice panel) needs to be matched against tableau IDs
      // We need to find what ID this card would have in the tableau
      const cardId = findCardIdInTableau(cardDef, myTableau, oppTableau);
      
      let html = '<ul class="card-effects">';
      cardDef.tiers.forEach((tier, index) => {
        tier.actions.forEach(action => {
          if (action.description && action.description.trim() !== '') {
            const myNextLevel = getNextEffectLevel(cardId, myTableau);
            const oppNextLevel = getNextEffectLevel(cardId, oppTableau);
            
            let className = '';
            if (index === myNextLevel) {
              className = 'effect-mine';
            } else if (index === oppNextLevel) {
              className = 'effect-opponent';
            }
            
            html += `<li class="${className}"><strong>Tier ${index + 1}:</strong> ${action.description}</li>`;
          }
        });
      });
      html += '</ul>';
      return html;
    }
    
    function findCardIdInTableau(cardDef, myTableau, oppTableau) {
      // Find the tableau ID that corresponds to this card
      const allTableauIds = [...myTableau, ...oppTableau];
      
      // Look for a tableau ID whose definition matches this card's name
      for (const tableauId of allTableauIds) {
        const tableauCardDef = gameState.cardDefinitions[tableauId];
        if (tableauCardDef && tableauCardDef.name === cardDef.name) {
          console.log(`✅ Found match: ${cardDef.name} → ${tableauId}`);
          return tableauId;
        }
      }
      
      console.log(`❌ No match found for ${cardDef.name} in tableaus:`, {
        cardName: cardDef.name,
        myTableau: myTableau,
        oppTableau: oppTableau,
        cardDefinitions: Object.keys(gameState.cardDefinitions).map(id => ({
          id: id,
          name: gameState.cardDefinitions[id]?.name
        }))
      });
      
      // Fallback to card definition ID or name
      return cardDef.id || cardDef.name;
    }

    function generateEffectsHTML(cardDef) {
      if (!cardDef) return 'Unknown card';
      
      let html = '<ul class="card-effects">';
      cardDef.tiers.forEach((tier, index) => {
        tier.actions.forEach(action => {
          if (action.description && action.description.trim() !== '') {
            html += `<li><strong>Tier ${index + 1}:</strong> ${action.description}</li>`;
          }
        });
      });
      html += '</ul>';
      return html;
    }

    function updateCardSelection() {
      const handCards = document.querySelectorAll('.hand .card');
      handCards.forEach(card => {
        const realId = card.getAttribute('data-real-id');
        if (realId === selUp || realId === selDown) {
          card.classList.add('selected');
        } else {
          card.classList.remove('selected');
        }
      });
      
      // Update card previews
      updateCardPreviews();
    }
    
    function updateCardPreviews() {
      const faceUpPreview = document.getElementById('faceUpPreview');
      const faceDownPreview = document.getElementById('faceDownPreview');
      
      // Clear previous content and reset classes
      faceUpPreview.innerHTML = '<div class="placeholder">Drag a card here</div>';
      faceUpPreview.className = 'card-preview';
      faceDownPreview.innerHTML = '<div class="placeholder">Drag a card here</div>';
      faceDownPreview.className = 'card-preview';
      
      // Render face up card details if selected
      if (selUp && gameState && gameState.cardDefinitions) {
        const cardDef = gameState.cardDefinitions[selUp];
        if (cardDef) {
          faceUpPreview.innerHTML = createCardPreviewContent(cardDef, selUp); // Pass real ID
          faceUpPreview.className = 'card-preview has-card';
        }
      }
      
      // Render face down card details if selected
      if (selDown && gameState && gameState.cardDefinitions) {
        const cardDef = gameState.cardDefinitions[selDown];
        if (cardDef) {
          faceDownPreview.innerHTML = createCardPreviewContent(cardDef, selDown); // Pass real ID
          faceDownPreview.className = 'card-preview has-card';
        }
      }
    }
    
    function createCardPreviewContent(cardDef, realCardId = null) {
      // Create card content using the same style as hand cards
      const div = document.createElement('div');
      div.className = 'card-preview-content';
      
      // Card title
      const title = document.createElement('div');
      title.className = 'card-title';
      title.textContent = cardDef.name;
      div.appendChild(title);
      
      // Card effects with same coloring system as hand cards
      const ul = document.createElement('ul');
      ul.className = 'card-effects';
      
      // Get tableau information for effect level calculation
      const normalizedState = normalizeGameState(gameState);
      const myTableau = normalizedState.self.tableauCardIds || [];
      const oppTableau = normalizedState.opponent.tableauCardIds || [];
      
      // Use the real card ID for tableau calculations (not card name)
      const cardId = realCardId || cardDef.name;
      const myNextLevel = getNextEffectLevel(cardId, myTableau);
      const oppNextLevel = getNextEffectLevel(cardId, oppTableau);
      
      console.log('DEBUG createCardPreviewContent: cardId =', cardId, 'cardName =', cardDef.name);
      console.log('DEBUG createCardPreviewContent: myTableau =', myTableau);
      console.log('DEBUG createCardPreviewContent: oppTableau =', oppTableau);
      console.log('DEBUG createCardPreviewContent: myNextLevel =', myNextLevel, 'oppNextLevel =', oppNextLevel);
      
      cardDef.tiers.forEach((tier, idx) => {
        const li = document.createElement('li');
        
        // Use EXACT same logic as hand cards
        const wouldBeActiveForMe = idx === myNextLevel;
        const wouldBeActiveForOpp = idx === oppNextLevel;
        
        let effectClass = '';
        if (wouldBeActiveForMe && wouldBeActiveForOpp) {
          effectClass = 'effect-both';
        } else if (wouldBeActiveForMe) {
          effectClass = 'effect-mine';
        } else if (wouldBeActiveForOpp) {
          effectClass = 'effect-opponent';
        }
        
        console.log('DEBUG createCardPreviewContent: tier', idx+1, 'wouldBeActiveForMe =', wouldBeActiveForMe, 'wouldBeActiveForOpp =', wouldBeActiveForOpp, 'effectClass =', effectClass);
        
        li.className = effectClass;
        li.innerHTML = (idx + 1) + '. ' + (tier.actions[0]?.description || '');
        ul.appendChild(li);
      });
      
      div.appendChild(ul);
      return div.outerHTML;
    }
    
    function updateChooseButtons() {
      const chooseFaceUp = document.getElementById('chooseFaceUp');
      const chooseFaceDown = document.getElementById('chooseFaceDown');
      const playBtn = document.getElementById('playBtn');
      
      if (!gameState) return;
      
      const isOpponentPickPhase = gameState.phase === 'OPPONENT_PICK';
      const isPlayTwoCardsPhase = gameState.phase === 'PLAY_TWO_CARDS';
      
      if (isOpponentPickPhase) {
        // In opponent pick phase, always enable buttons (cards are already selected by active player)
        if (chooseFaceUp) {
          chooseFaceUp.disabled = false;
          chooseFaceUp.style.display = 'block';
        }
        if (chooseFaceDown) {
          chooseFaceDown.disabled = false;
          chooseFaceDown.style.display = 'block';
        }
        if (playBtn) playBtn.style.display = 'none';
      } else if (isPlayTwoCardsPhase) {
        // In play two cards phase, show play button when both cards are selected
        if (chooseFaceUp) chooseFaceUp.style.display = 'none';
        if (chooseFaceDown) chooseFaceDown.style.display = 'none';
        if (playBtn) {
          playBtn.style.display = selUp && selDown ? 'block' : 'none';
        }
      } else {
        // Other phases - disable everything
        if (chooseFaceUp) {
          chooseFaceUp.disabled = true;
          chooseFaceUp.style.display = 'block';
        }
        if (chooseFaceDown) {
          chooseFaceDown.disabled = true;
          chooseFaceDown.style.display = 'block';
        }
        if (playBtn) playBtn.style.display = 'none';
      }
    }
    
    function updateCentralPanelVisibility() {
      const cardSelectionPanel = document.getElementById('cardSelectionPanel');
      if (!cardSelectionPanel || !gameState) return;
      
      // Always show the panel, but control interaction based on phase and player
      cardSelectionPanel.style.display = 'block';
      
      const normalizedState = normalizeGameState(gameState);
      const isOpponentPickPhase = normalizedState.phase === 'OPPONENT_PICK';
      const isPlayTwoCardsPhase = normalizedState.phase === 'PLAY_TWO_CARDS';
      const isMyTurn = normalizedState.isMyTurn;
      const isWaitingForChoice = normalizedState.waitingForOpponentChoice;
      
      console.log('DEBUG updateCentralPanelVisibility: phase =', normalizedState.phase, 'isMyTurn =', isMyTurn, 'waitingForChoice =', isWaitingForChoice, 'canChooseCards =', normalizedState.canChooseCards);
      
      if (isOpponentPickPhase && normalizedState.canChooseCards) {
        // We can choose between the two cards (we're the opponent)
        enableCentralPanelInteraction(true);
        updatePanelTitle('Choose Between These Cards');
      } else if (isOpponentPickPhase && !normalizedState.canChooseCards) {
        // We submitted the cards, waiting for opponent to choose
        enableCentralPanelInteraction(false);
        updatePanelTitle('Waiting for Opponent to Choose...');
      } else if (isPlayTwoCardsPhase && isMyTurn) {
        // We can select two cards to play
        enableCentralPanelInteraction(true);
        updatePanelTitle('Select Your Cards to Play');
      } else if (isPlayTwoCardsPhase && !isMyTurn) {
        // Opponent's turn to play cards
        enableCentralPanelInteraction(false);
        updatePanelTitle('Opponent is Playing...');
      } else {
        // Other cases
        enableCentralPanelInteraction(false);
        updatePanelTitle('Waiting...');
      }
    }
    
    function updatePanelTitle(title) {
      const panelTitle = document.querySelector('#cardSelectionPanel h3');
      if (panelTitle) {
        panelTitle.textContent = title;
      }
    }
    
    function enableCentralPanelInteraction(enabled) {
      const faceUpPreview = document.getElementById('faceUpPreview');
      const faceDownPreview = document.getElementById('faceDownPreview');
      const chooseFaceUp = document.getElementById('chooseFaceUp');
      const chooseFaceDown = document.getElementById('chooseFaceDown');
      
      if (enabled) {
        // Enable drag and drop
        if (faceUpPreview) faceUpPreview.style.pointerEvents = 'auto';
        if (faceDownPreview) faceDownPreview.style.pointerEvents = 'auto';
        
        // Enable choose buttons based on current phase
        const isOpponentPickPhase = gameState && gameState.phase === 'OPPONENT_PICK';
        const isPlayTwoCardsPhase = gameState && gameState.phase === 'PLAY_TWO_CARDS';
        
        if (isOpponentPickPhase) {
          // In opponent pick phase, always enable buttons (cards are already selected by active player)
          if (chooseFaceUp) chooseFaceUp.disabled = false;
          if (chooseFaceDown) chooseFaceDown.disabled = false;
        } else if (isPlayTwoCardsPhase) {
          // In play two cards phase, show play button when both cards are selected
          if (chooseFaceUp) chooseFaceUp.style.display = 'none';
          if (chooseFaceDown) chooseFaceDown.style.display = 'none';
          // Show play button instead
          const playBtn = document.getElementById('playBtn');
          if (playBtn) {
            playBtn.style.display = selUp && selDown ? 'block' : 'none';
          }
        }
      } else {
        // Disable drag and drop
        if (faceUpPreview) faceUpPreview.style.pointerEvents = 'none';
        if (faceDownPreview) faceDownPreview.style.pointerEvents = 'none';
        
        // Disable all buttons
        if (chooseFaceUp) {
          chooseFaceUp.disabled = true;
          chooseFaceUp.style.display = 'block';
        }
        if (chooseFaceDown) {
          chooseFaceDown.disabled = true;
          chooseFaceDown.style.display = 'block';
        }
        const playBtn = document.getElementById('playBtn');
        if (playBtn) playBtn.style.display = 'none';
      }
    }
    
    function setupDragAndDrop() {
      const faceUpPreview = document.getElementById('faceUpPreview');
      const faceDownPreview = document.getElementById('faceDownPreview');
      
      if (!faceUpPreview || !faceDownPreview) return;
      
      // Face Up drop zone
      faceUpPreview.addEventListener('dragover', (e) => {
        e.preventDefault();
        if (faceUpPreview.style.pointerEvents !== 'none') {
          faceUpPreview.classList.add('drag-over');
        }
      });
      
      faceUpPreview.addEventListener('dragleave', (e) => {
        faceUpPreview.classList.remove('drag-over');
      });
      
      faceUpPreview.addEventListener('drop', (e) => {
        e.preventDefault();
        faceUpPreview.classList.remove('drag-over');
        
        if (faceUpPreview.style.pointerEvents !== 'none') {
          const cardId = e.dataTransfer.getData('text/plain');
          if (cardId) {
            selUp = cardId;
            updateCardSelection();
            updateCardPreviews();
            updateChooseButtons();
          }
        }
      });
      
      // Face Down drop zone
      faceDownPreview.addEventListener('dragover', (e) => {
        e.preventDefault();
        if (faceDownPreview.style.pointerEvents !== 'none') {
          faceDownPreview.classList.add('drag-over');
        }
      });
      
      faceDownPreview.addEventListener('dragleave', (e) => {
        faceDownPreview.classList.remove('drag-over');
      });
      
      faceDownPreview.addEventListener('drop', (e) => {
        e.preventDefault();
        faceDownPreview.classList.remove('drag-over');
        
        if (faceDownPreview.style.pointerEvents !== 'none') {
          const cardId = e.dataTransfer.getData('text/plain');
          if (cardId) {
            selDown = cardId;
            updateCardSelection();
            updateCardPreviews();
            updateChooseButtons();
          }
        }
      });
      
      // Choose button event listeners
      const chooseFaceUp = document.getElementById('chooseFaceUp');
      const chooseFaceDown = document.getElementById('chooseFaceDown');
      
      if (chooseFaceUp) {
        chooseFaceUp.addEventListener('click', () => {
          if (!chooseFaceUp.disabled) {
            // Handle face up selection
            console.log('Chose face up card');
            // Submit the choice to the backend
            submitOpponentChoice('faceUp');
          }
        });
      }
      
      if (chooseFaceDown) {
        chooseFaceDown.addEventListener('click', () => {
          if (!chooseFaceDown.disabled) {
            // Handle face down selection
            console.log('Chose face down card');
            // Submit the choice to the backend
            submitOpponentChoice('faceDown');
          }
        });
      }
    }

    // Prevent multiple simultaneous submissions
    let isSubmittingChoice = false;
    
    async function submitOpponentChoice(choice) {
      if (!matchId || !gameState) {
        console.error('Missing matchId or gameState:', { matchId, gameState: !!gameState });
        return;
      }
      
      // Prevent multiple simultaneous submissions
      if (isSubmittingChoice) {
        // console.log('Choice already being submitted, ignoring duplicate');
        return;
      }
      
      isSubmittingChoice = true;
      
      try {
        const chooseFaceUp = choice === 'faceUp';
        const body = { chooseFaceUp: chooseFaceUp };
        
        console.log('Submitting opponent choice:', {
          choice,
          chooseFaceUp,
          body,
          currentPhase: gameState.phase,
          playerSeat
        });
        
        const response = await apiCall('choose', body);
        
          console.log('Opponent choice submitted successfully');
        console.log('New game state:', response);
        
        // apiCall already updates gameState, so just refresh UI
          await refresh();
      } catch (error) {
        console.error('Error submitting opponent choice:', error);
      } finally {
        isSubmittingChoice = false;
      }
    }

    function renderHands() {
      console.log('DEBUG renderHands: Starting renderHands');
      console.log('DEBUG renderHands: gameState =', gameState);
      console.log('DEBUG renderHands: playerSeat =', playerSeat);
      
      if (!gameState || playerSeat === null) {
        console.log('DEBUG renderHands: Early return - gameState:', !!gameState, 'playerSeat:', playerSeat);
        return;
      }
      
      // Normalize gameState to handle both legacy and new formats
      const normalizedState = normalizeGameState(gameState);
      console.log('DEBUG renderHands: normalizedState =', normalizedState);
      console.log('DEBUG renderHands: self.handCardIds =', normalizedState.self.handCardIds);
      
      // UPDATED: New layout mapping - handA = self, handB = opponent
      // playerA section = "Your Area" (bottom), playerB section = "Opponent Area" (top)
      const myHandDiv = document.getElementById('handA');     // Your hand
      const oppHandDiv = document.getElementById('handB');    // Opponent hand
      
      console.log('DEBUG renderHands: myHandDiv =', myHandDiv);
      console.log('DEBUG renderHands: oppHandDiv =', oppHandDiv);
      
      // Clear both hands
      myHandDiv.innerHTML = '';
      oppHandDiv.innerHTML = '';
      
      // Render my hand with real cards
      console.log('DEBUG renderHands: Checking self.handCardIds:', normalizedState.self.handCardIds);
      if (normalizedState.self.handCardIds && normalizedState.self.handCardIds.length > 0) {
        console.log('DEBUG renderHands: Found', normalizedState.self.handCardIds.length, 'cards to render');
        const cardCounts = {};
        normalizedState.self.handCardIds.forEach(id => {
          cardCounts[id] = (cardCounts[id] || 0) + 1;
        });
        
        console.log('DEBUG renderHands: Card counts:', cardCounts);
        Object.keys(cardCounts).forEach(id => {
          const count = cardCounts[id];
          const cardDef = normalizedState.cardDefinitions[id];
          console.log('DEBUG renderHands: Rendering card', id, 'count:', count, 'def:', cardDef);
          for (let i = 0; i < count; i++) {
            const uniqueId = count > 1 ? `${id}_${i}` : id;
            const cardElement = renderCard(uniqueId, cardDef, true, id, true); // Enable effect colors
            console.log('DEBUG renderHands: Created card element:', cardElement);
            myHandDiv.appendChild(cardElement);
          }
        });
        console.log('DEBUG renderHands: My hand div after rendering:', myHandDiv.innerHTML);
        console.log('DEBUG renderHands: My hand div children count:', myHandDiv.children.length);
      } else {
        console.log('DEBUG renderHands: No cards to render or self.handCardIds is empty');
      }
      
      // Render opponent hand - show revealed cards if any, otherwise show card backs
      const oppHandSize = normalizedState.opponent.handSize;
      const revealedCards = normalizedState.opponent.revealedCards;
      
      let revealedCardIndex = 0;
      for (let i = 0; i < oppHandSize; i++) {
        // Check if we have revealed cards to show
        if (revealedCards && revealedCardIndex < revealedCards.length) {
          const cardId = revealedCards[revealedCardIndex];
          const cardDef = gameState.cardDefinitions[cardId];
          
          if (cardDef) {
            // Create revealed card
            const revealedCard = document.createElement('div');
            revealedCard.className = 'card-tooltip revealed-card';
            revealedCard.style.width = '140px';
            revealedCard.style.height = '160px';
            revealedCard.style.border = '2px solid #4caf50';
            revealedCard.style.borderRadius = '12px';
            revealedCard.style.background = 'linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%)';
            revealedCard.style.position = 'relative';
            revealedCard.setAttribute('data-real-id', cardId);
            
            const title = document.createElement('div');
            title.className = 'card-title';
            title.style.fontWeight = 'bold';
            title.style.marginBottom = '6px';
            title.style.fontSize = '12px';
            title.textContent = cardDef.name;
            revealedCard.appendChild(title);
            
            const ul = document.createElement('ul');
            ul.className = 'card-effects';
            ul.style.listStyle = 'none';
            ul.style.padding = '0';
            ul.style.margin = '0';
            ul.style.fontSize = '10px';
            cardDef.tiers.forEach((tier, idx) => {
              const li = document.createElement('li');
              li.style.marginBottom = '2px';
              li.innerHTML = (idx + 1) + '. ' + (tier.actions[0]?.description || '');
              ul.appendChild(li);
            });
            revealedCard.appendChild(ul);
            
            // Add a "revealed" indicator
            const revealedIndicator = document.createElement('div');
            revealedIndicator.style.position = 'absolute';
            revealedIndicator.style.top = '5px';
            revealedIndicator.style.right = '5px';
            revealedIndicator.style.background = '#4caf50';
            revealedIndicator.style.color = 'white';
            revealedIndicator.style.borderRadius = '50%';
            revealedIndicator.style.width = '20px';
            revealedIndicator.style.height = '20px';
            revealedIndicator.style.display = 'flex';
            revealedIndicator.style.alignItems = 'center';
            revealedIndicator.style.justifyContent = 'center';
            revealedIndicator.style.fontSize = '12px';
            revealedIndicator.textContent = '👁';
            revealedCard.appendChild(revealedIndicator);
            
            oppHandDiv.appendChild(revealedCard);
            revealedCardIndex++;
          } else {
            // Fallback to card back if card definition not found
            const cardBack = createCardBack();
            oppHandDiv.appendChild(cardBack);
          }
        } else {
          // Show regular card back
          const cardBack = createCardBack();
          oppHandDiv.appendChild(cardBack);
        }
      }
      
      function createCardBack() {
        const cardBack = document.createElement('div');
        cardBack.className = 'card-tooltip';
        cardBack.style.width = '140px';
        cardBack.style.height = '160px';
        cardBack.style.border = '2px solid #666';
        cardBack.style.borderRadius = '12px';
        cardBack.style.backgroundColor = '#333';
        cardBack.style.display = 'flex';
        cardBack.style.alignItems = 'center';
        cardBack.style.justifyContent = 'center';
        cardBack.style.fontSize = '24px';
        cardBack.style.color = '#fff';
        cardBack.textContent = '?';
        return cardBack;
      }
    }
    function renderActiveEffects() {
      const normalizedState = normalizeGameState(gameState);
      
      // Render self active effects
      const selfEffectsDiv = document.getElementById('statusEffectsListA');
      const oppEffectsDiv = document.getElementById('statusEffectsListB');
      
      if (selfEffectsDiv) {
        selfEffectsDiv.innerHTML = '';
        const selfEffects = normalizedState.self.activeStatuses || {};
        
        Object.entries(selfEffects).forEach(([effectName, value]) => {
          const effectElement = document.createElement('div');
          effectElement.className = 'status-effect self-effect';
          effectElement.innerHTML = `
            <span class="effect-name">${effectName}</span>
            <span class="effect-value">${value > 0 ? '+' : ''}${value}</span>
          `;
          selfEffectsDiv.appendChild(effectElement);
        });
        
        if (Object.keys(selfEffects).length === 0) {
          const noEffectsElement = document.createElement('div');
          noEffectsElement.className = 'no-effects';
          noEffectsElement.textContent = 'No active effects';
          selfEffectsDiv.appendChild(noEffectsElement);
        }
      }
      
      // Render opponent active effects
      if (oppEffectsDiv) {
        oppEffectsDiv.innerHTML = '';
        const oppEffects = normalizedState.opponent.activeStatuses || {};
        
        Object.entries(oppEffects).forEach(([effectName, value]) => {
          const effectElement = document.createElement('div');
          effectElement.className = 'status-effect opponent-effect';
          effectElement.innerHTML = `
            <span class="effect-name">${effectName}</span>
            <span class="effect-value">${value > 0 ? '+' : ''}${value}</span>
          `;
          oppEffectsDiv.appendChild(effectElement);
        });
        
        if (Object.keys(oppEffects).length === 0) {
          const noEffectsElement = document.createElement('div');
          noEffectsElement.className = 'no-effects';
          noEffectsElement.textContent = 'No active effects';
          oppEffectsDiv.appendChild(noEffectsElement);
        }
      }
    }

    function renderTableaus() {
      if (!gameState || playerSeat === null) return;
      
      // Normalize gameState to handle both legacy and new formats
      const normalizedState = normalizeGameState(gameState);
      
      // UPDATED: New layout mapping - tableauA = self, tableauB = opponent  
      // playerA section = "Your Area" (bottom), playerB section = "Opponent Area" (top)
      const myTableauDiv = document.getElementById('tableauA');     // Your tableau
      const oppTableauDiv = document.getElementById('tableauB');    // Opponent tableau
      
      // Get the correct tableau data from normalized state
      const myTableauIds = normalizedState.self.tableauCardIds || [];
      const oppTableauIds = normalizedState.opponent.tableauCardIds || [];
      const myRecentlyAdded = normalizedState.self.recentlyAddedCards || [];
      const oppRecentlyAdded = normalizedState.opponent.recentlyAddedCards || [];
      
      console.log('DEBUG renderTableaus: myTableauIds =', myTableauIds);
      console.log('DEBUG renderTableaus: oppTableauIds =', oppTableauIds);
      console.log('DEBUG renderTableaus: myRecentlyAdded =', myRecentlyAdded);
      console.log('DEBUG renderTableaus: oppRecentlyAdded =', oppRecentlyAdded);
      
      // Clear both tableaus
      myTableauDiv.innerHTML = '';
      oppTableauDiv.innerHTML = '';
      
      // Clear any existing newly-added classes from previous renders
      document.querySelectorAll('.newly-added').forEach(element => {
        element.classList.remove('newly-added');
      });
      
      // Render my tableau
      const cardCountsMy = {};
      myTableauIds.forEach(id => {
        cardCountsMy[id] = (cardCountsMy[id] || 0) + 1;
      });
      
      Object.keys(cardCountsMy).forEach(id => {
        const count = cardCountsMy[id];
        const cardDef = normalizedState.cardDefinitions[id];
        const stackedCard = renderStackedCard(id, cardDef, count, 'self');
        myTableauDiv.appendChild(stackedCard);
      });
      
      // Render opponent tableau
      const cardCountsOpp = {};
      oppTableauIds.forEach(id => {
        cardCountsOpp[id] = (cardCountsOpp[id] || 0) + 1;
      });
      
      Object.keys(cardCountsOpp).forEach(id => {
        const count = cardCountsOpp[id];
        const cardDef = normalizedState.cardDefinitions[id];
        const stackedCard = renderStackedCard(id, cardDef, count, 'opponent');
        oppTableauDiv.appendChild(stackedCard);
      });
      
      // Also render active effects
      renderActiveEffects();
    }
    
    // Global variable to store all effects for persistent log
    let allEffects = [];
    let lastEffectCount = 0;

    function renderEffectFeedback() {
      console.log('DEBUG renderEffectFeedback: gameState =', gameState);
      console.log('DEBUG renderEffectFeedback: recentEffects =', gameState?.recentEffects);
      
      if (!gameState || !gameState.recentEffects) {
        console.log('DEBUG renderEffectFeedback: No gameState or recentEffects, returning');
        return;
      }
      
      // Add new effects to the persistent log and show as toasts
      if (gameState.recentEffects.length > lastEffectCount) {
        const newEffects = gameState.recentEffects.slice(lastEffectCount);
        allEffects = allEffects.concat(newEffects);
        lastEffectCount = gameState.recentEffects.length;
        
        // Keep only last 50 effects
        if (allEffects.length > 50) {
          allEffects = allEffects.slice(-50);
        }
        
        // Show new effects as toasts
        newEffects.forEach(effect => {
          const playerName = effect.playerName || 'Unknown';
          const effectDescription = effect.effectDescription || 'No description';
          const dotChange = effect.dotChange || 0;
          
          let message = `${playerName}: ${effectDescription}`;
          if (dotChange !== 0) {
            message += ` (${dotChange > 0 ? '+' : ''}${dotChange} dots)`;
          }
          
          showToast(message, 'effect', 4000);
        });
      }
      
      console.log('DEBUG renderEffectFeedback: All effects =', allEffects);
    }
    
    function renderStatusEffects() {
      if (!gameState) return;
      
      // Get status effects for both players
      const statusEffectsA = gameState.activeStatusesA || {};
      const statusEffectsB = gameState.activeStatusesB || {};
      
      // Render Player A status effects
      renderPlayerStatusEffects('statusEffectsListA', statusEffectsA);
      
      // Render Player B status effects
      renderPlayerStatusEffects('statusEffectsListB', statusEffectsB);
    }
    
    function renderPlayerStatusEffects(containerId, statusEffects) {
      const container = document.getElementById(containerId);
      if (!container) return;
      
      // Clear previous status effects
      container.innerHTML = '';
      
      // If no status effects, hide the container
      if (Object.keys(statusEffects).length === 0) {
        container.parentElement.style.display = 'none';
        return;
      }
      
      // Show the container
      container.parentElement.style.display = 'block';
      
      // Render each status effect
      Object.entries(statusEffects).forEach(([statusType, duration]) => {
        const statusElement = document.createElement('div');
        statusElement.className = 'status-effect';
        
        // Add specific class based on status type
        let tooltipText = '';
        switch (statusType) {
          case 'SHIELD':
            statusElement.classList.add('shield');
            statusElement.innerHTML = '<span class="status-effect-icon">🛡️</span> Escudo';
            tooltipText = 'Protege contra el próximo daño o efecto negativo';
            break;
          case 'THORNS':
            statusElement.classList.add('thorns');
            statusElement.innerHTML = '<span class="status-effect-icon">🌵</span> Espinas';
            tooltipText = 'Daña al oponente cuando te ataca';
            break;
          case 'REFLECT_ALL_DAMAGE':
            statusElement.classList.add('reflect');
            statusElement.innerHTML = '<span class="status-effect-icon">↩️</span> Reflejo';
            tooltipText = 'Refleja todo el daño de vuelta al atacante';
            break;
          case 'SHIELD_NEXT_PUSH_AGAINST_YOU':
            statusElement.classList.add('shield');
            statusElement.innerHTML = '<span class="status-effect-icon">🛡️</span> Escudo Push';
            tooltipText = 'Protege contra el próximo push negativo';
            break;
          case 'REFLECT_NEXT_PUSH':
            statusElement.classList.add('reflect');
            statusElement.innerHTML = '<span class="status-effect-icon">↩️</span> Reflejo Push';
            tooltipText = 'Refleja el próximo push de vuelta al oponente';
            break;
          case 'RANDOMIZE_NEXT_CARD_EFFECT':
            statusElement.classList.add('random');
            statusElement.innerHTML = '<span class="status-effect-icon">🎲</span> Aleatorio';
            tooltipText = 'La próxima carta tendrá un efecto aleatorio';
            break;
          case 'GLOBAL_RANDOM_EFFECTS':
            statusElement.classList.add('global');
            statusElement.innerHTML = '<span class="status-effect-icon">🌪️</span> Caos Global';
            tooltipText = 'Todos los efectos de cartas serán aleatorios';
            break;
          default:
            statusElement.innerHTML = `<span class="status-effect-icon">❓</span> ${statusType}`;
            tooltipText = `Efecto de estado: ${statusType}`;
        }
        
        // Add tooltip
        const tooltip = document.createElement('div');
        tooltip.className = 'status-effect-tooltip';
        tooltip.textContent = tooltipText;
        statusElement.appendChild(tooltip);
        
        // Add duration if not permanent (-1)
        if (duration !== -1) {
          const durationElement = document.createElement('span');
          durationElement.className = 'status-effect-duration';
          durationElement.textContent = duration;
          statusElement.appendChild(durationElement);
        }
        
        container.appendChild(statusElement);
      });
    }
    
    function renderCentralCardPanel() {
      // Update phase display
      if (gameState && gameState.phase) {
        const phaseElement = document.getElementById('currentPhase');
        if (phaseElement) {
          phaseElement.textContent = gameState.phase;
        }
      }
      
      // Load selected cards in OPPONENT_PICK phase
      if (gameState && gameState.phase === 'OPPONENT_PICK') {
        loadSelectedCardsForOpponentPick();
      } else {
        // Update card previews for other phases
        updateCardPreviews();
      }
      
      // Update choose buttons
      updateChooseButtons();
    }
    
    function loadSelectedCardsForOpponentPick() {
      const faceUpPreview = document.getElementById('faceUpPreview');
      const faceDownPreview = document.getElementById('faceDownPreview');
      
      if (!faceUpPreview || !faceDownPreview || !gameState) return;
      
      // Get the selected cards from game state
      const selectedFaceUpCard = gameState.faceUpCardId;
      const selectedFaceDownCard = gameState.faceDownCardId;
      
      // Load Face Up Card
      if (selectedFaceUpCard && gameState.cardDefinitions) {
        const cardDef = gameState.cardDefinitions[selectedFaceUpCard];
        if (cardDef) {
          faceUpPreview.innerHTML = createCardPreviewContent(cardDef, selectedFaceUpCard); // Pass real ID
          faceUpPreview.className = 'card-preview has-card';
        }
      } else {
        faceUpPreview.innerHTML = '<div class="placeholder">No card selected</div>';
        faceUpPreview.className = 'card-preview';
      }
      
      // Load Face Down Card (mystery card)
      if (selectedFaceDownCard && gameState.cardDefinitions) {
        const cardDef = gameState.cardDefinitions[selectedFaceDownCard];
        if (cardDef) {
          // Show as mystery card with ???
          faceDownPreview.innerHTML = `
            <div class="card-preview-content">
              <div class="card-preview-name">???</div>
              <div class="card-preview-tiers">
                <div class="tier-preview">
                  <div class="tier-preview-header">Hidden Card</div>
                  <div class="tier-preview-action">This card's effects are hidden</div>
                </div>
              </div>
            </div>
          `;
          faceDownPreview.className = 'card-preview has-card mystery-card';
          // Disable drag and drop for mystery card
          faceDownPreview.style.pointerEvents = 'none';
        }
      } else {
        faceDownPreview.innerHTML = '<div class="placeholder">No card selected</div>';
        faceDownPreview.className = 'card-preview';
        // Disable drag and drop when no card
        faceDownPreview.style.pointerEvents = 'none';
      }
    }
    
    function selectCard(cardId, position) {
      if (position === 'up') {
        selUp = cardId;
      } else {
        selDown = cardId;
      }
      
      updateCardSelection();
      updateCardPreviews();
    }

    function renderStackedCard(cardId, cardDef, count, owner = 'self') {
      const div = document.createElement('div');
      div.className = 'card-tooltip stacked-card';
      
      const btn = document.createElement('button');
      btn.className = 'tableau-card';
      btn.style.width = '140px';
      btn.style.minHeight = '160px';
      btn.style.position='relative';
      
      // Check if this card was recently added using normalized state
      const normalizedState = normalizeGameState(gameState);
      
      // Only use the relevant recently added cards based on owner
      const recentlyAddedCards = owner === 'self' 
        ? (normalizedState.self.recentlyAddedCards || [])
        : (normalizedState.opponent.recentlyAddedCards || []);
      
      // Count how many of this card were recently added for this specific owner
      const recentCount = recentlyAddedCards.filter(id => id === cardId).length;
      
      // Only highlight if this is a recent addition
      const isRecentlyAdded = recentCount > 0;
      
      console.log(`DEBUG renderStackedCard (${owner}): cardId =`, cardId, 'count =', count);
      console.log(`DEBUG renderStackedCard (${owner}): recentlyAddedCards =`, recentlyAddedCards);
      console.log(`DEBUG renderStackedCard (${owner}): recentCount =`, recentCount, 'isRecentlyAdded =', isRecentlyAdded);
      console.log(`DEBUG renderStackedCard (${owner}): cardDef.name =`, cardDef?.name);
      
      if (isRecentlyAdded) {
        btn.classList.add('newly-added');
        // Remove the class after animation completes
        setTimeout(() => {
          btn.classList.remove('newly-added');
        }, 2000);
      }
      
      if(cardDef){
          const title=document.createElement('div');
          title.className='card-title';
          title.textContent=cardDef.name;
          btn.appendChild(title);
          const ul=document.createElement('ul');
          ul.className='card-effects';
          cardDef.tiers.forEach((tier,idx)=>{
              const li=document.createElement('li');
              li.innerHTML=(idx+1)+'. '+(tier.actions[0]?.description||'');
              if(idx===Math.min(count-1,2)) li.classList.add('active');
              ul.appendChild(li);
          });
          btn.appendChild(ul);
      } else {
          btn.textContent=cardId;
      }
      
      // Add count badge if more than 1
      if (count > 1) {
        const badge = document.createElement('span');
        badge.className = 'card-count-badge';
        badge.textContent = count;
        btn.appendChild(badge);
      }
      
      if (cardDef) {
        const tooltip = document.createElement('div');
        tooltip.className = 'tooltip-content';
        tooltip.innerHTML = generateCardTooltip(cardDef);
        div.appendChild(tooltip);
      }
      
      div.appendChild(btn);
      return div;
    }
    function startTurnTimer() {
      clearTimers();
      
      // Use configured timer value from backend, default to 120 seconds
      const normalizedState = normalizeGameState(gameState);
      console.log('🔍 DEBUG startTurnTimer: gameState =', gameState);
      console.log('🔍 DEBUG startTurnTimer: normalizedState.playTwoCardsTimeSeconds =', normalizedState.playTwoCardsTimeSeconds);
      console.log('🔍 DEBUG startTurnTimer: normalizedState =', normalizedState);
      
      turnTimeLeft = normalizedState.playTwoCardsTimeSeconds || 30;
      
      console.log(`🕐 Starting turn timer: ${turnTimeLeft} seconds (PLAY_TWO_CARDS phase)`, {
        configuredValue: normalizedState.playTwoCardsTimeSeconds,
        fallbackUsed: !normalizedState.playTwoCardsTimeSeconds
      });
      updateTimerDisplay();
      
      turnTimer = setInterval(() => {
        turnTimeLeft--;
        updateTimerDisplay();
        
        if (turnTimeLeft <= 0) {
          clearTimers();
          log('Turn timer expired! Auto-selecting random cards...');
          autoSelectRandomCards();
        }
      }, 1000);
    }

    function startChoiceTimer() {
      clearTimers();
      
      // Use configured timer value from backend, default to 60 seconds
      const normalizedState = normalizeGameState(gameState);
      console.log('🔍 DEBUG startChoiceTimer: gameState =', gameState);
      console.log('🔍 DEBUG startChoiceTimer: normalizedState.opponentPickTimeSeconds =', normalizedState.opponentPickTimeSeconds);
      console.log('🔍 DEBUG startChoiceTimer: normalizedState =', normalizedState);
      
      choiceTimeLeft = normalizedState.opponentPickTimeSeconds || 15;
      
      console.log(`🕐 Starting choice timer: ${choiceTimeLeft} seconds (OPPONENT_PICK phase)`, {
        configuredValue: normalizedState.opponentPickTimeSeconds,
        fallbackUsed: !normalizedState.opponentPickTimeSeconds
      });
      updateTimerDisplay();
      
      choiceTimer = setInterval(() => {
        choiceTimeLeft--;
        updateTimerDisplay();
        
        if (choiceTimeLeft <= 0) {
          clearTimers();
          log('Choice timer expired! Auto-selecting random choice...');
          autoSelectRandomChoice();
        }
      }, 1000);
    }
    
    function updateTimerDisplay() {
      const timerElement = document.getElementById('gameTimer');
      if (!timerElement) return;
      
      const currentTime = turnTimer ? turnTimeLeft : choiceTimeLeft;
      timerElement.textContent = currentTime + 's';
      
      // Update timer styling based on time remaining (proportional to timer type)
      timerElement.className = 'timer-display';
      const isChoicePhase = choiceTimer !== null;
      
      if (isChoicePhase) {
        // Choice phase: 60 seconds total
        if (currentTime <= 10) {
          timerElement.classList.add('danger');
        } else if (currentTime <= 20) {
          timerElement.classList.add('warning');
        }
      } else {
        // Turn phase: 120 seconds total  
        if (currentTime <= 20) {
          timerElement.classList.add('danger');
        } else if (currentTime <= 40) {
          timerElement.classList.add('warning');
        }
      }
    }

    function clearTimers() {
      if (turnTimer) {
        clearInterval(turnTimer);
        turnTimer = null;
      }
      if (choiceTimer) {
        clearInterval(choiceTimer);
        choiceTimer = null;
      }
    }

    async function autoSelectRandomCards() {
      if (!matchId || !gameState || gameState.waitingForOpponentChoice) return;
      
      const handIds = gameState.activeHandCardIds;
      if (handIds.length < 2) return;
      
      // Select two random cards
      const random1 = handIds[Math.floor(Math.random() * handIds.length)];
      let random2 = handIds[Math.floor(Math.random() * handIds.length)];
      while (random2 === random1 && handIds.length > 1) {
        random2 = handIds[Math.floor(Math.random() * handIds.length)];
      }
      
      selUp = random1;
      selDown = random2;
      document.getElementById('selUp').textContent = selUp;
      document.getElementById('selDown').textContent = selDown;
      
      // Make the API call
      clearTimers();
      const body = JSON.stringify({ faceUpId: selUp, faceDownId: selDown });
      const url = playerSeat !== null ? 
        api + '/api/match/' + matchId + '/play?seat=' + playerSeat :
        api + '/api/match/' + matchId + '/play';
      gameState = await req(url, { method:'POST', headers:{'Content-Type':'application/json'}, body });
      log('Auto-played: up=' + selUp + ', down=' + selDown);
      
      // Reset selection after playing
      resetSelection();
      
      await refresh();
    }

    async function autoSelectRandomChoice() {
      if (!matchId || !gameState || !gameState.waitingForOpponentChoice) return;
      
      const chooseFaceUpOption = Math.random() < 0.5;
      if (chooseFaceUpOption) {
        await chooseFaceUp();
        } else {
        await chooseFaceDown();
      }
    }

    function resetSelection() {
      selUp = null;
      selDown = null;
      document.getElementById('selUp').textContent = '-';
      document.getElementById('selDown').textContent = '-';
      updateCardSelection();
    }

    function updateUIForPhase() {
      const normalizedState = normalizeGameState(gameState);
      const isWaitingForChoice = normalizedState.waitingForOpponentChoice;
      const phase = normalizedState.phase || 'PLAY_TWO_CARDS';
      // Use the backend-provided isMyTurn flag
      const isMyTurn = normalizedState.isMyTurn;
      
      // Show/hide selection status
      const selectionStatus = document.getElementById('selectionStatus');
      if (selectionStatus) {
        selectionStatus.style.display = isWaitingForChoice ? 'none' : 'block';
      }
      
      // Show/hide buttons
      const playBtn = document.getElementById('playBtn');
      if (playBtn) {
        playBtn.style.display = !isWaitingForChoice ? 'block' : 'none';
      }
      
      // Start appropriate timer only if not already running
      if (isWaitingForChoice && !choiceTimer) {
        startChoiceTimer();
      } else if (!isWaitingForChoice && !turnTimer) {
        startTurnTimer();
      }
      
      // Toggle interaction based on turn
      toggleInteraction(isMyTurn);
      
      if (isWaitingForChoice) {
        // Show the cards that need to be chosen between
        const faceUpDef = gameState.cardDefinitions[gameState.faceUpCardId];
        const faceDownDef = gameState.cardDefinitions[gameState.faceDownCardId];
        
        // In OPPONENT_PICK phase, the opponent should be able to choose
        // For now, we'll assume if we're in this phase and waiting, we can choose
        const isOpponentTurn = normalizedState.phase === 'OPPONENT_PICK' && normalizedState.waitingForOpponentChoice;
        const isCardSubmitter = normalizedState.phase === 'OPPONENT_PICK' && !normalizedState.waitingForOpponentChoice;
        
        // Get current player's tableaus for effect highlighting using normalized state
        const myTableau = normalizedState.self.tableauCardIds || [];
        const oppTableau = normalizedState.opponent.tableauCardIds || [];
        
        // Debug: Log current state
        console.log('Choice Panel Debug:');
        console.log('  My tableau:', myTableau.map(id => `${id} = ${normalizedState.cardDefinitions[id]?.name || 'Unknown'}`));
        console.log('  Opp tableau:', oppTableau.map(id => `${id} = ${normalizedState.cardDefinitions[id]?.name || 'Unknown'}`));
        console.log('  Face up card ID:', gameState.faceUpCardId);
        console.log('  Face down card ID:', gameState.faceDownCardId);
        console.log('  Face up def:', faceUpDef);
        console.log('  Face down def:', faceDownDef);
        
        // Update Face Up Card display
        const faceUpTitle = document.querySelector('#faceUpCardDisplay .modal-card-title');
        const faceUpEffects = document.querySelector('#faceUpCardDisplay .modal-card-effects');
        
        if (faceUpDef && faceUpTitle && faceUpEffects) {
          faceUpTitle.textContent = faceUpDef.name;
          faceUpEffects.innerHTML = generateEffectsHTMLWithHighlighting(faceUpDef, myTableau, oppTableau);
        } else if (faceUpTitle && faceUpEffects) {
          // Fallback if card definition is missing
          faceUpTitle.textContent = gameState.faceUpCardId || 'Face Up Card';
          faceUpEffects.innerHTML = '<p>Card details loading...</p>';
        }
        
        // Update Face Down Card display
        const faceDownTitle = document.querySelector('#faceDownCardDisplay .modal-card-title');
        const faceDownEffects = document.querySelector('#faceDownCardDisplay .modal-card-effects');
        if (faceDownTitle && faceDownEffects) {
          // If backend sends "???" but we are the card submitter, use our stored card
          let actualFaceDownDef = faceDownDef;
          if (isCardSubmitter && !faceDownDef && myLastFaceDownCard) {
            actualFaceDownDef = gameState.cardDefinitions[myLastFaceDownCard];
            console.log('🎭 Using stored face-down card:', myLastFaceDownCard, '→', actualFaceDownDef?.name);
          }
          
          console.log('Face Down Card logic:', {
            isCardSubmitter: isCardSubmitter,
            backendFaceDownId: gameState.faceDownCardId,
            myStoredCard: myLastFaceDownCard,
            faceDownDef: faceDownDef,
            actualFaceDownDef: actualFaceDownDef,
            playerSeat: playerSeat,
            activePlayer: gameState.activePlayer
          });
          
          if (isCardSubmitter && actualFaceDownDef) {
            // Show complete details to the player who submitted the cards (they know what it is)
            faceDownTitle.textContent = actualFaceDownDef.name + ' (You selected this)';
            faceDownTitle.className = 'modal-card-title';
            faceDownTitle.style.fontStyle = 'italic';
            faceDownTitle.style.color = '#666';
            faceDownEffects.innerHTML = generateEffectsHTMLWithHighlighting(actualFaceDownDef, myTableau, oppTableau);
        } else {
            // Opponent cannot see the face down card details
          faceDownTitle.textContent = '???';
          faceDownTitle.className = 'modal-card-title';
            faceDownTitle.style.fontStyle = 'normal';
            faceDownTitle.style.color = 'inherit';
            faceDownEffects.innerHTML = '<p>Hidden card</p>';
          }
        }
        
        // Show the choice modal
        // Modal removed - using central panel instead
      } else {
        // Modal removed - using central panel instead
      }
    }
    function toggleInteraction(isMyTurn) {
      const phase = gameState.phase || 'PLAY_TWO_CARDS';
      const canInteract = isMyTurn && phase === 'PLAY_TWO_CARDS';
      
      console.log('DEBUG toggleInteraction: isMyTurn =', isMyTurn, 'phase =', phase, 'canInteract =', canInteract);
      
      // Enable/disable hand cards
      const handCards = document.querySelectorAll('.hand .card');
      console.log('DEBUG toggleInteraction: found', handCards.length, 'hand cards');
      handCards.forEach(card => {
        if (canInteract) {
          card.style.pointerEvents = 'auto';
          card.style.opacity = '1';
        } else {
          card.style.pointerEvents = 'none';
          card.style.opacity = '0.5';
        }
      });
      
      // Show/hide play button and selection status
      const playBtn = document.getElementById('playBtn');
      const selectionStatus = document.getElementById('selectionStatus');
      
      if (canInteract && playBtn && selectionStatus) {
        playBtn.style.display = 'block';
        selectionStatus.style.display = 'block';
      } else {
        if (playBtn) playBtn.style.display = 'none';
        if (selectionStatus) selectionStatus.style.display = 'none';
      }
    }

    function checkWinConditions() {
      const normalizedState = normalizeGameState(gameState);
      const winner = normalizedState.winner;
      
      console.log('DEBUG checkWinConditions: winner =', winner, 'selfDotCounter =', normalizedState.selfDotCounter);
      
      const winnerDisplay = document.getElementById('winnerDisplay');
      const winnerText = document.getElementById('winnerText');
      const rematchBtn = document.getElementById('rematchBtn');
      const gameBackToHomeBtn = document.getElementById('gameBackToHomeBtn');
      
      if (winner && winnerDisplay && winnerText) {
        // Show winner message using backend calculation
        winnerDisplay.style.display = 'block';
        
        // Determine if the winner is me or opponent
        const isIWinner = winner === normalizedState.self.name;
        const isOpponentBot = normalizedState.opponent.isBot;
        
        if (isIWinner) {
          // I won!
          winnerText.textContent = '🎉 You Win!';
          winnerText.style.color = '#4CAF50'; // Green for victory
        } else {
          // Opponent won
          if (isOpponentBot) {
            winnerText.textContent = '🤖 ' + winner + ' Wins!';
          winnerText.style.color = '#ff6b6b'; // Red for bot victory
        } else {
            winnerText.textContent = '🎉 ' + winner + ' Wins!';
            winnerText.style.color = '#ff6b6b'; // Red for opponent victory
          }
        }
        
        // Show buttons
        if (rematchBtn) {
          rematchBtn.style.display = 'inline-block';
          rematchBtn.onclick = () => {
            // Reset game or create new match
            location.reload(); // Simple solution for now
          };
        }
        
        if (gameBackToHomeBtn) {
          gameBackToHomeBtn.style.display = 'inline-block';
          gameBackToHomeBtn.onclick = () => {
            showScreen('homeScreen');
          };
        }
        
        log('🎉 Game Over! Winner: ' + winner);
        disableGameControls();
      } else {
        // No winner yet, hide winner display
        if (winnerDisplay) {
        winnerDisplay.style.display = 'none';
        }
      }
    }
    
    // Responsive collapse functionality
    function applyResponsiveCollapse() {
      const gameMain = document.querySelector('.game-main');
      const playerSections = document.querySelectorAll('.player-section');
      const cardSelectionPanel = document.querySelector('.card-selection-panel');
      
      if (!gameMain || !playerSections.length) return;
      
      // DISABLED: No longer adding collapsible classes to prevent hover interference
      
      // DISABLED: Auto-collapse logic that interferes with card interaction
      // Keep all sections expanded for better card interaction
      const activePlayer = gameState?.activePlayer;
      const phase = gameState?.phase;
      
      // DISABLED: No longer manipulating expanded/collapsed classes
    }
    
    // DISABLED: Hover effects removed to prevent interference with card interaction
    function setupHoverEffects() {
      // This function has been disabled to improve card interactivity
    }
    
    function addPlayerNamePill(playerSection, playerName) {
      // Remove existing name pill if any
      const existingPill = playerSection.querySelector('.player-name-pill');
      if (existingPill) {
        existingPill.remove();
      }
      
      // Create name pill
      const namePill = document.createElement('div');
      namePill.className = 'player-name-pill';
      namePill.textContent = playerName;
      
      // Insert after the player-area-label
      const label = playerSection.querySelector('.player-area-label');
      if (label) {
        label.parentNode.insertBefore(namePill, label.nextSibling);
      }
    }
    
    function setupOpponentHandToggle(opponentHandId) {
      // Only setup once to avoid duplicates
      if (document.getElementById('toggleOpponentHand')) {
        return; // Already setup
      }
      
      const opponentHand = document.getElementById(opponentHandId);
      if (!opponentHand) return;
      
      // Find the hand header (h4 that says "Hand:")
      const handHeader = opponentHand.previousElementSibling;
      if (handHeader && handHeader.tagName === 'H4') {
        // Create a container for the header and button
        const headerContainer = document.createElement('div');
        headerContainer.className = 'hand-header';
        
        // Clone the h4 to avoid moving it
        const h4Clone = handHeader.cloneNode(true);
        headerContainer.appendChild(h4Clone);
        
        // Create the toggle button
        const toggleBtn = document.createElement('button');
        toggleBtn.id = 'toggleOpponentHand';
        toggleBtn.className = 'toggle-hand-btn';
        toggleBtn.textContent = '👁️';
        toggleBtn.title = 'Show/Hide opponent hand';
        
        headerContainer.appendChild(toggleBtn);
        
        // Replace the original h4 with the container
        handHeader.parentNode.replaceChild(headerContainer, handHeader);
        
        // Set hand as hidden by default
        opponentHand.classList.add('opponent-hand', 'hidden');
        
        // Add click event
        toggleBtn.addEventListener('click', function() {
          if (opponentHand.classList.contains('hidden')) {
            opponentHand.classList.remove('hidden');
            toggleBtn.textContent = '🙈'; // Hide icon
            toggleBtn.title = 'Hide opponent hand';
          } else {
            opponentHand.classList.add('hidden');
            toggleBtn.textContent = '👁️'; // Show icon
            toggleBtn.title = 'Show opponent hand';
          }
        });
      }
    }

    function disableGameControls() {
      // Disable all game controls when someone wins
      const controls = ['playBtn', 'chooseFaceUpBtn', 'chooseFaceDownBtn'];
      controls.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
          element.disabled = true;
          element.style.opacity = '0.5';
        }
      });
      
      // Clear timers
      clearTimers();
      
      // Disable card selection
      const handCards = document.querySelectorAll('.hand .card');
      handCards.forEach(card => {
        card.style.pointerEvents = 'none';
        card.style.opacity = '0.5';
      });

      // Show rematch and back to home buttons
      const rematchBtn = document.getElementById('rematchBtn');
      const gameBackToHomeBtn = document.getElementById('gameBackToHomeBtn');
      if (rematchBtn) {
        rematchBtn.disabled = false;
        rematchBtn.style.opacity = '1';
        rematchBtn.style.display = 'inline-block';
      }
      if (gameBackToHomeBtn) {
        gameBackToHomeBtn.disabled = false;
        gameBackToHomeBtn.style.opacity = '1';
        gameBackToHomeBtn.style.display = 'inline-block';
      }
    }

    async function chooseFaceUp() {
      if (!matchId) return;
      clearTimers();
      // Hide modal immediately
      // Modal removed - using central panel instead
      const body = JSON.stringify({ chooseFaceUp: true });
      const url = playerSeat !== null ? 
        api + '/api/match/' + matchId + '/choose?seat=' + playerSeat :
        api + '/api/match/' + matchId + '/choose';
      gameState = await req(url, { method:'POST', headers:{'Content-Type':'application/json'}, body });
      log('Opponent chose Face Up card');
      await refresh();
    }

    async function chooseFaceDown() {
      if (!matchId) return;
      clearTimers();
      // Hide modal immediately
      // Modal removed - using central panel instead
      const body = JSON.stringify({ chooseFaceUp: false });
      const url = playerSeat !== null ? 
        api + '/api/match/' + matchId + '/choose?seat=' + playerSeat :
        api + '/api/match/' + matchId + '/choose';
      gameState = await req(url, { method:'POST', headers:{'Content-Type':'application/json'}, body });
      log('Opponent chose Face Down card');
      await refresh();
    }

    // Store the last face-down card we submitted (so we can show it to ourselves later)
    let myLastFaceDownCard = null;

    // Missing function for play selected cards
    async function playSelected() {
      if (!matchId || !selUp || !selDown) { 
        log('Pick two cards'); 
        return; 
      }
      clearTimers();
      
      // Store our face-down card selection locally
      myLastFaceDownCard = selDown;
      console.log('🎭 Storing my face-down card:', selDown);
      
      const body = JSON.stringify({ faceUpId: selUp, faceDownId: selDown });
      const url = playerSeat !== null ? 
        api + '/api/match/' + matchId + '/play?seat=' + playerSeat :
        api + '/api/match/' + matchId + '/play';
      gameState = await req(url, { method:'POST', headers:{'Content-Type':'application/json'}, body });
      log('Played: up=' + selUp + ', down=' + selDown);
      
      // Reset selection after playing
      resetSelection();
      
      await refresh();
    }

    // Add event listener for play button
    const playBtn = document.getElementById('playBtn');
    if (playBtn) {
      playBtn.onclick = playSelected;
    }

    // Add event listeners for rematch and back to home buttons
    const rematchBtn = document.getElementById('rematchBtn');
    if (rematchBtn) {
      rematchBtn.onclick = startRematch;
    }

    const gameBackToHomeBtn = document.getElementById('gameBackToHomeBtn');
    if (gameBackToHomeBtn) {
      gameBackToHomeBtn.onclick = () => {
        // Clear game state and return to home
        clearGameState();
        showScreen('homeScreen');
      };
    }

    async function startRematch() {
      try {
        log('🔄 Starting rematch with same players...');
        
        // Hide winner display immediately
        const winnerDisplay = document.getElementById('winnerDisplay');
        if (winnerDisplay) {
          winnerDisplay.style.display = 'none';
        }
        
        // Show loading message
        log('Resetting game state...');
        
        // Reset all game visuals but keep matchId and playerSeat
        resetGameVisuals();
        
        // Try to call backend rematch endpoint
        try {
          await req(api + '/api/match/' + matchId + '/rematch', { method: 'POST' });
          log('✅ Backend rematch successful');
        } catch (backendError) {
          // If backend endpoint doesn't exist, that's OK - we'll handle it manually
          if (backendError.message.includes('404') || backendError.message.includes('Not Found')) {
            log('⚠️ Backend rematch endpoint not available, using manual reset');
          } else {
            throw backendError; // Re-throw non-404 errors
          }
        }
        
        // Show ready screen for both players to confirm they want to play again
        if (matchId) {
          document.getElementById('displayMatchId').textContent = matchId;
          showScreen('readyScreen');
          
          log('🎮 Ready screen shown. Both players need to set ready again.');
          
          // Start refreshing to get latest state
          await refresh();
          startAutoRefresh();
        } else {
          throw new Error('Match ID is missing');
        }
        
      } catch (error) {
        log('❌ Error starting rematch: ' + error.message);
        alert('Failed to start rematch. Returning to home screen.');
        
        // If any error, go back to home screen
        clearGameState();
        showScreen('homeScreen');
      }
    }
    
    function resetGameVisuals() {
      console.log('🎮 Resetting game visuals for rematch...');
      
      // Reset only visual elements, keep matchId and playerSeat
      gameState = null;
      selUp = null;
      selDown = null;
      myLastFaceDownCard = null; // Clear stored face-down card for new game
      
      // Clear timers
      clearTimers();
      
      // Reset UI elements
      document.getElementById('selUp').textContent = '-';
      document.getElementById('selDown').textContent = '-';
      
      // Clear tableaus and hands
      const tableauA = document.getElementById('tableauA');
      const tableauB = document.getElementById('tableauB');
      const handA = document.getElementById('handA');
      const handB = document.getElementById('handB');
      
      if (tableauA) tableauA.innerHTML = '';
      if (tableauB) tableauB.innerHTML = '';
      if (handA) handA.innerHTML = '';
      if (handB) handB.innerHTML = '';
      
      // Reset dot counter display
      const sharedDotCounter = document.getElementById('sharedDotCounter');
      if (sharedDotCounter) {
        sharedDotCounter.textContent = '0';
      }
      
      // Reset timer display
      const timer = document.getElementById('gameTimer');
      if (timer) {
        timer.textContent = '0s';
        timer.className = 'timer';
      }
      
      // Hide choice modal
      // Modal removed - using central panel instead
      
      // Hide winner display
      const winnerDisplay = document.getElementById('winnerDisplay');
      if (winnerDisplay) {
        winnerDisplay.style.display = 'none';
      }
      
      // Re-enable game controls
      const controls = ['playBtn', 'chooseFaceUpBtn', 'chooseFaceDownBtn'];
      controls.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
          element.disabled = false;
          element.style.opacity = '1';
        }
      });
      
      log('Game visuals reset for rematch');
    }

    function clearGameState() {
      // Clear all game-related variables
      gameState = null;
      matchId = null;
      playerSeat = null;
      selUp = null;
      selDown = null;
      myLastFaceDownCard = null; // Clear stored face-down card
      
      // Clear timers
      clearTimers();
      
      // Stop auto refresh
      if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
        autoRefreshInterval = null;
      }
      
      // Reset UI elements
      document.getElementById('selUp').textContent = '-';
      document.getElementById('selDown').textContent = '-';
      
      // Clear tableaus and hands
      const tableauA = document.getElementById('tableauA');
      const tableauB = document.getElementById('tableauB');
      const handA = document.getElementById('handA');
      const handB = document.getElementById('handB');
      
      if (tableauA) tableauA.innerHTML = '';
      if (tableauB) tableauB.innerHTML = '';
      if (handA) handA.innerHTML = '';
      if (handB) handB.innerHTML = '';
      
      // Reset dot counter display
      const sharedDotCounter = document.getElementById('sharedDotCounter');
      if (sharedDotCounter) {
        sharedDotCounter.textContent = '0';
      }
      
      // Reset timer display
      const timer = document.getElementById('gameTimer');
      if (timer) {
        timer.textContent = '0s';
        timer.className = 'timer';
      }
      
      // Reset timer configuration initialization flags
      const playTwoCardsSelect = document.getElementById('playTwoCardsTime');
      const opponentPickSelect = document.getElementById('opponentPickTime');
      if (playTwoCardsSelect) {
        delete playTwoCardsSelect.dataset.initialized;
      }
      if (opponentPickSelect) {
        delete opponentPickSelect.dataset.initialized;
      }
      
      // Reset player displays
      const playerAName = document.getElementById('playerAName');
      const playerBName = document.getElementById('playerBName');
      const playerAStatus = document.getElementById('playerAStatus');
      const playerBStatus = document.getElementById('playerBStatus');
      
      if (playerAName) playerAName.textContent = '';
      if (playerBName) playerBName.textContent = '';
      if (playerAStatus) playerAStatus.textContent = '';
      if (playerBStatus) playerBStatus.textContent = '';
      
      // Reset active player display
      const activePlayerText = document.querySelector('.game-header p');
      if (activePlayerText) {
        activePlayerText.textContent = 'Active Player: -';
      }
      
      // Reset phase display
      const phaseText = document.querySelector('.game-header p:last-child');
      if (phaseText) {
        phaseText.textContent = 'Phase: WAITING';
      }
      
      // Hide choice modal
      // Modal removed - using central panel instead
      
      // Hide winner display
      const winnerDisplay = document.getElementById('winnerDisplay');
      if (winnerDisplay) {
        winnerDisplay.style.display = 'none';
      }
      
      // Re-enable game controls
      const controls = ['playBtn', 'chooseFaceUpBtn', 'chooseFaceDownBtn'];
      controls.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
          element.disabled = false;
          element.style.opacity = '1';
        }
      });
      
      log('Game state cleared completely for rematch');
    }

    // Function to send timer settings to backend
    async function updateTimerSettings() {
      const playTwoCardsSelect = document.getElementById('playTwoCardsTime');
      const opponentPickSelect = document.getElementById('opponentPickTime');
      
      const playTwoCardsTime = parseInt(playTwoCardsSelect.value);
      const opponentPickTime = parseInt(opponentPickSelect.value);
      
      // Mark that user has manually modified these values
      playTwoCardsSelect.dataset.userModified = 'true';
      opponentPickSelect.dataset.userModified = 'true';
      
      console.log(`⏰ updateTimerSettings called: PLAY_TWO_CARDS=${playTwoCardsTime}s, OPPONENT_PICK=${opponentPickTime}s`);
      console.log(`⏰ matchId=${matchId}, playerToken=${playerToken}`);
      
      if (!matchId || !playerToken) {
        console.log('⏰ No match or token available for timer update - storing locally for when ready is clicked');
        
        // Store values locally to send when ready is clicked
        window.pendingTimerSettings = {
          playTwoCardsTimeSeconds: playTwoCardsTime,
          opponentPickTimeSeconds: opponentPickTime
        };
        console.log('⏰ Stored pending timer settings:', window.pendingTimerSettings);
        return;
      }
      
      try {
        console.log('⏰ Sending timer settings to backend...');
        const response = await fetch(`/api/matches/${matchId}/timer-settings`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Player-Token': playerToken
          },
          body: JSON.stringify({
            playTwoCardsTimeSeconds: playTwoCardsTime,
            opponentPickTimeSeconds: opponentPickTime
          })
        });
        
        if (response.ok) {
          console.log('✅ Timer settings updated successfully');
          // Clear pending settings since they were sent successfully
          delete window.pendingTimerSettings;
        } else {
          const errorText = await response.text();
          console.warn('❌ Failed to update timer settings:', errorText);
        }
      } catch (error) {
        console.error('❌ Error updating timer settings:', error);
      }
    }

    // Force show home screen on load
    document.addEventListener('DOMContentLoaded', function() {
      console.log('DOM loaded, showing home screen');
      showScreen('homeScreen');
      
      // Initialize hover effects for game board
      setupHoverEffects();
      
      // Initialize opponent hand toggle
      setupOpponentHandToggle();
      
      // Setup timer configuration event listeners
      const playTwoCardsTimeSelect = document.getElementById('playTwoCardsTime');
      const opponentPickTimeSelect = document.getElementById('opponentPickTime');
      
      console.log('🎯 EVENT DEBUG: playTwoCardsTimeSelect =', playTwoCardsTimeSelect);
      console.log('🎯 EVENT DEBUG: opponentPickTimeSelect =', opponentPickTimeSelect);
      
      if (playTwoCardsTimeSelect) {
        // Remove existing listeners first
        playTwoCardsTimeSelect.removeEventListener('change', updateTimerSettings);
        playTwoCardsTimeSelect.addEventListener('change', updateTimerSettings);
        console.log('🎯 EVENT DEBUG: Added change listener to playTwoCardsTime');
      }
      
      if (opponentPickTimeSelect) {
        // Remove existing listeners first
        opponentPickTimeSelect.removeEventListener('change', updateTimerSettings);
        opponentPickTimeSelect.addEventListener('change', updateTimerSettings);
        console.log('🎯 EVENT DEBUG: Added change listener to opponentPickTime');
      }
    });

    // Also show home screen immediately
    showScreen('homeScreen');
  </script>
</body>
</html>

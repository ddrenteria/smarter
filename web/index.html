<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Office Duel - Enhanced UI</title>
  <style>
    body { font-family: sans-serif; margin: 20px; background: #f5f5f5; }
    .game-container { 
      display: grid; 
      grid-template-columns: auto 1fr; 
      grid-template-rows: auto 1fr auto; 
      gap: 20px; 
      min-height: 80vh;
    }
    .game-header { grid-column: 2; grid-row: 1; }
    .game-main { grid-column: 2; grid-row: 2; }
    .game-footer { grid-column: 2; grid-row: 3; }
    .game-sidebar { grid-column: 1; grid-row: 1 / 4; }
    .player-section { border: 2px solid #ddd; padding: 20px; border-radius: 12px; background: white; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    .player-section.active { background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); border-color: #2196f3; box-shadow: 0 4px 16px rgba(33, 150, 243, 0.3); }
    .player-section h3 { margin: 0 0 15px 0; font-size: 1.2em; color: #333; }
    .player-area-label { 
      display: inline-block; 
      background: #2196f3; 
      color: white; 
      padding: 4px 12px; 
      border-radius: 20px; 
      font-size: 0.8em; 
      margin-bottom: 10px; 
    }
    .player-area-label.opponent { background: #ff5722; }
    .hand { display: flex; gap: 8px; margin: 10px 0; flex-wrap: wrap; }
    .card {
      width: 140px;
      min-height: 200px;
      padding: 10px;
      border: 2px solid #888;
      border-radius: 8px;
      cursor: pointer;
      background: white;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      justify-content: flex-start;
      text-align: center;
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .card:hover { 
      background: #f0f8ff; 
      border-color: #2196f3; 
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    .card.selected { 
      background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); 
      border-color: #2196f3; 
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
    }
    .card-title { font-weight: bold; margin-bottom: 6px; }
    .card-effects { list-style: none; padding: 0; margin: 0; font-size: 12px; text-align: left; }
    .card-effects li { color: #000; }
    .card-effects li.active { color: #28a745; font-weight: bold; }
    .tableau { display: flex; gap: 4px; margin: 10px 0; flex-wrap: wrap; }
    .tableau-card {
      width: 140px;
      min-height: 200px;
      padding: 8px;
      border: 2px solid #ccc;
      border-radius: 6px;
      background: #f9f9f9;
      font-size: 12px;
      position: relative;
      display: flex;
      flex-direction: column;
      text-align: center;
    }
    .stacked-card { position: relative; }
    .card-count-badge { 
      position: absolute; 
      top: -8px; 
      right: -8px; 
      background: #ff4444; 
      color: white; 
      border-radius: 50%; 
      width: 20px; 
      height: 20px; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      font-size: 10px; 
      font-weight: bold; 
      border: 2px solid white;
    }
    .card-tooltip { position: relative; }
    .card-tooltip:hover .tooltip-content { display: block; }
    .tooltip-content { 
      display: none; position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); 
      background: #333; color: white; padding: 8px; border-radius: 4px; white-space: nowrap; 
      z-index: 1000; font-size: 12px; max-width: 300px; white-space: normal;
    }
    .log { white-space: pre-wrap; font-family: monospace; max-height: 200px; overflow: auto; border: 1px solid #eee; padding: 8px; background: #f9f9f9; }
    .controls { 
      margin: 20px 0; 
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    
    .controls button {
      background: #4caf50;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      transition: all 0.3s ease;
    }
    
    .controls button:hover:not(:disabled) {
      background: #45a049;
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    
    .controls button:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    .status { font-weight: bold; margin: 10px 0; }
    
    .choice-cards {
      display: flex;
      gap: 20px;
      margin: 10px 0;
    }
    
    .choice-card {
      border: 2px solid #28a745;
      border-radius: 8px;
      padding: 15px;
      background: #f8f9fa;
      text-align: center;
      flex: 1;
    }
    
    .choice-card button {
      margin-top: 10px;
      padding: 8px 16px;
      background: #28a745;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .choice-card button:hover {
      background: #218838;
    }
    
    .shared-counter {
      text-align: center;
      margin: 20px 0;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 12px;
      color: white;
      min-width: 200px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    
    .dot-display {
      margin: 15px 0;
    }
    
    .dot-value {
      font-size: 48px;
      font-weight: bold;
      margin: 10px 0;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    
    .dot-labels {
      display: flex;
      justify-content: space-between;
      font-size: 14px;
      margin-top: 10px;
    }
    
    .player-label {
      background: rgba(255,255,255,0.2);
      padding: 5px 10px;
      border-radius: 15px;
    }
    
    .neutral-label {
      background: rgba(255,255,255,0.3);
      padding: 5px 10px;
      border-radius: 15px;
      font-weight: bold;
    }
    
    .winner-display {
      margin-top: 15px;
      padding: 15px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      border: 2px solid #fff;
    }
    
    .winner-display h2 {
      margin: 0;
      color: #fff;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }
    
    /* Enhanced Timer Styling */
    .timer-display {
      display: inline-block;
      padding: 8px 16px;
      border-radius: 20px;
      font-weight: bold;
      font-size: 1.1em;
      transition: all 0.3s ease;
      background: #4caf50;
      color: white;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    .timer-display.warning { background: #ff9800; }
    .timer-display.danger { background: #f44336; animation: pulse 1s infinite; }
    @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
    
    /* Game Status Enhancements */
    .game-status {
      background: white;
      padding: 15px;
      border-radius: 8px;
      margin: 10px 0;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border-left: 4px solid #2196f3;
    }
    
    /* Enhanced Choice Modal */
    .choice-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    .choice-modal-content {
      background: white;
      padding: 30px;
      border-radius: 12px;
      max-width: 600px;
      width: 90%;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    }
    
    .choice-btn {
      background: #2196f3;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 1.1em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 2px 8px rgba(33, 150, 243, 0.3);
    }
    
    .choice-btn:hover {
      background: #1976d2;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
    }
    
    .choice-btn:active {
      transform: translateY(0);
    }
    
    /* Layout specific styles */
    .game-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 0;
    }
    
    .timer-top-right {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 100;
    }
    
    .enemy-area {
      margin-bottom: 20px;
    }
    
    .player-area {
      margin-top: 20px;
    }
    
    /* Play Cards Section */
    .play-cards-section {
      margin-top: 20px;
      padding: 15px;
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      border-radius: 8px;
      border: 2px solid #dee2e6;
    }
    
    .play-selected-btn {
      background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 1.1em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
      width: 100%;
      margin-top: 10px;
    }
    
    .play-selected-btn:hover {
      background: linear-gradient(135deg, #218838 0%, #1aa179 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(40, 167, 69, 0.4);
    }
    
    .play-selected-btn:active {
      transform: translateY(0);
    }
    
    .play-selected-btn:disabled {
      background: #6c757d;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    /* Modal Card Display */
    .modal-card-display {
      background: white;
      border: 2px solid #ddd;
      border-radius: 8px;
      padding: 15px;
      margin: 10px 0;
      min-height: 120px;
      display: flex;
      flex-direction: column;
    }
    
    .modal-card-title {
      font-weight: bold;
      font-size: 1.1em;
      color: #333;
      margin-bottom: 10px;
      text-align: center;
    }
    
    .modal-card-effects {
      font-size: 0.9em;
      color: #666;
      line-height: 1.4;
    }
    
    .modal-card-effects ul {
      margin: 0;
      padding-left: 20px;
      list-style-type: disc;
    }
    
    .modal-card-effects li {
      margin: 4px 0;
    }
    
    .modal-card-title.hidden-card {
      color: #666 !important;
      font-style: italic !important;
      position: relative;
    }
    
    .modal-card-title.hidden-card::after {
      content: " (Hidden)";
      font-size: 0.8em;
      color: #999;
    }
  </style>
</head>
<body>
  <h1>Office Duel - Enhanced UI</h1>
  
  <!-- Lobby/Join UI -->
  <div id="lobbySection" class="controls">
    <div id="joinPrompt" style="display: none;">
      <h3>Join Match</h3>
      <input id="playerName" type="text" placeholder="Enter your name" style="width:200px;" />
      <button id="joinMatchBtn">Join Match</button>
    </div>
    <div id="lobbyInfo" style="display: none;">
      <h3>Waiting Room</h3>
      <div>Player A: <span id="playerAName">-</span> <span id="playerAReady">(Not Ready)</span></div>
      <div>Player B: <span id="playerBName">-</span> <span id="playerBReady">(Not Ready)</span></div>
      <button id="readyBtn" style="display: none;">I'm Ready!</button>
      <div id="waitingMessage">Waiting for both players to be ready...</div>
    </div>
  </div>

  <div class="controls">
    <button id="createBtn">Create Match</button>
    <button id="createBotBtn">ðŸ¤– Create Match with Bot</button>
    Seed: <input id="seed" type="number" value="123" style="width:120px;" />
    | Join: <input id="joinId" type="text" placeholder="match-id" style="width:260px;" />
    <button id="joinBtn">Join</button>
    <span id="matchId"></span>
    <button id="copyMatchIdBtn" style="display: none; margin-left: 10px;">ðŸ“‹ Copy Match ID</button>
  </div>
  
  <div class="controls">
    <button id="refreshBtn">Refresh</button>
    <button id="autoBtn">Auto Turn</button>
  </div>

  <div class="game-container" id="gameContainer" style="display: none;">
    <!-- Timer in top right -->
    <div class="timer-top-right">
      <div class="status">Timer: <span id="timer" class="timer-display">-</span></div>
    </div>
    
    <!-- Left Sidebar - Shared Counter -->
    <div class="game-sidebar">
      <div class="shared-counter">
        <h3>Shared Dot Counter</h3>
        <div class="dot-display">
          <div class="dot-value" id="dotCounter">0</div>
          <div class="dot-labels">
            <span class="player-label">B Wins (-5)</span>
            <span class="neutral-label">Neutral (0)</span>
            <span class="player-label">A Wins (+5)</span>
          </div>
        </div>
        <div id="winnerDisplay" class="winner-display" style="display: none;">
          <h2 id="winnerText">Game Over!</h2>
        </div>
      </div>
    </div>
    
    <!-- Game Header -->
    <div class="game-header">
      <div class="status">Active Player: <span id="active">-</span></div>
      <div class="status">Phase: <span id="phase">-</span></div>
    </div>
    
    <!-- Main Game Area -->
    <div class="game-main">
      <!-- Enemy Area (Top) -->
      <div class="player-section enemy-area" id="playerA">
        <div class="player-area-label opponent">Opponent Area</div>
        <h3 id="playerATitle">Player A</h3>
        <div class="status">Hand: <span id="handSizeA">-</span> cards</div>
        <div class="status">Tableau: <span id="tableauSizeA">-</span> cards</div>
        <h4>Hand:</h4>
        <div class="hand" id="handA"></div>
        <h4>Tableau:</h4>
        <div class="tableau" id="tableauA"></div>
      </div>

      <!-- Your Area (Bottom) -->
      <div class="player-section player-area" id="playerB">
        <div class="player-area-label">Your Area</div>
        <h3 id="playerBTitle">Player B</h3>
        <div class="status">Hand: <span id="handSizeB">-</span> cards</div>
        <div class="status">Tableau: <span id="tableauSizeB">-</span> cards</div>
        <h4>Hand:</h4>
        <div class="hand" id="handB"></div>
        <h4>Tableau:</h4>
        <div class="tableau" id="tableauB"></div>
        
        <!-- Play Cards Section -->
        <div class="play-cards-section">
          <div class="status" id="selectionStatus">Selected: Face Up=<span id="selUp">-</span>, Face Down=<span id="selDown">-</span></div>
          <button id="playBtn" class="play-selected-btn" style="display: none;">ðŸŽ¯ Play Selected Cards</button>
        </div>
      </div>
    </div>
    
    <!-- Game Footer -->
    <div class="game-footer">
      <!-- Footer content can be added here if needed -->
    </div>
  </div>

    <!-- Enhanced Card Choice Modal -->
    <div id="choiceModal" class="choice-modal" style="display: none;">
      <div class="choice-modal-content">
        <h2 id="choiceModalTitle">Choose Between These Cards</h2>
        <div class="choice-cards">
          <div class="choice-card">
            <h4>Face Up Card</h4>
            <div class="modal-card-display" id="faceUpCardDisplay">
              <div class="modal-card-title">-</div>
              <div class="modal-card-effects">-</div>
            </div>
            <button id="chooseFaceUpBtn" onclick="chooseFaceUp()" class="choice-btn">Choose This One</button>
          </div>
          <div class="choice-card">
            <h4>Face Down Card</h4>
            <div class="modal-card-display" id="faceDownCardDisplay">
              <div class="modal-card-title">???</div>
              <div class="modal-card-effects">???</div>
            </div>
            <button id="chooseFaceDownBtn" onclick="chooseFaceDown()" class="choice-btn">Choose This One</button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Fallback choice status for non-modal display -->
    <div class="status" id="choiceStatus" style="display: none;">
      <h4>Opponent must choose between these two cards:</h4>
      <div class="choice-cards">
        <div class="choice-card">
          <strong>Face Up Card:</strong> <span id="faceUpCard">-</span>
          <button id="chooseFaceUpBtnFallback" onclick="chooseFaceUp()">Choose This One</button>
        </div>
        <div class="choice-card">
          <strong>Face Down Card:</strong> <span id="faceDownCard">-</span>
          <button id="chooseFaceDownBtnFallback" onclick="chooseFaceDown()">Choose This One</button>
        </div>
      </div>
    </div>
    <button id="playBtn" style="display: none;">Play Selected</button>
  </div>

  <h3>Game Log</h3>
  <div id="log" class="log"></div>

  <script>
    const api = 'https://smarter.onrender.com';
    let matchId = '';
    let playerSeat = null;
    let playerName = null;
    
    // Read matchId from URL and check for existing seat
    (function initMatchFromUrl(){
      const url = new URL(window.location.href);
      const pMatch = url.searchParams.get('match');
      if(pMatch){
        matchId = pMatch;
      } else {
        const parts = window.location.pathname.split('/');
        if(parts.length>=3 && parts[1]==='app' && parts[2].length>0){
          matchId = parts[2];
        }
      }
      
      // Check localStorage for existing seat
      const storedSeat = localStorage.getItem('match_' + matchId + '_seat');
      const storedName = localStorage.getItem('match_' + matchId + '_name');
      
      if(storedSeat !== null && storedName !== null){
        playerSeat = parseInt(storedSeat);
        playerName = storedName;
      }
      
      if(matchId){
        document.getElementById('matchId').textContent = 'Match: ' + matchId;
        document.getElementById('copyMatchIdBtn').style.display = 'inline-block';
        if(playerSeat !== null){
          startAutoRefresh();
          refresh();
        } else {
          showJoinPrompt();
        }
      }
    })();
    let gameState = null;
    let selUp = null, selDown = null;
    let turnTimer = null;
    let choiceTimer = null;
    let turnTimeLeft = 30;
    let choiceTimeLeft = 15;

    async function req(url, opts={}) {
      const r = await fetch(url, opts);
      if (!r.ok) throw new Error(await r.text());
      return r.json();
    }

    function log(msg){
      const el = document.getElementById('log');
      el.textContent += msg + "\n";
      el.scrollTop = el.scrollHeight;
    }

    function renderCard(cardId, cardDef, isSelectable = false, realCardId = null) {
      const div = document.createElement('div');
      div.className = 'card-tooltip';
      
      // Use real card ID for backend, display ID for UI
      const realId = realCardId || cardId;
      const displayId = cardId;
      
        const btn = document.createElement('button');
      btn.className = 'card' + (isSelectable && (selUp === displayId || selDown === displayId) ? ' selected' : '');
      //btn.textContent = displayId + (cardDef ? (' - ' + cardDef.name) : '');
      btn.setAttribute('data-real-id', realId); // Store real ID for backend
      
      // Build inner layout: title + effects list
      if(cardDef){
          const title = document.createElement('div');
          title.className = 'card-title';
          title.textContent = cardDef.name;
          btn.appendChild(title);
          const ul = document.createElement('ul');
          ul.className = 'card-effects';
          // Show first 3 tiers descriptions (first action per tier)
          cardDef.tiers.forEach((tier, idx)=>{
             const li=document.createElement('li');
             li.textContent = (idx+1)+'. '+ (tier.actions[0]?.description || '');
             ul.appendChild(li);
          });
          btn.appendChild(ul);
      } else {
          btn.textContent = displayId;
      }
      
      // Only allow selection if it's selectable AND not waiting for opponent choice
      const canSelect = isSelectable && !gameState.waitingForOpponentChoice;
      
      if (canSelect) {
        btn.onclick = () => {
          if (!selUp) selUp = realId; // Use real ID for backend
          else if (!selDown && realId !== selUp) selDown = realId; 
          else { selUp = realId; selDown = null; }
          document.getElementById('selUp').textContent = selUp || '-';
          document.getElementById('selDown').textContent = selDown || '-';
          // Don't re-render hands, just update the visual selection
          updateCardSelection();
        };
      }
      
      if (cardDef) {
        const tooltip = document.createElement('div');
        tooltip.className = 'tooltip-content';
        tooltip.innerHTML = generateCardTooltip(cardDef);
        div.appendChild(tooltip);
      }
      
      div.appendChild(btn);
      return div;
    }

    function generateCardTooltip(cardDef) {
      let html = `<strong>${cardDef.name}</strong><br>`;
      html += `Tags: ${cardDef.tags.join(', ')}<br><br>`;
      
      cardDef.tiers.forEach((tier, index) => {
        html += `<strong>Tier ${index + 1}:</strong><br>`;
        tier.actions.forEach(action => {
          html += `â€¢ ${action.description}<br>`;
        });
        html += '<br>';
      });
      
      return html;
    }

    function generateEffectsHTML(cardDef) {
      let html = '<ul>';
      cardDef.tiers.forEach((tier, index) => {
        tier.actions.forEach(action => {
          html += `<li><strong>Tier ${index + 1}:</strong> ${action.description}</li>`;
        });
      });
      html += '</ul>';
      return html;
    }

    function renderHands() {
      if (!gameState || playerSeat === null) return;
      
      // Determine which hand divs belong to me vs opponent
      const myHandDiv = playerSeat === 0 ? document.getElementById('handA') : document.getElementById('handB');
      const oppHandDiv = playerSeat === 0 ? document.getElementById('handB') : document.getElementById('handA');
      
      // Clear both hands
      myHandDiv.innerHTML = '';
      oppHandDiv.innerHTML = '';
      
      // Render my hand with real cards
      if (gameState.activeHandCardIds && gameState.activeHandCardIds.length > 0) {
        const cardCounts = {};
        gameState.activeHandCardIds.forEach(id => {
          cardCounts[id] = (cardCounts[id] || 0) + 1;
        });
        
        Object.keys(cardCounts).forEach(id => {
          const count = cardCounts[id];
          const cardDef = gameState.cardDefinitions[id];
          for (let i = 0; i < count; i++) {
            const uniqueId = count > 1 ? `${id}_${i}` : id;
            myHandDiv.appendChild(renderCard(uniqueId, cardDef, true, id));
          }
        });
      }
      
      // Render opponent hand with card backs (dots)
      const oppHandSize = playerSeat === 0 ? gameState.handSizeB : gameState.handSizeA;
      for (let i = 0; i < oppHandSize; i++) {
        const cardBack = document.createElement('div');
        cardBack.className = 'card-tooltip';
        cardBack.style.width = '140px';
        cardBack.style.height = '200px';
        cardBack.style.border = '2px solid #666';
        cardBack.style.borderRadius = '8px';
        cardBack.style.backgroundColor = '#333';
        cardBack.style.display = 'flex';
        cardBack.style.alignItems = 'center';
        cardBack.style.justifyContent = 'center';
        cardBack.style.fontSize = '24px';
        cardBack.style.color = '#fff';
        cardBack.textContent = '?';
        oppHandDiv.appendChild(cardBack);
      }
    }

    function renderTableaus() {
      if (!gameState) return;
      
      // Render Player A tableau
      const tableauA = document.getElementById('tableauA');
      tableauA.innerHTML = '';
      const cardCountsA = {};
      gameState.tableauCardIdsA.forEach(id => {
        cardCountsA[id] = (cardCountsA[id] || 0) + 1;
      });
      
      Object.keys(cardCountsA).forEach(id => {
        const count = cardCountsA[id];
        const cardDef = gameState.cardDefinitions[id];
        const stackedCard = renderStackedCard(id, cardDef, count);
        tableauA.appendChild(stackedCard);
      });
      
      // Render Player B tableau
      const tableauB = document.getElementById('tableauB');
      tableauB.innerHTML = '';
      const cardCountsB = {};
      gameState.tableauCardIdsB.forEach(id => {
        cardCountsB[id] = (cardCountsB[id] || 0) + 1;
      });
      
      Object.keys(cardCountsB).forEach(id => {
        const count = cardCountsB[id];
        const cardDef = gameState.cardDefinitions[id];
        const stackedCard = renderStackedCard(id, cardDef, count);
        tableauB.appendChild(stackedCard);
      });
    }

    function renderStackedCard(cardId, cardDef, count) {
      const div = document.createElement('div');
      div.className = 'card-tooltip stacked-card';
      
      const btn = document.createElement('button');
      btn.className = 'tableau-card';
      //btn.textContent = cardId + (cardDef ? (' - ' + cardDef.name) : '');
      btn.style.width = '140px';
      btn.style.minHeight = '200px';
      btn.style.position='relative';
      
      if(cardDef){
          const title=document.createElement('div');
          title.className='card-title';
          title.textContent=cardDef.name;
          btn.appendChild(title);
          const ul=document.createElement('ul');
          ul.className='card-effects';
          cardDef.tiers.forEach((tier,idx)=>{
              const li=document.createElement('li');
              li.textContent=(idx+1)+'. '+(tier.actions[0]?.description||'');
              if(idx===Math.min(count-1,2)) li.classList.add('active');
              ul.appendChild(li);
          });
          btn.appendChild(ul);
      } else {
          btn.textContent=cardId;
      }
      
      // Add count badge if more than 1
      if (count > 1) {
        const badge = document.createElement('span');
        badge.className = 'card-count-badge';
        badge.textContent = count;
        btn.appendChild(badge);
      }
      
      if (cardDef) {
        const tooltip = document.createElement('div');
        tooltip.className = 'tooltip-content';
        tooltip.innerHTML = generateCardTooltip(cardDef);
        div.appendChild(tooltip);
      }
      
      div.appendChild(btn);
      return div;
    }

    async function createMatch() {
      const seed = Number(document.getElementById('seed').value || '0');
      const data = await req(api + '/api/match?seed=' + seed, { method:'POST', headers:{'Content-Type':'application/json'}, body:'{}' });
      matchId = data.id;
      document.getElementById('matchId').textContent = 'Match: ' + matchId;
      document.getElementById('copyMatchIdBtn').style.display = 'inline-block';
      window.location.assign('/?match=' + matchId); // navigate so friend can copy URL
    }

    async function createMatchWithBot() {
      const seed = Number(document.getElementById('seed').value || '0');
      const data = await req(api + '/api/match/bot?seed=' + seed, { method:'POST', headers:{'Content-Type':'application/json'}, body:'{}' });
      matchId = data.id;
      document.getElementById('matchId').textContent = 'Match: ' + matchId;
      document.getElementById('copyMatchIdBtn').style.display = 'inline-block';
      
      // Join as Player B (human player)
      const name = prompt('Enter your name for the bot match:');
      if (!name) return;
      
      try {
        const response = await req(api + '/api/match/' + matchId + '/join', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: name })
        });

        playerSeat = response.seat;
        playerName = name;
        
        // Store in localStorage
        localStorage.setItem('match_' + matchId + '_seat', playerSeat);
        localStorage.setItem('match_' + matchId + '_name', playerName);
        
        log('Joined bot match as Player ' + (playerSeat === 0 ? 'A' : 'B'));
        
        startAutoRefresh();
        refresh();
      } catch (error) {
        alert('Failed to join bot match: ' + error.message);
      }
    }

    function joinMatch(){
      const id = document.getElementById('joinId').value.trim();
      if(id){ window.location.assign('/?match=' + id); }
    }

    async function refresh() {
      if (!matchId) return;
      
      const url = playerSeat !== null ? 
        api + '/api/match/' + matchId + '?seat=' + playerSeat :
        api + '/api/match/' + matchId;
      
      gameState = await req(url);
      
      // Handle lobby state
      if (!gameState.started) {
        showLobby();
        return;
      }
      
      // Game started - show game UI
      showGame();
      
      // Update player info
      document.getElementById('handSizeA').textContent = gameState.handSizeA;
      document.getElementById('handSizeB').textContent = gameState.handSizeB;
      document.getElementById('tableauSizeA').textContent = gameState.tableauSizeA;
      document.getElementById('tableauSizeB').textContent = gameState.tableauSizeB;
      document.getElementById('active').textContent = gameState.activePlayer === 0 ? 'A' : 'B';
      document.getElementById('phase').textContent = gameState.phase || 'PLAY_TWO_CARDS';
      
      // Update player names and area labels based on current player
      const playerAName = gameState.playerA || 'Player A';
      const playerBName = gameState.playerB || 'Player B';
      document.getElementById('playerATitle').textContent = playerAName;
      document.getElementById('playerBTitle').textContent = playerBName;
      
      // Update area labels based on current player perspective
      const playerALabel = document.querySelector('#playerA .player-area-label');
      const playerBLabel = document.querySelector('#playerB .player-area-label');
      
      if (playerSeat === 0) {
        // Current player is Player A
        playerALabel.textContent = 'Your Area';
        playerALabel.className = 'player-area-label';
        playerBLabel.textContent = 'Opponent Area';
        playerBLabel.className = 'player-area-label opponent';
      } else if (playerSeat === 1) {
        // Current player is Player B
        playerALabel.textContent = 'Opponent Area';
        playerALabel.className = 'player-area-label opponent';
        playerBLabel.textContent = 'Your Area';
        playerBLabel.className = 'player-area-label';
      }
      
      // Update dot counter with enhanced visual feedback
      const dotCounter = gameState.sharedDotCounter;
      const dotCounterElement = document.getElementById('dotCounter');
      dotCounterElement.textContent = dotCounter;
      
      // Update counter styling based on value
      dotCounterElement.className = 'dot-value';
      if (dotCounter >= 5) {
        dotCounterElement.style.color = '#4caf50'; // Green for Player A winning
        dotCounterElement.style.textShadow = '0 0 10px rgba(76, 175, 80, 0.5)';
      } else if (dotCounter <= -5) {
        dotCounterElement.style.color = '#f44336'; // Red for Player B winning
        dotCounterElement.style.textShadow = '0 0 10px rgba(244, 67, 54, 0.5)';
      } else {
        dotCounterElement.style.color = '#fff'; // White for neutral
        dotCounterElement.style.textShadow = '2px 2px 4px rgba(0,0,0,0.3)';
      }
      
      // Check win conditions
      checkWinConditions();
      
      // Update active player highlighting with enhanced visual feedback
      const playerAElement = document.getElementById('playerA');
      const playerBElement = document.getElementById('playerB');
      
      playerAElement.classList.toggle('active', gameState.activePlayer === 0);
      playerBElement.classList.toggle('active', gameState.activePlayer === 1);
      
      // Add active turn indicator to player titles
      const playerATitle = document.getElementById('playerATitle');
      const playerBTitle = document.getElementById('playerBTitle');
      
      if (gameState.activePlayer === 0) {
        playerATitle.innerHTML = (gameState.playerA || 'Player A') + ' <span style="color: #4caf50; font-size: 0.8em;">ðŸŸ¢ Your Turn</span>';
        playerBTitle.textContent = gameState.playerB || 'Player B';
      } else {
        playerATitle.textContent = gameState.playerA || 'Player A';
        playerBTitle.innerHTML = (gameState.playerB || 'Player B') + ' <span style="color: #4caf50; font-size: 0.8em;">ðŸŸ¢ Your Turn</span>';
      }
      
      // Update UI based on phase
      updateUIForPhase();
      
      // Render hands and tableaus
      renderHands();
      renderTableaus();
      
      // Ensure interaction is properly toggled
      const isMyTurn = playerSeat !== null && playerSeat === gameState.activePlayer;
      toggleInteraction(isMyTurn);
      
      // Auto-play bot turns
      if (gameState.started) {
        const isPlayerABot = gameState.playerAIsBot;
        const isPlayerBBot = gameState.playerBIsBot;
        const activePlayer = gameState.activePlayer;
        const phase = gameState.phase;
        const inactivePlayer = 1 - activePlayer;
        
        console.log('Bot check: started=' + gameState.started + ', isPlayerABot=' + isPlayerABot + ', isPlayerBBot=' + isPlayerBBot + ', activePlayer=' + activePlayer + ', phase=' + phase);
        
        let shouldAct = false;
        let delay = 1000;
        let action = 'playing';
        
        if (phase === 'PLAY_TWO_CARDS') {
          // Submit phase: only active player bot acts
          if ((activePlayer === 0 && isPlayerABot) || (activePlayer === 1 && isPlayerBBot)) {
            shouldAct = true;
            delay = 1000; // 1 second to select cards
            action = 'selecting cards';
          }
        } else if (phase === 'OPPONENT_PICK') {
          // Choice phase: only inactive player bot acts
          if ((inactivePlayer === 0 && isPlayerABot) || (inactivePlayer === 1 && isPlayerBBot)) {
            shouldAct = true;
            delay = 3000; // 3 seconds to choose between cards
            action = 'choosing between cards';
          }
        }
        
        if (shouldAct) {
          console.log('Bot will ' + action + ' in ' + delay + 'ms');
          setTimeout(async () => {
            try {
              await req(api + '/api/match/' + matchId + '/bot-turn?seat=' + playerSeat, { method: 'POST' });
              log('Bot ' + action + ' automatically');
            } catch (error) {
              console.log('Bot auto-play failed:', error);
            }
          }, delay);
        }
      }
    }

    function toggleInteraction(isMyTurn) {
      const phase = gameState.phase || 'PLAY_TWO_CARDS';
      const canInteract = isMyTurn && phase === 'PLAY_TWO_CARDS';
      
      // Enable/disable hand cards
      const handCards = document.querySelectorAll('.hand .card');
      handCards.forEach(card => {
        if (canInteract) {
          card.style.pointerEvents = 'auto';
          card.style.opacity = '1';
        } else {
          card.style.pointerEvents = 'none';
          card.style.opacity = '0.5';
        }
      });
      
      // Show/hide play button and selection status
      const playBtn = document.getElementById('playBtn');
      const selectionStatus = document.getElementById('selectionStatus');
      
      if (canInteract) {
        playBtn.style.display = 'block';
        selectionStatus.style.display = 'block';
      } else {
        playBtn.style.display = 'none';
        selectionStatus.style.display = 'none';
      }
    }

    function updateUIForPhase() {
      const isWaitingForChoice = gameState.waitingForOpponentChoice;
      const phase = gameState.phase || 'PLAY_TWO_CARDS';
      const isMyTurn = playerSeat !== null && playerSeat === gameState.activePlayer;
      
      // Show/hide selection status
      document.getElementById('selectionStatus').style.display = isWaitingForChoice ? 'none' : 'block';
      document.getElementById('choiceStatus').style.display = isWaitingForChoice ? 'block' : 'none';
      
      // Show/hide buttons
      document.getElementById('playBtn').style.display = !isWaitingForChoice ? 'block' : 'none';
      
      // Start appropriate timer only if not already running
      if (isWaitingForChoice && !choiceTimer) {
        startChoiceTimer();
      } else if (!isWaitingForChoice && !turnTimer) {
        startTurnTimer();
      }
      
      // Toggle interaction based on turn
      toggleInteraction(isMyTurn);
      
      if (isWaitingForChoice) {
        // Show the cards that need to be chosen between
        const faceUpDef = gameState.cardDefinitions[gameState.faceUpCardId];
        const faceDownDef = gameState.cardDefinitions[gameState.faceDownCardId];
        
        // Only show choice buttons to the opponent (not the player who submitted the cards)
        const isOpponentTurn = playerSeat !== null && playerSeat !== gameState.activePlayer;
        const isCardSubmitter = playerSeat !== null && playerSeat === gameState.activePlayer;
        
        // Update Face Up Card display
        const faceUpTitle = document.querySelector('#faceUpCardDisplay .modal-card-title');
        const faceUpEffects = document.querySelector('#faceUpCardDisplay .modal-card-effects');
        
        if (faceUpDef) {
          faceUpTitle.textContent = faceUpDef.name;
          faceUpEffects.innerHTML = generateEffectsHTML(faceUpDef);
        } else {
          faceUpTitle.textContent = gameState.faceUpCardId;
          faceUpEffects.textContent = 'Unknown card';
        }
        
        // Update Face Down Card display
        const faceDownTitle = document.querySelector('#faceDownCardDisplay .modal-card-title');
        const faceDownEffects = document.querySelector('#faceDownCardDisplay .modal-card-effects');
        if (isCardSubmitter && faceDownDef) {
          // Show hidden card details to the player who submitted the cards
          faceDownTitle.textContent = faceDownDef.name + ' (Hidden)';
          faceDownTitle.className = 'modal-card-title hidden-card';
          faceDownEffects.innerHTML = generateEffectsHTML(faceDownDef);
        } else {
          // Keep it hidden for the opponent
          faceDownTitle.textContent = '???';
          faceDownTitle.className = 'modal-card-title';
          faceDownEffects.textContent = 'Hidden card';
        }
        
        // Update fallback content
        document.getElementById('faceUpCard').textContent = 
          gameState.faceUpCardId + (faceUpDef ? (' - ' + faceUpDef.name) : '');
        document.getElementById('faceDownCard').textContent = 
          (isCardSubmitter && faceDownDef) ? (gameState.faceDownCardId + ' - ' + faceDownDef.name + ' (Hidden)') : '???';
        
        if (isOpponentTurn) {
          // Show modal for opponent to choose
          document.getElementById('choiceModal').style.display = 'flex';
          document.getElementById('choiceModalTitle').textContent = 'Choose Between These Cards';
          // Show choice buttons in modal
          document.querySelectorAll('#choiceModal .choice-btn').forEach(btn => btn.style.display = 'block');
        } else {
          // Show waiting message for active player
          document.getElementById('choiceModal').style.display = 'flex';
          document.getElementById('choiceModalTitle').textContent = 'Waiting for opponent to choose...';
          // Hide choice buttons in modal
          document.querySelectorAll('#choiceModal .choice-btn').forEach(btn => btn.style.display = 'none');
        }
        
        // Update fallback display
        const choiceButtons = document.querySelectorAll('#chooseFaceUpBtnFallback, #chooseFaceDownBtnFallback');
        choiceButtons.forEach(btn => {
          btn.style.display = isOpponentTurn ? 'block' : 'none';
        });
        
        // Show appropriate message in fallback
        const choiceStatus = document.getElementById('choiceStatus');
        if (isOpponentTurn) {
          choiceStatus.querySelector('h4').textContent = 'Choose between these two cards:';
        } else {
          choiceStatus.querySelector('h4').textContent = 'Waiting for opponent to choose...';
        }
      } else {
        // Hide modal when not waiting for choice
        document.getElementById('choiceModal').style.display = 'none';
        // Only reset selection if we're not in the middle of selecting cards
        // Don't reset if we already have cards selected
        if (!selUp && !selDown) {
          document.getElementById('selUp').textContent = '-';
          document.getElementById('selDown').textContent = '-';
        }
      }
    }

    async function autoTurn() {
      if (!matchId) return;
      const url = playerSeat !== null ? 
        api + '/api/match/' + matchId + '/auto?seat=' + playerSeat :
        api + '/api/match/' + matchId + '/auto';
      await req(url, { method:'POST' });
      log('Auto turn submitted');
      await refresh();
    }

    async function playSelected() {
      if (!matchId || !selUp || !selDown) { log('Pick two cards'); return; }
      clearTimers();
      const body = JSON.stringify({ faceUpId: selUp, faceDownId: selDown });
      const url = playerSeat !== null ? 
        api + '/api/match/' + matchId + '/play?seat=' + playerSeat :
        api + '/api/match/' + matchId + '/play';
      gameState = await req(url, { method:'POST', headers:{'Content-Type':'application/json'}, body });
      log('Played: up=' + selUp + ', down=' + selDown);
      
      // Reset selection after playing
      resetSelection();
      
      await refresh();
    }

    async function chooseFaceUp() {
      if (!matchId) return;
      clearTimers();
      // Hide modal immediately
      document.getElementById('choiceModal').style.display = 'none';
      const body = JSON.stringify({ chooseFaceUp: true });
      const url = playerSeat !== null ? 
        api + '/api/match/' + matchId + '/choose?seat=' + playerSeat :
        api + '/api/match/' + matchId + '/choose';
      gameState = await req(url, { method:'POST', headers:{'Content-Type':'application/json'}, body });
      log('Opponent chose Face Up card');
      await refresh();
    }

    async function chooseFaceDown() {
      if (!matchId) return;
      clearTimers();
      // Hide modal immediately
      document.getElementById('choiceModal').style.display = 'none';
      const body = JSON.stringify({ chooseFaceUp: false });
      const url = playerSeat !== null ? 
        api + '/api/match/' + matchId + '/choose?seat=' + playerSeat :
        api + '/api/match/' + matchId + '/choose';
      gameState = await req(url, { method:'POST', headers:{'Content-Type':'application/json'}, body });
      log('Opponent chose Face Down card');
      await refresh();
    }

    document.getElementById('createBtn').onclick = createMatch;
    document.getElementById('createBotBtn').onclick = createMatchWithBot;
    document.getElementById('refreshBtn').onclick = async () => {
      const btn = document.getElementById('refreshBtn');
      const originalText = btn.textContent;
      btn.textContent = 'Refreshing...';
      btn.disabled = true;
      try {
        await refresh();
        btn.textContent = 'âœ“ Refreshed';
        setTimeout(() => {
          btn.textContent = originalText;
          btn.disabled = false;
        }, 1000);
      } catch (error) {
        btn.textContent = 'âœ— Error';
        setTimeout(() => {
          btn.textContent = originalText;
          btn.disabled = false;
        }, 2000);
      }
    };
    document.getElementById('autoBtn').onclick = autoTurn;
    document.getElementById('playBtn').onclick = playSelected;
    document.getElementById('joinBtn').onclick = joinMatch;
    document.getElementById('joinMatchBtn').onclick = joinMatchWithName;
    document.getElementById('readyBtn').onclick = setReady;
    document.getElementById('copyMatchIdBtn').onclick = copyMatchId;

    // Auto-refresh every 2 seconds when there's an active match
    let refreshInterval;
    function startAutoRefresh() {
      if (refreshInterval) clearInterval(refreshInterval);
      refreshInterval = setInterval(async () => {
        if (matchId) {
          try {
            await refresh();
          } catch (e) {
            console.log('Auto-refresh failed:', e);
          }
        }
      }, 2000);
    }

    function stopAutoRefresh() {
      if (refreshInterval) {
        clearInterval(refreshInterval);
        refreshInterval = null;
      }
    }

    function updateCardSelection() {
      // Update visual selection without re-rendering
      const handCards = document.querySelectorAll('.hand .card');
      handCards.forEach(card => {
        const realId = card.getAttribute('data-real-id');
        if (realId === selUp || realId === selDown) {
          card.classList.add('selected');
        } else {
          card.classList.remove('selected');
        }
      });
    }

    function resetSelection() {
      selUp = null;
      selDown = null;
      document.getElementById('selUp').textContent = '-';
      document.getElementById('selDown').textContent = '-';
      updateCardSelection();
    }

    function checkWinConditions() {
      const dots = gameState.sharedDotCounter;
      const winnerDisplay = document.getElementById('winnerDisplay');
      const winnerText = document.getElementById('winnerText');
      
      if (dots >= 5) {
        // Player A wins
        winnerDisplay.style.display = 'block';
        winnerText.textContent = 'ðŸŽ‰ Player A Wins! (+5 dots)';
        winnerText.style.color = '#4CAF50';
        log('ðŸŽ‰ Player A wins with ' + dots + ' dots!');
        disableGameControls();
      } else if (dots <= -5) {
        // Player B wins
        winnerDisplay.style.display = 'block';
        winnerText.textContent = 'ðŸŽ‰ Player B Wins! (-5 dots)';
        winnerText.style.color = '#4CAF50';
        log('ðŸŽ‰ Player B wins with ' + dots + ' dots!');
        disableGameControls();
      } else {
        // No winner yet
        winnerDisplay.style.display = 'none';
      }
    }

    function disableGameControls() {
      // Disable all game controls when someone wins
      const controls = ['playBtn', 'autoBtn', 'chooseFaceUpBtn', 'chooseFaceDownBtn'];
      controls.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
          element.disabled = true;
          element.style.opacity = '0.5';
        }
      });
      
      // Clear timers
      clearTimers();
      
      // Disable card selection
      const handCards = document.querySelectorAll('.hand .card');
      handCards.forEach(card => {
        card.style.pointerEvents = 'none';
        card.style.opacity = '0.5';
      });
    }

    function startTurnTimer() {
      clearTimers();
      turnTimeLeft = 30;
      updateTimerDisplay();
      
      turnTimer = setInterval(() => {
        turnTimeLeft--;
        updateTimerDisplay();
        
        if (turnTimeLeft <= 0) {
          clearTimers();
          log('Turn timer expired! Auto-selecting random cards...');
          autoSelectRandomCards();
        }
      }, 1000);
    }

    function startChoiceTimer() {
      clearTimers();
      choiceTimeLeft = 15;
      updateTimerDisplay();
      
      choiceTimer = setInterval(() => {
        choiceTimeLeft--;
        updateTimerDisplay();
        
        if (choiceTimeLeft <= 0) {
          clearTimers();
          log('Choice timer expired! Auto-selecting random choice...');
          autoSelectRandomChoice();
        }
      }, 1000);
    }
    
    function updateTimerDisplay() {
      const timerElement = document.getElementById('timer');
      const currentTime = turnTimer ? turnTimeLeft : choiceTimeLeft;
      timerElement.textContent = currentTime + 's';
      
      // Update timer styling based on time remaining
      timerElement.className = 'timer-display';
      if (currentTime <= 5) {
        timerElement.classList.add('danger');
      } else if (currentTime <= 10) {
        timerElement.classList.add('warning');
      }
    }

    function clearTimers() {
      if (turnTimer) {
        clearInterval(turnTimer);
        turnTimer = null;
      }
      if (choiceTimer) {
        clearInterval(choiceTimer);
        choiceTimer = null;
      }
    }

    async function autoSelectRandomCards() {
      if (!matchId || !gameState || gameState.waitingForOpponentChoice) return;
      
      const handIds = gameState.activeHandCardIds;
      if (handIds.length < 2) return;
      
      // Select two random cards
      const random1 = handIds[Math.floor(Math.random() * handIds.length)];
      let random2 = handIds[Math.floor(Math.random() * handIds.length)];
      while (random2 === random1 && handIds.length > 1) {
        random2 = handIds[Math.floor(Math.random() * handIds.length)];
      }
      
      selUp = random1;
      selDown = random2;
      document.getElementById('selUp').textContent = selUp;
      document.getElementById('selDown').textContent = selDown;
      
      // Don't call playSelected() here to avoid double reset
      // Instead, make the API call directly
      clearTimers();
      const body = JSON.stringify({ faceUpId: selUp, faceDownId: selDown });
      const url = playerSeat !== null ? 
        api + '/api/match/' + matchId + '/play?seat=' + playerSeat :
        api + '/api/match/' + matchId + '/play';
      gameState = await req(url, { method:'POST', headers:{'Content-Type':'application/json'}, body });
      log('Auto-played: up=' + selUp + ', down=' + selDown);
      
      // Reset selection after playing
      resetSelection();
      
      await refresh();
    }

    async function autoSelectRandomChoice() {
      if (!matchId || !gameState || !gameState.waitingForOpponentChoice) return;
      
      const chooseFaceUp = Math.random() < 0.5;
      if (chooseFaceUp) {
        await chooseFaceUp();
      } else {
        await chooseFaceDown();
      }
    }

    // New Milestone 1 functions
    function showJoinPrompt() {
      document.getElementById('joinPrompt').style.display = 'block';
      document.getElementById('lobbyInfo').style.display = 'none';
      document.getElementById('gameContainer').style.display = 'none';
    }

    function showLobby() {
      document.getElementById('joinPrompt').style.display = 'none';
      document.getElementById('lobbyInfo').style.display = 'block';
      document.getElementById('gameContainer').style.display = 'none';
      
      // Update lobby info
      document.getElementById('playerAName').textContent = gameState.playerA || '-';
      document.getElementById('playerBName').textContent = gameState.playerB || '-';
      document.getElementById('playerAReady').textContent = gameState.readyA ? '(Ready)' : '(Not Ready)';
      document.getElementById('playerBReady').textContent = gameState.readyB ? '(Ready)' : '(Not Ready)';
      
      // Show ready button if this player isn't ready yet
      const readyBtn = document.getElementById('readyBtn');
      const waitingMsg = document.getElementById('waitingMessage');
      
      if (playerSeat === 0 && !gameState.readyA) {
        readyBtn.style.display = 'block';
        waitingMsg.textContent = 'Click "I\'m Ready!" when you\'re ready to start';
      } else if (playerSeat === 1 && !gameState.readyB) {
        readyBtn.style.display = 'block';
        waitingMsg.textContent = 'Click "I\'m Ready!" when you\'re ready to start';
      } else if (!gameState.readyA || !gameState.readyB) {
        readyBtn.style.display = 'none';
        waitingMsg.textContent = 'Waiting for the other player to be ready...';
      } else {
        readyBtn.style.display = 'none';
        waitingMsg.textContent = 'Both players ready! Starting game...';
      }
    }

    function showGame() {
      document.getElementById('joinPrompt').style.display = 'none';
      document.getElementById('lobbyInfo').style.display = 'none';
      document.getElementById('gameContainer').style.display = 'grid';
    }

    async function joinMatchWithName() {
      const name = document.getElementById('playerName').value.trim();
      if (!name) {
        alert('Please enter your name');
        return;
      }

      try {
        const response = await req(api + '/api/match/' + matchId + '/join', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: name })
        });

        playerSeat = response.seat;
        playerName = name;
        
        // Store in localStorage
        localStorage.setItem('match_' + matchId + '_seat', playerSeat);
        localStorage.setItem('match_' + matchId + '_name', playerName);
        
        log('Joined match as Player ' + (playerSeat === 0 ? 'A' : 'B'));
        
        startAutoRefresh();
        refresh();
      } catch (error) {
        alert('Failed to join match: ' + error.message);
      }
    }

    async function setReady() {
      try {
        await req(api + '/api/match/' + matchId + '/ready?seat=' + playerSeat, {
          method: 'POST'
        });
        log('Ready status sent');
        refresh();
      } catch (error) {
        alert('Failed to set ready status: ' + error.message);
      }
    }

    async function copyMatchId() {
      if (!matchId) return;
      
      try {
        // Copy just the match ID to clipboard
        await navigator.clipboard.writeText(matchId);
        
        // Show temporary feedback
        const btn = document.getElementById('copyMatchIdBtn');
        const originalText = btn.textContent;
        btn.textContent = 'âœ… Copied!';
        btn.style.backgroundColor = '#28a745';
        
        setTimeout(() => {
          btn.textContent = originalText;
          btn.style.backgroundColor = '';
        }, 1500);
        
        log('Match ID copied to clipboard: ' + matchId);
      } catch (error) {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = matchId;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        
        log('Match ID copied to clipboard (fallback)');
      }
    }
  </script>
</body>
</html>

